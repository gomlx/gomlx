// Code generated by "enumer -type=DType -yaml -json -text -values"; DO NOT EDIT.

package shapes

import (
	"encoding/json"
	"fmt"
	"strings"
)

const _DTypeName = "InvalidDTypeBoolInt8Int16Int32Int64UInt8UInt16UInt32UInt64Float16Float32Float64TupleOpaqueTypeComplex64BFloat16TokenComplex128"

var _DTypeIndex = [...]uint8{0, 12, 16, 20, 25, 30, 35, 40, 46, 52, 58, 65, 72, 79, 84, 94, 103, 111, 116, 126}

const _DTypeLowerName = "invaliddtypeboolint8int16int32int64uint8uint16uint32uint64float16float32float64tupleopaquetypecomplex64bfloat16tokencomplex128"

func (i DType) String() string {
	if i < 0 || i >= DType(len(_DTypeIndex)-1) {
		return fmt.Sprintf("DType(%d)", i)
	}
	return _DTypeName[_DTypeIndex[i]:_DTypeIndex[i+1]]
}

func (DType) Values() []string {
	return DTypeStrings()
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _DTypeNoOp() {
	var x [1]struct{}
	_ = x[InvalidDType-(0)]
	_ = x[Bool-(1)]
	_ = x[Int8-(2)]
	_ = x[Int16-(3)]
	_ = x[Int32-(4)]
	_ = x[Int64-(5)]
	_ = x[UInt8-(6)]
	_ = x[UInt16-(7)]
	_ = x[UInt32-(8)]
	_ = x[UInt64-(9)]
	_ = x[Float16-(10)]
	_ = x[Float32-(11)]
	_ = x[Float64-(12)]
	_ = x[Tuple-(13)]
	_ = x[OpaqueType-(14)]
	_ = x[Complex64-(15)]
	_ = x[BFloat16-(16)]
	_ = x[Token-(17)]
	_ = x[Complex128-(18)]
}

var _DTypeValues = []DType{InvalidDType, Bool, Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64, Float16, Float32, Float64, Tuple, OpaqueType, Complex64, BFloat16, Token, Complex128}

var _DTypeNameToValueMap = map[string]DType{
	_DTypeName[0:12]:         InvalidDType,
	_DTypeLowerName[0:12]:    InvalidDType,
	_DTypeName[12:16]:        Bool,
	_DTypeLowerName[12:16]:   Bool,
	_DTypeName[16:20]:        Int8,
	_DTypeLowerName[16:20]:   Int8,
	_DTypeName[20:25]:        Int16,
	_DTypeLowerName[20:25]:   Int16,
	_DTypeName[25:30]:        Int32,
	_DTypeLowerName[25:30]:   Int32,
	_DTypeName[30:35]:        Int64,
	_DTypeLowerName[30:35]:   Int64,
	_DTypeName[35:40]:        UInt8,
	_DTypeLowerName[35:40]:   UInt8,
	_DTypeName[40:46]:        UInt16,
	_DTypeLowerName[40:46]:   UInt16,
	_DTypeName[46:52]:        UInt32,
	_DTypeLowerName[46:52]:   UInt32,
	_DTypeName[52:58]:        UInt64,
	_DTypeLowerName[52:58]:   UInt64,
	_DTypeName[58:65]:        Float16,
	_DTypeLowerName[58:65]:   Float16,
	_DTypeName[65:72]:        Float32,
	_DTypeLowerName[65:72]:   Float32,
	_DTypeName[72:79]:        Float64,
	_DTypeLowerName[72:79]:   Float64,
	_DTypeName[79:84]:        Tuple,
	_DTypeLowerName[79:84]:   Tuple,
	_DTypeName[84:94]:        OpaqueType,
	_DTypeLowerName[84:94]:   OpaqueType,
	_DTypeName[94:103]:       Complex64,
	_DTypeLowerName[94:103]:  Complex64,
	_DTypeName[103:111]:      BFloat16,
	_DTypeLowerName[103:111]: BFloat16,
	_DTypeName[111:116]:      Token,
	_DTypeLowerName[111:116]: Token,
	_DTypeName[116:126]:      Complex128,
	_DTypeLowerName[116:126]: Complex128,
}

var _DTypeNames = []string{
	_DTypeName[0:12],
	_DTypeName[12:16],
	_DTypeName[16:20],
	_DTypeName[20:25],
	_DTypeName[25:30],
	_DTypeName[30:35],
	_DTypeName[35:40],
	_DTypeName[40:46],
	_DTypeName[46:52],
	_DTypeName[52:58],
	_DTypeName[58:65],
	_DTypeName[65:72],
	_DTypeName[72:79],
	_DTypeName[79:84],
	_DTypeName[84:94],
	_DTypeName[94:103],
	_DTypeName[103:111],
	_DTypeName[111:116],
	_DTypeName[116:126],
}

// DTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func DTypeString(s string) (DType, error) {
	if val, ok := _DTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _DTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to DType values", s)
}

// DTypeValues returns all values of the enum
func DTypeValues() []DType {
	return _DTypeValues
}

// DTypeStrings returns a slice of all String values of the enum
func DTypeStrings() []string {
	strs := make([]string, len(_DTypeNames))
	copy(strs, _DTypeNames)
	return strs
}

// IsADType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i DType) IsADType() bool {
	for _, v := range _DTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for DType
func (i DType) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for DType
func (i *DType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("DType should be a string, got %s", data)
	}

	var err error
	*i, err = DTypeString(s)
	return err
}

// MarshalText implements the encoding.TextMarshaler interface for DType
func (i DType) MarshalText() ([]byte, error) {
	return []byte(i.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for DType
func (i *DType) UnmarshalText(text []byte) error {
	var err error
	*i, err = DTypeString(string(text))
	return err
}

// MarshalYAML implements a YAML Marshaler for DType
func (i DType) MarshalYAML() (interface{}, error) {
	return i.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for DType
func (i *DType) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var s string
	if err := unmarshal(&s); err != nil {
		return err
	}

	var err error
	*i, err = DTypeString(s)
	return err
}
