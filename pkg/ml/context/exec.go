/*
 *	Copyright 2023 Jan Pfeifer
 *
 *	Licensed under the Apache License, Version 2.0 (the "License");
 *	you may not use this file except in compliance with the License.
 *	You may obtain a copy of the License at
 *
 *	http://www.apache.org/licenses/LICENSE-2.0
 *
 *	Unless required by applicable law or agreed to in writing, software
 *	distributed under the License is distributed on an "AS IS" BASIS,
 *	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *	See the License for the specific language governing permissions and
 *	limitations under the License.
 */

package context

import (
	"fmt"
	"reflect"
	"runtime"
	"sync"

	"github.com/gomlx/gomlx/backends"
	. "github.com/gomlx/gomlx/internal/exceptions"
	"github.com/gomlx/gomlx/pkg/core/graph"
	"github.com/gomlx/gomlx/pkg/core/tensors"
	"github.com/pkg/errors"
)

// Generated by `cmd/constraints_generator`:

// ExecGraphFn is a type parameter for accepted function types for MustNewExec constructor.
type ExecGraphFn interface {
	func(*Context, *Graph) |
		func(*Context, []*Node) |
		func(*Context, *Node) |
		func(*Context, *Node, *Node) |
		func(*Context, *Node, *Node, *Node) |
		func(*Context, *Node, *Node, *Node, *Node) |
		func(*Context, *Node, *Node, *Node, *Node, *Node) |
		func(*Context, *Node, *Node, *Node, *Node, *Node, *Node) |

		func(*Context, *Graph) *Node |
		func(*Context, []*Node) *Node |
		func(*Context, *Node) *Node |
		func(*Context, *Node, *Node) *Node |
		func(*Context, *Node, *Node, *Node) *Node |
		func(*Context, *Node, *Node, *Node, *Node) *Node |
		func(*Context, *Node, *Node, *Node, *Node, *Node) *Node |
		func(*Context, *Node, *Node, *Node, *Node, *Node, *Node) *Node |

		func(*Context, *Graph) (*Node, *Node) |
		func(*Context, []*Node) (*Node, *Node) |
		func(*Context, *Node) (*Node, *Node) |
		func(*Context, *Node, *Node) (*Node, *Node) |
		func(*Context, *Node, *Node, *Node) (*Node, *Node) |
		func(*Context, *Node, *Node, *Node, *Node) (*Node, *Node) |
		func(*Context, *Node, *Node, *Node, *Node, *Node) (*Node, *Node) |
		func(*Context, *Node, *Node, *Node, *Node, *Node, *Node) (*Node, *Node) |

		func(*Context, *Graph) (*Node, *Node, *Node) |
		func(*Context, []*Node) (*Node, *Node, *Node) |
		func(*Context, *Node) (*Node, *Node, *Node) |
		func(*Context, *Node, *Node) (*Node, *Node, *Node) |
		func(*Context, *Node, *Node, *Node) (*Node, *Node, *Node) |
		func(*Context, *Node, *Node, *Node, *Node) (*Node, *Node, *Node) |
		func(*Context, *Node, *Node, *Node, *Node, *Node) (*Node, *Node, *Node) |
		func(*Context, *Node, *Node, *Node, *Node, *Node, *Node) (*Node, *Node, *Node) |

		func(*Context, *Graph) []*Node |
		func(*Context, []*Node) []*Node |
		func(*Context, *Node) []*Node |
		func(*Context, *Node, *Node) []*Node |
		func(*Context, *Node, *Node, *Node) []*Node |
		func(*Context, *Node, *Node, *Node, *Node) []*Node |
		func(*Context, *Node, *Node, *Node, *Node, *Node) []*Node |
		func(*Context, *Node, *Node, *Node, *Node, *Node, *Node) []*Node
}

// ExecGraphFnOneOutput is a type parameter for accepted function types for MustNewExec constructor.
type ExecGraphFnOneOutput interface {
	func(*Context, *Graph) *Node |
		func(*Context, []*Node) *Node |
		func(*Context, *Node) *Node |
		func(*Context, *Node, *Node) *Node |
		func(*Context, *Node, *Node, *Node) *Node |
		func(*Context, *Node, *Node, *Node, *Node) *Node |
		func(*Context, *Node, *Node, *Node, *Node, *Node) *Node |
		func(*Context, *Node, *Node, *Node, *Node, *Node, *Node) *Node
}

// Exec creates and executes computation graphs that take as input a
// Context as needed based on the inputs shapes, to allow the function
// to access (both read and set) variables and everything in the Context.
// Otherwise, very similar to graph.Exec.
//
// It simplifies the process of executing a graph building
// function with real values.
//
// For example, assume you wrote the "symbolic computation" (graph) function:
//
//	def LogitsGraph(ctx *context.Context, inputs *Node) *Node {
//	    logits := layers.Dense(ctx.In("dense0", inputs, 5))
//		logits = layers.Dense(ctx.In("dense1", logits, 5))
//		logits = Sigmoid(logits)
//		return logits
//	}
//
// And then with Exec one can do:
//
//	ctx := context.New(backend)  // New context holding the model variables.
//	var logitsFn = context.MustNewExec(backend, ctx, LogitsGraph)
//	batch := [][]float32{ {1, 2, 3}, {4, 5, 6} } // 2 examples with 3 features (shape=[2,3])
//	results, err := logitsFn.Exec(batch)
//	if err != nil {
//		panic(err)
//	}
//	fmt.Printf("Logits(%v) = %s\n", batch, results[0])
//
// A few things to note (valid to all family of Exec.Exec methods, Exec.Exec, Exec.Exec1, Exec.MustExec, etc.):
//
//   - Exec.Exec doesn't take as input the context again, it uses the value used to create the Exec object.
//   - The inputs are materialized as tensors, if they are not yet. The conversion is automatic (but slower if it
//     needs to convert before executing).
//   - The ctxGraphFn represents the "symbolic computation" (graph) function. Exec.Exec calls it the first time
//     (or whenever the input shapes change) to build the computation graph, and then JIT-compile it.
//     That means the first call (for each new input shape) is slow, but further calls are pre-compiled and executed
//     fast.
//   - The hyperparameters in the Context (Context.SetParams) are only used during the graph building and not after that.
//     We recommend freezing them before creating the Exec object.
//   - Only the variables in the Context can be updated -- either from outside a graph execution or within
//     the graph execution itself -- for instance, when training a model. Exec.Exec manages the updates automatically.
//   - While ctxGraphFn is executed in a single goroutine to build the computation graph, the actual execution of
//     for the JIT-compiled program can be done concurrently -- meaning you can call Exec.Exec concurrently from
//     multiple goroutines. It's always safe, but different backends will have different optimal parallelization levels
//     if you are trying to optimize for throughput.
//
// Example: Implementing a counter in a variable:
//
//	ctx := context.New()
//	counterExec := context.MustNewExec(backend, ctx, func(ctx *context.Context, g *Graph) *Node {
//		counterVar := ctx.VariableWithValue("count", int32(10))
//		count := counterVar.ValueGraph(g)
//		count = AddScalar(count, 1)
//		counterVar.SetValueGraph(count)
//		return count
//	})
//	fmt.Println("Counting:")
//	for range(3) {
//		fmt.Printf("\tcount=%s\n", exec.Exec1())  // -> 11, 12, 13
//	}
//	counterVar := ctx.InspectVariable(ctx.Scope(), "count")  // Inspecting the variable from outside the graph execution.
//	fmt.Printf("- State of counter=%s\n", counterVar.Value())  // -> int32(13)
//
// Like with graph.Exec, the need to build different graphs for different
// shapes can be expensive when sizes of the inputs vary a lot.
// The usual solution is to use shapes with size in a power scale (for instance, powers of 2) and padding
// the input tensors for unused slices (often using a mask).
//
// For safety concerns, the cache of JIT-compiled graphs for different input shapes is limited.
// It can be set or disabled with SetMaxCache.
type Exec struct {
	backend backends.Backend
	context *Context
	exec    *graph.Exec

	// Original function that takes ctx and the converted closure
	// that only takes *Node as input.
	ctxGraphFn, graphFn                       any
	inputIsGraph, inputAsSlice, outputAsSlice bool

	// changedVars maps GraphId of the graphs built to their list
	// of modified variables: we assume that building the graph for different
	// shapes may
	changedVars   map[graph.GraphId][]*Variable
	muChangedVars sync.Mutex

	// isInitializeVariablesExec indicates this executor is being used to initialize variables.
	// Initializing variables within the cxtGraphFn would lead to an infinite recursion.
	// This checks for that.
	isInitializeVariablesExec bool
}

// NewExecAny constructs an Exec object for the given context and symbolic computation function ctxGraphFn.
//
// The ctxGraphFn is called to build the computation graphs with a Context.
// It must take a *Context input parameter followed by one or more *Node parameters as input and return one or more *Node.
// Alternatively, it can, instead of *Node inputs, take a *Graph object, when there are no input tensors.
//
// The Context ctx passed in the construction is used in all calls to ctxGraphFn, as well as during the graph execution later.
// If set to nil, it automatically creates a new empty context.
//
// Before the execution of a graph, it initializes the variables as needed, using the configured initializer.
// And variables updated in the graph (using Variable.SetValueGraph) are updated also during execution.
// More details see Exec.
func NewExecAny(backend backends.Backend, ctx *Context, ctxGraphFn any) (*Exec, error) {
	if ctx == nil {
		ctx = New()
	}
	e := &Exec{
		backend:     backend,
		context:     ctx,
		ctxGraphFn:  ctxGraphFn,
		changedVars: make(map[graph.GraphId][]*Variable),
	}
	ctxGraphFnT := reflect.TypeOf(ctxGraphFn)
	if ctxGraphFnT.Kind() != reflect.Func {
		return nil, errors.Errorf("ctxGraphFn must be a function")
	}
	var node *Node
	nodeType := reflect.TypeOf(node)
	contextType := reflect.TypeOf(ctx)
	var tmpGraph *Graph
	graphType := reflect.TypeOf(tmpGraph)

	// Must have at least 2 arguments, and the first must be of type *Context.
	if ctxGraphFnT.NumIn() < 2 {
		return nil, errors.Errorf("at least *Context and one input argument required")
	}
	if ctxGraphFnT.In(0) != contextType {
		return nil, errors.Errorf("the first argument for ctxGraphFn must be a *Context, got %s instead", ctxGraphFnT.In(0))
	}

	// Check other arguments.
	for ii := 1; ii < ctxGraphFnT.NumIn(); ii++ {
		if ctxGraphFnT.In(ii).Kind() == reflect.Slice && ctxGraphFnT.In(ii).Elem() == nodeType {
			// Case 1: []*Node
			if ctxGraphFnT.NumIn() != 2 {
				return nil, errors.Errorf("[]*Node parameters are only accepted if they are the only input besides the Context, got function type %s instead", ctxGraphFnT)
			}
			e.inputAsSlice = true
			break
		}
		if ctxGraphFnT.In(ii) == graphType {
			// Case 2: *Graph
			if ctxGraphFnT.NumIn() != 2 {
				return nil, errors.Errorf("*Graph argument is only accepted if it is the only input besides the Context, got function type %s instead", ctxGraphFnT)
			}
			e.inputIsGraph = true
			break
		}
		if ctxGraphFnT.In(ii) != nodeType {
			return nil, errors.Errorf("input parameter %d is not of type *Node", ii)
		}
	}
	for ii := 0; ii < ctxGraphFnT.NumOut(); ii++ {
		if ctxGraphFnT.Out(ii).Kind() == reflect.Slice && ctxGraphFnT.Out(ii).Elem() == nodeType {
			if ctxGraphFnT.NumOut() != 1 {
				return nil, errors.Errorf("[]*Node parameters are only accepted as output if they are the only output, got function type %s instead", ctxGraphFnT)
			}
			e.outputAsSlice = true
			break
		}
		if ctxGraphFnT.Out(ii) != nodeType {
			return nil, errors.Errorf("output parameter %d is not of type *Node", ii)
		}
	}

	e.buildGraphFn()
	e.exec = graph.MustNewExecAny(backend, e.graphFn)
	funcName := runtime.FuncForPC(reflect.ValueOf(ctxGraphFn).Pointer()).Name()
	e.exec.WithName(fmt.Sprintf("Context.Exec:%s", funcName))
	e.exec.SetSideParamsHook(e.setSideParams)
	return e, nil
}

// buildGraphFn constructs a function graphFn that can be passed to the wrapped Exec.
// This function is a closure that will call the ctxGraphFn provided by the user with the
// extra *context.Context argument, plus it prepends the output with the updated values --
// so it can behind the scenes update the variables to the user.
func (e *Exec) buildGraphFn() {
	ctxGraphFnT := reflect.TypeOf(e.ctxGraphFn)
	numIn := ctxGraphFnT.NumIn() - 1
	var node *Node
	nodeT := reflect.TypeOf(node)
	var nodeSlice []*Node
	nodeSliceT := reflect.TypeOf(nodeSlice)
	var tmpGraph *Graph
	graphT := reflect.TypeOf(tmpGraph)

	// Build input types for new graphFn: same as ctxGraphFn, but without the Context.
	var inT []reflect.Type
	if e.inputIsGraph {
		// The only input is a graph.
		inT = []reflect.Type{graphT}
	} else if e.inputAsSlice {
		// The only input is a []*Node.
		inT = []reflect.Type{nodeSliceT}
	} else {
		inT = make([]reflect.Type, numIn)
		for ii := 0; ii < numIn; ii++ {
			inT[ii] = nodeT
		}
	}

	// Output types for a new graphFn: it is converted to a []*Node, because we will prepend
	// the changed variables as extra outputs.
	outT := []reflect.Type{nodeSliceT}

	// Builds the function that will be called without Context, by computation.Exec. It will take as
	// input a slice of *Node (or only a *computation.Graph), and as output also a slice of *Node.
	graphFnT := reflect.FuncOf(inT, outT, false)
	e.graphFn = reflect.MakeFunc(graphFnT, func(args []reflect.Value) (results []reflect.Value) {
		// Inputs for the original ctxGraphFn: we prepend the context to the arguments.
		argsWithContext := make([]reflect.Value, len(args)+1)
		argsWithContext[0] = reflect.ValueOf(e.context)
		copy(argsWithContext[1:], args)

		// Call ctxGraphFn, the results will be a slice of *Node.
		ctxGraphFnResults := reflect.ValueOf(e.ctxGraphFn).Call(argsWithContext)

		// Find the graph.
		var g *Graph
		if e.inputIsGraph {
			g = args[0].Interface().(*Graph)
		} else if e.inputAsSlice {
			nodes := args[0].Interface().([]*Node)
			g = nodes[0].Graph()
		} else {
			node := args[0].Interface().(*Node)
			g = node.Graph()
		}
		graphId := g.GraphId()

		// Find variables that were changed and their updated graph values (*Node).
		var changedVars []*Variable
		var allValues []*Node
		e.context.EnumerateVariables(func(v *Variable) {
			if v.ChangedInGraph(g) {
				changedVars = append(changedVars, v)
				allValues = append(allValues, v.ValueGraph(g))
			}
		})
		{
			// Save list of variables changed.
			e.muChangedVars.Lock()
			e.changedVars[graphId] = changedVars
			e.muChangedVars.Unlock()
		}
		// Append ctxGraphFnResults to allValues.
		if e.outputAsSlice {
			// cxtGraphResults returns one value, a []*Node, easy to append.
			allValues = append(allValues, ctxGraphFnResults[0].Interface().([]*Node)...)
		} else {
			// Append one result at a time (it's ok if there are no results).
			for _, r := range ctxGraphFnResults {
				allValues = append(allValues, r.Interface().(*Node))
			}
		}

		// the results will be a []*Node, which will hold all the values.
		results = []reflect.Value{reflect.ValueOf(allValues)}

		// Mark context for reuse after the first time it is used.
		if !e.context.reuse {
			e.context = e.context.Reuse()
		}
		return
	}).Interface()
}

// Finalize clears the cache, finalizing and releasing the memory for all compiled graphs.
// The Exec object shouldn't be used after that.
// Especially if you are compiling the graph to many different shapes, try to manually finalize
// and not wait for the GC -- particularly important if you are running this in benchmarks.
func (e *Exec) Finalize() {
	e.exec.Finalize()
}

// setSideParams is used by computation.Exec.SetSideParamsHook to set up
// the variable values as parameters just before graph execution.
//
// It fills the graph parameter values for every variable used in the given graph.
// It keeps a cache of the variables' mapping for faster access.
//
// It's assumed len(inputBuffers) = len(donate) = g.NumParameters()
//
// `Exec*` methods are used by those implementing an executor (context.Exec) or related tests, not normally
// needed by end users.
func (e *Exec) setSideParams(g *Graph, inputBuffers []backends.Buffer, donate []bool) {
	// Initialize variables if needed.
	ctx := e.context
	if !e.isInitializeVariablesExec && ctx.NeedsInitialization() {
		ctx.InitializeVariables(e.backend)
	}

	graphId := g.GraphId()
	ctx.EnumerateVariables(func(v *Variable) {
		nodes, found := v.graphToNodes.Load(graphId)
		if !found {
			return
		}
		if nodes == nil || nodes.paramNode == nil || nodes.paramNode.Type() != graph.NodeTypeParameter {
			Panicf("invalid paramNode for variable %q", v.ParameterName())
		}
		handle := nodes.paramNode.GetParameterHandle()

		if v.ChangedInGraph(g) {
			// We donate the buffer, since we are getting a new one on the output.
			inputBuffers[handle] = v.Value().DonateBuffer(e.backend, e.exec.DeviceNum())
			v.Value().FinalizeAll()
			v.value = nil
			donate[handle] = true
		} else {
			if v.value == nil {
				if e.isInitializeVariablesExec {
					Panicf("variable %q used and not initialized during variable initialization, this would lead to "+
						"recursive initialization of variables, and is not supported", v.ScopeAndName())
				} else {
					Panicf("variable %q failed to initialize", v.ScopeAndName())
				}
			}
			inputBuffers[handle] = v.Value().Buffer(e.backend, e.exec.DeviceNum())
			donate[handle] = false
		}
	})
}

// SetNodeLogger with the function to be called for the nodes
// marked for logging during execution. If set to nil,
// nothing will be logged.
func (e *Exec) SetNodeLogger(loggerFn graph.LoggerFn) {
	e.exec.SetNodeLogger(loggerFn)
}

// GetNodeLogger returns the currently registered LoggerFn.
func (e *Exec) GetNodeLogger() graph.LoggerFn {
	return e.exec.GetNodeLogger()
}

// WithDevice sets the device num to be used by graphs constructed by Exec.
// This configures the computation to use a single device -- no distribution.
//
// This should be called before any invocations of the Exec methods.
//
// It returns a reference to itself, so configuration calls can be cascaded.
func (e *Exec) WithDevice(deviceNum backends.DeviceNum) *Exec {
	e.exec.WithDevice(deviceNum)
	return e
}

// WithName sets the name of Exec, used to provide the name to graphs created.
// This should be called before any invocations of MustExec().
// It returns a reference to itself so calls can be cascaded.
func (e *Exec) WithName(name string) *Exec {
	e.exec.WithName(name)
	return e
}

// Name returns the Exec name, a string used as a prefix for Graph construction.
func (e *Exec) Name() string {
	return e.exec.Name()
}

// SetMaxCache sets the maximum size of the cache.
// Set it to -1 to have unlimited cache size.
// It returns a reference to itself so calls can be cascaded.
func (e *Exec) SetMaxCache(maxCacheSize int) *Exec {
	e.exec.SetMaxCache(maxCacheSize)
	return e
}

// Context returns the associated Context object, usually created
// during the creation of the Exec object. It can be set to something
// different with SetContext().
func (e *Exec) Context() *Context {
	return e.context
}

// SetContext associates the given Context with the Exec object.
// It should be called before the first Exec is made.
// Notice that only after the first time context is used to build a graph,
// it is set to Reuse. If the Context variables were already created,
// it should be marked with Context.Reuse.
// It returns a reference to itself so calls can be cascaded.
func (e *Exec) SetContext(context *Context) *Exec {
	e.context = context
	return e
}

// Exec parses the arguments into tensors (if they are not yet) and executes
// the graph corresponding to the shapes of the arguments.
//
// Notice it uses the Context object used during creation -- if needed, you can change it with SetContext.
//
// If a graph does not yet exist, one is created (using ctxGraphFn provided during creation), compiled, and cached
// for these shapes of the inputs.
// After the very first invocation of Exec, the context is marked as Context.Reuse().
//
// It returns the outputs in a slice. See Exec1, Exec2, ..., Exec4 as aliases when you expect a fixed number of outputs.
func (e *Exec) Exec(args ...any) ([]*tensors.Tensor, error) {
	outputs, _, err := e.ExecWithGraph(args...)
	return outputs, err
}

// ExecWithGraph is similar to Exec, but it also returns the computation graph used in the call.
//
// Since Exec creates different computation graphs when the inputs shapes change,
// this can help disambiguate in case the user needs to use the Graph for something else.
//
// It returns an error if something goes wrong.
func (e *Exec) ExecWithGraph(args ...any) (outputs []*tensors.Tensor, g *Graph, err error) {
	outputs, g, err = e.exec.ExecWithGraph(args...)
	if err != nil {
		return nil, nil, err
	}

	// Separate the changed variables new values and set the variables accordingly:
	// the changed variables outputs come first.
	e.muChangedVars.Lock()
	changedVars := e.changedVars[g.GraphId()]
	e.muChangedVars.Unlock()
	if len(changedVars) > len(outputs) {
		return nil, nil, errors.Errorf("not enough outputs of the graph for updated variables: expected %d, got %d", len(changedVars), len(outputs))
	}
	for ii, v := range changedVars {
		old := v.Value()
		if old != nil {
			old.FinalizeAll()
		}
		if !v.shape.Equal(outputs[ii].Shape()) {
			return nil, nil, errors.Errorf("variable %q changed shape in graph execution: expected %v, got %v", v.ScopeAndName(), v.shape, outputs[ii].Shape())
		}
		v.SetValue(outputs[ii])
	}
	outputs = outputs[len(changedVars):]
	return
}

// PreCompile will build the computation graph, JIT-compile and cache it, but not yet execute.
//
// Useful when one wants to measure the time separately, from graph compilation and its execution.
func (e *Exec) PreCompile(args ...any) {
	e.exec.PreCompile(args...)
}
