/***** File generated by ./cmd/graphs_codegen, based on backends.Builder interface. Don't edit it directly. *****/

package graph

import (
	"fmt"
	"slices"
	"strings"

	"github.com/gomlx/gomlx/backends"
	"github.com/gomlx/gomlx/pkg/core/shapes"
	"github.com/gomlx/gomlx/pkg/support/xslices"
	"github.com/gomlx/gopjrt/dtypes"
)

type NodeType int

const (
	NodeTypeInvalid NodeType = iota
	NodeTypeSplitNode
	NodeTypeAbs
	NodeTypeAdd
	NodeTypeAllReduce
	NodeTypeArgMinMax
	NodeTypeBatchNormForInference
	NodeTypeBatchNormForTraining
	NodeTypeBatchNormGradient
	NodeTypeBitCount
	NodeTypeBitcast
	NodeTypeBitwiseAnd
	NodeTypeBitwiseNot
	NodeTypeBitwiseOr
	NodeTypeBitwiseXor
	NodeTypeBroadcastInDim
	NodeTypeCeil
	NodeTypeClamp
	NodeTypeClz
	NodeTypeComplex
	NodeTypeConcatenate
	NodeTypeConj
	NodeTypeConstant
	NodeTypeConvGeneral
	NodeTypeConvertDType
	NodeTypeCos
	NodeTypeDiv
	NodeTypeDot
	NodeTypeDotGeneral
	NodeTypeDynamicSlice
	NodeTypeDynamicUpdateSlice
	NodeTypeEqual
	NodeTypeEqualTotalOrder
	NodeTypeErf
	NodeTypeExp
	NodeTypeExpm1
	NodeTypeFFT
	NodeTypeFloor
	NodeTypeGather
	NodeTypeGreaterOrEqual
	NodeTypeGreaterOrEqualTotalOrder
	NodeTypeGreaterThan
	NodeTypeGreaterThanTotalOrder
	NodeTypeIdentity
	NodeTypeImag
	NodeTypeIota
	NodeTypeIsFinite
	NodeTypeIsNaN
	NodeTypeLessOrEqual
	NodeTypeLessOrEqualTotalOrder
	NodeTypeLessThan
	NodeTypeLessThanTotalOrder
	NodeTypeLog
	NodeTypeLog1p
	NodeTypeLogicalAnd
	NodeTypeLogicalNot
	NodeTypeLogicalOr
	NodeTypeLogicalXor
	NodeTypeLogistic
	NodeTypeMax
	NodeTypeMin
	NodeTypeMul
	NodeTypeNeg
	NodeTypeNotEqual
	NodeTypeNotEqualTotalOrder
	NodeTypePad
	NodeTypeParameter
	NodeTypePow
	NodeTypeRNGBitGenerator
	NodeTypeReal
	NodeTypeReduceBitwiseAnd
	NodeTypeReduceBitwiseOr
	NodeTypeReduceBitwiseXor
	NodeTypeReduceLogicalAnd
	NodeTypeReduceLogicalOr
	NodeTypeReduceLogicalXor
	NodeTypeReduceMax
	NodeTypeReduceMin
	NodeTypeReduceProduct
	NodeTypeReduceSum
	NodeTypeReduceWindow
	NodeTypeRem
	NodeTypeReshape
	NodeTypeReverse
	NodeTypeRound
	NodeTypeRsqrt
	NodeTypeScatterMax
	NodeTypeScatterMin
	NodeTypeScatterSum
	NodeTypeSelectAndScatterMax
	NodeTypeSelectAndScatterMin
	NodeTypeShiftLeft
	NodeTypeShiftRightArithmetic
	NodeTypeShiftRightLogical
	NodeTypeSign
	NodeTypeSin
	NodeTypeSlice
	NodeTypeSqrt
	NodeTypeSub
	NodeTypeTanh
	NodeTypeTranspose
	NodeTypeWhere
)

// nodeInputsAbs holds the inputs used for the call to backends.Abs.
type nodeInputsAbs struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsAbs) Type() NodeType {
	return NodeTypeAbs
}

// String implements the interface NodeInputs.
func (ni *nodeInputsAbs) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Abs returns the Op that represents the output of the corresponding operation.
func Abs(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsAbs{
		x: x,
	}
	result, err := g.builder.Abs(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsAdd holds the inputs used for the call to backends.Add.
type nodeInputsAdd struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsAdd) Type() NodeType {
	return NodeTypeAdd
}

// String implements the interface NodeInputs.
func (ni *nodeInputsAdd) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// Add returns the element-wise sum of the two values.
// Standard broadcasting rules apply (see documentation).
func Add(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsAdd{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.Add(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsAllReduce holds the inputs used for the call to backends.AllReduce.
type nodeInputsAllReduce struct {
	operands      []*Node
	reductionType ReduceOpType
	replicaGroups [][]int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsAllReduce) Type() NodeType {
	return NodeTypeAllReduce
}

// String implements the interface NodeInputs.
func (ni *nodeInputsAllReduce) String() string {
	return fmt.Sprintf("%s(operands=[#%s], reductionType=%v, replicaGroups=%v)",
		ni.Type(),
		strings.Join(xslices.Map(ni.operands, func(node *Node) string { return fmt.Sprintf("#%d", node.Id()) }), ", "),
		ni.reductionType,
		ni.replicaGroups,
	)
}

// backendAllReduce is a Graph wrapper for the backend.Builder.AllReduce method.
func backendAllReduce(operands []*Node, reductionType ReduceOpType, replicaGroups [][]int) []*Node {
	inputNodes := []*Node{}
	inputNodes = append(inputNodes, operands...)
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsAllReduce{
		operands:      slices.Clone(operands),
		reductionType: reductionType,
		replicaGroups: slices.Clone(replicaGroups),
	}
	results, err := g.builder.AllReduce(xslices.Map(operands, func(node *Node) backends.Op { return node.outputOps[0] }), inputs.reductionType, inputs.replicaGroups)
	if err != nil {
		panic(err)
	}
	node := &Node{
		outputOps: results,
		outputShapes: xslices.Map(results,
			func(op backends.Op) shapes.Shape { return mustNoError(g.builder.OpShape(op)) }),
		graph:      g,
		inputs:     inputs,
		inputNodes: inputNodes,
	}
	g.registerNode(node)
	return splitNode(node)
}

// nodeInputsArgMinMax holds the inputs used for the call to backends.ArgMinMax.
type nodeInputsArgMinMax struct {
	x           *Node
	axis        int
	outputDType dtypes.DType
	isMin       bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsArgMinMax) Type() NodeType {
	return NodeTypeArgMinMax
}

// String implements the interface NodeInputs.
func (ni *nodeInputsArgMinMax) String() string {
	return fmt.Sprintf("%s(x=[#%d], axis=%v, outputDType=%v, isMin=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axis,
		ni.outputDType,
		ni.isMin,
	)
}

// backendArgMinMax is a Graph wrapper for the backend.Builder.ArgMinMax method.
func backendArgMinMax(x *Node, axis int, outputDType dtypes.DType, isMin bool) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsArgMinMax{
		x:           x,
		axis:        axis,
		outputDType: outputDType,
		isMin:       isMin,
	}
	result, err := g.builder.ArgMinMax(x.outputOps[0], inputs.axis, inputs.outputDType, inputs.isMin)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsBatchNormForInference holds the inputs used for the call to backends.BatchNormForInference.
type nodeInputsBatchNormForInference struct {
	operand     *Node
	scale       *Node
	offset      *Node
	mean        *Node
	variance    *Node
	epsilon     float32
	featureAxis int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBatchNormForInference) Type() NodeType {
	return NodeTypeBatchNormForInference
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBatchNormForInference) String() string {
	return fmt.Sprintf("%s(operand=[#%d], scale=[#%d], offset=[#%d], mean=[#%d], variance=[#%d], epsilon=%v, featureAxis=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.scale.Id(),
		ni.offset.Id(),
		ni.mean.Id(),
		ni.variance.Id(),
		ni.epsilon,
		ni.featureAxis,
	)
}

// backendBatchNormForInference is a Graph wrapper for the backend.Builder.BatchNormForInference method.
func backendBatchNormForInference(operand *Node, scale *Node, offset *Node, mean *Node, variance *Node, epsilon float32, featureAxis int) (
	node *Node) {
	inputNodes := []*Node{operand, scale, offset, mean, variance}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsBatchNormForInference{
		operand:     operand,
		scale:       scale,
		offset:      offset,
		mean:        mean,
		variance:    variance,
		epsilon:     epsilon,
		featureAxis: featureAxis,
	}
	result, err := g.builder.BatchNormForInference(operand.outputOps[0], scale.outputOps[0], offset.outputOps[0], mean.outputOps[0], variance.outputOps[0], inputs.epsilon, inputs.featureAxis)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsBatchNormForTraining holds the inputs used for the call to backends.BatchNormForTraining.
type nodeInputsBatchNormForTraining struct {
	operand     *Node
	scale       *Node
	offset      *Node
	epsilon     float32
	featureAxis int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBatchNormForTraining) Type() NodeType {
	return NodeTypeBatchNormForTraining
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBatchNormForTraining) String() string {
	return fmt.Sprintf("%s(operand=[#%d], scale=[#%d], offset=[#%d], epsilon=%v, featureAxis=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.scale.Id(),
		ni.offset.Id(),
		ni.epsilon,
		ni.featureAxis,
	)
}

// backendBatchNormForTraining is a Graph wrapper for the backend.Builder.BatchNormForTraining method.
func backendBatchNormForTraining(operand *Node, scale *Node, offset *Node, epsilon float32, featureAxis int) (
	normalized, batchMean, batchVariance *Node) {
	inputNodes := []*Node{operand, scale, offset}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsBatchNormForTraining{
		operand:     operand,
		scale:       scale,
		offset:      offset,
		epsilon:     epsilon,
		featureAxis: featureAxis,
	}
	v0, v1, v2, err := g.builder.BatchNormForTraining(operand.outputOps[0], scale.outputOps[0], offset.outputOps[0], inputs.epsilon, inputs.featureAxis)
	if err != nil {
		panic(err)
	}
	node := &Node{
		outputOps:    []backends.Op{v0, v1, v2},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(v0)), mustNoError(g.builder.OpShape(v1)), mustNoError(g.builder.OpShape(v2))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	splitNodes := splitNode(node)
	normalized, batchMean, batchVariance = splitNodes[0], splitNodes[1], splitNodes[2]
	return
}

// nodeInputsBatchNormGradient holds the inputs used for the call to backends.BatchNormGradient.
type nodeInputsBatchNormGradient struct {
	operand     *Node
	scale       *Node
	mean        *Node
	variance    *Node
	gradOutput  *Node
	epsilon     float32
	featureAxis int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBatchNormGradient) Type() NodeType {
	return NodeTypeBatchNormGradient
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBatchNormGradient) String() string {
	return fmt.Sprintf("%s(operand=[#%d], scale=[#%d], mean=[#%d], variance=[#%d], gradOutput=[#%d], epsilon=%v, featureAxis=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.scale.Id(),
		ni.mean.Id(),
		ni.variance.Id(),
		ni.gradOutput.Id(),
		ni.epsilon,
		ni.featureAxis,
	)
}

// backendBatchNormGradient is a Graph wrapper for the backend.Builder.BatchNormGradient method.
func backendBatchNormGradient(operand *Node, scale *Node, mean *Node, variance *Node, gradOutput *Node, epsilon float32, featureAxis int) (
	gradOperand, gradScale, gradOffset *Node) {
	inputNodes := []*Node{operand, scale, mean, variance, gradOutput}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsBatchNormGradient{
		operand:     operand,
		scale:       scale,
		mean:        mean,
		variance:    variance,
		gradOutput:  gradOutput,
		epsilon:     epsilon,
		featureAxis: featureAxis,
	}
	v0, v1, v2, err := g.builder.BatchNormGradient(operand.outputOps[0], scale.outputOps[0], mean.outputOps[0], variance.outputOps[0], gradOutput.outputOps[0], inputs.epsilon, inputs.featureAxis)
	if err != nil {
		panic(err)
	}
	node := &Node{
		outputOps:    []backends.Op{v0, v1, v2},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(v0)), mustNoError(g.builder.OpShape(v1)), mustNoError(g.builder.OpShape(v2))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	splitNodes := splitNode(node)
	gradOperand, gradScale, gradOffset = splitNodes[0], splitNodes[1], splitNodes[2]
	return
}

// nodeInputsBitCount holds the inputs used for the call to backends.BitCount.
type nodeInputsBitCount struct {
	operand *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBitCount) Type() NodeType {
	return NodeTypeBitCount
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBitCount) String() string {
	return fmt.Sprintf("%s(operand=[#%d])",
		ni.Type(),
		ni.operand.Id(),
	)
}

// BitCount returns the number of bits that are set to one.
// Also known as Population Count ("Popcnt") or Hamming Weight.
func BitCount(operand *Node) (
	node *Node) {
	inputNodes := []*Node{operand}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsBitCount{
		operand: operand,
	}
	result, err := g.builder.BitCount(operand.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsBitcast holds the inputs used for the call to backends.Bitcast.
type nodeInputsBitcast struct {
	x           *Node
	targetDType dtypes.DType
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBitcast) Type() NodeType {
	return NodeTypeBitcast
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBitcast) String() string {
	return fmt.Sprintf("%s(x=[#%d], targetDType=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.targetDType,
	)
}

// Bitcast performs an elementwise bit-cast operation from a dtype to another dtype.
//
// The Bitcast doesn't "convert", rather it just reinterprets the bits from x.DType() to the targetDType.
//
// If x.DType() and targetDType use the same number of bytes (targetDType.Size() == x.DType().Size()),
// the dimensions are not changed, simply the dtype is changed.
//
// If targetDType.Size() > x.DType().Size(), it requires x last axis to have a dimension of
// targetDType.Size() / x.DType().Size(), and the returned shape will trim the last axis.
//
// If targetDType.Size() < x.DType().Size(), the returned shape will have an extra axis in the end, with dimension of
// x.DType().Size() / targetDType.Size().
//
// E.g: Bitcast([1]uint32{0xdeadbeef}, dtypes.UInt16) -> [1][2]uint16{{0xbeef, 0xdead}} // Little-endian encoding.
func Bitcast(x *Node, targetDType dtypes.DType) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsBitcast{
		x:           x,
		targetDType: targetDType,
	}
	result, err := g.builder.Bitcast(x.outputOps[0], inputs.targetDType)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsBitwiseAnd holds the inputs used for the call to backends.BitwiseAnd.
type nodeInputsBitwiseAnd struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBitwiseAnd) Type() NodeType {
	return NodeTypeBitwiseAnd
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBitwiseAnd) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// BitwiseAnd returns the element-wise bitwise AND operation.
func BitwiseAnd(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsBitwiseAnd{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.BitwiseAnd(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsBitwiseNot holds the inputs used for the call to backends.BitwiseNot.
type nodeInputsBitwiseNot struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBitwiseNot) Type() NodeType {
	return NodeTypeBitwiseNot
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBitwiseNot) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// BitwiseNot returns the element-wise bitwise AND operation.
func BitwiseNot(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsBitwiseNot{
		x: x,
	}
	result, err := g.builder.BitwiseNot(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsBitwiseOr holds the inputs used for the call to backends.BitwiseOr.
type nodeInputsBitwiseOr struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBitwiseOr) Type() NodeType {
	return NodeTypeBitwiseOr
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBitwiseOr) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// BitwiseOr returns the element-wise bitwise OR operation.
func BitwiseOr(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsBitwiseOr{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.BitwiseOr(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsBitwiseXor holds the inputs used for the call to backends.BitwiseXor.
type nodeInputsBitwiseXor struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBitwiseXor) Type() NodeType {
	return NodeTypeBitwiseXor
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBitwiseXor) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// BitwiseXor returns the element-wise bitwise XOR operator.
func BitwiseXor(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsBitwiseXor{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.BitwiseXor(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsBroadcastInDim holds the inputs used for the call to backends.BroadcastInDim.
type nodeInputsBroadcastInDim struct {
	x             *Node
	outputShape   shapes.Shape
	broadcastAxes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBroadcastInDim) Type() NodeType {
	return NodeTypeBroadcastInDim
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBroadcastInDim) String() string {
	return fmt.Sprintf("%s(x=[#%d], outputShape=%v, broadcastAxes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.outputShape,
		ni.broadcastAxes,
	)
}

// backendBroadcastInDim is a Graph wrapper for the backend.Builder.BroadcastInDim method.
func backendBroadcastInDim(x *Node, outputShape shapes.Shape, broadcastAxes []int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsBroadcastInDim{
		x:             x,
		outputShape:   outputShape,
		broadcastAxes: slices.Clone(broadcastAxes),
	}
	result, err := g.builder.BroadcastInDim(x.outputOps[0], inputs.outputShape, inputs.broadcastAxes)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsCeil holds the inputs used for the call to backends.Ceil.
type nodeInputsCeil struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsCeil) Type() NodeType {
	return NodeTypeCeil
}

// String implements the interface NodeInputs.
func (ni *nodeInputsCeil) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Ceil returns the Op that represents the output of the corresponding operation.
func Ceil(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsCeil{
		x: x,
	}
	result, err := g.builder.Ceil(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsClamp holds the inputs used for the call to backends.Clamp.
type nodeInputsClamp struct {
	min *Node
	x   *Node
	max *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsClamp) Type() NodeType {
	return NodeTypeClamp
}

// String implements the interface NodeInputs.
func (ni *nodeInputsClamp) String() string {
	return fmt.Sprintf("%s(min=[#%d], x=[#%d], max=[#%d])",
		ni.Type(),
		ni.min.Id(),
		ni.x.Id(),
		ni.max.Id(),
	)
}

// Clamp returns the element-wise clamping operation.
//
// The values max and min can either be a scalar or have the same shape as x.
func Clamp(min *Node, x *Node, max *Node) (
	node *Node) {
	inputNodes := []*Node{min, x, max}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsClamp{
		min: min,
		x:   x,
		max: max,
	}
	result, err := g.builder.Clamp(min.outputOps[0], x.outputOps[0], max.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsClz holds the inputs used for the call to backends.Clz.
type nodeInputsClz struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsClz) Type() NodeType {
	return NodeTypeClz
}

// String implements the interface NodeInputs.
func (ni *nodeInputsClz) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Clz returns element-wise the "count leading zeros" bits of input node x -- for integer values.
func Clz(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsClz{
		x: x,
	}
	result, err := g.builder.Clz(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsComplex holds the inputs used for the call to backends.Complex.
type nodeInputsComplex struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsComplex) Type() NodeType {
	return NodeTypeComplex
}

// String implements the interface NodeInputs.
func (ni *nodeInputsComplex) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// Complex returns the complex number taking x0 as the real part and x1 as the imaginary part.
// The real (x0) and imaginary (x1) must have the same dtype, and they must be either `dtypes.Float32` or
// `dtypes.Float64`.
// The output will be either `dtypes.Complex64` or `dtypes.Complex128`, depending on x0 and x1 dtypes.
// The shapes of `real` or `imaginary` must be the same, or one must be a scalar, in which case
// the value is broadcast to every other value.
func Complex(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsComplex{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.Complex(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsConcatenate holds the inputs used for the call to backends.Concatenate.
type nodeInputsConcatenate struct {
	axis     int
	operands []*Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsConcatenate) Type() NodeType {
	return NodeTypeConcatenate
}

// String implements the interface NodeInputs.
func (ni *nodeInputsConcatenate) String() string {
	return fmt.Sprintf("%s(axis=%v, operands=[#%s])",
		ni.Type(),
		ni.axis,
		strings.Join(xslices.Map(ni.operands, func(node *Node) string { return fmt.Sprintf("#%d", node.Id()) }), ", "),
	)
}

// backendConcatenate is a Graph wrapper for the backend.Builder.Concatenate method.
func backendConcatenate(axis int, operands ...*Node) (
	node *Node) {
	inputNodes := []*Node{}
	inputNodes = append(inputNodes, operands...)
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsConcatenate{
		axis:     axis,
		operands: slices.Clone(operands),
	}
	result, err := g.builder.Concatenate(inputs.axis, xslices.Map(operands, func(node *Node) backends.Op { return node.outputOps[0] })...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsConj holds the inputs used for the call to backends.Conj.
type nodeInputsConj struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsConj) Type() NodeType {
	return NodeTypeConj
}

// String implements the interface NodeInputs.
func (ni *nodeInputsConj) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Conj returns the conjugate of a complex number. E.g: Conj(1+3i) = 1-3i
func Conj(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsConj{
		x: x,
	}
	result, err := g.builder.Conj(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsConvGeneral holds the inputs used for the call to backends.ConvGeneral.
type nodeInputsConvGeneral struct {
	input             *Node
	kernel            *Node
	axes              backends.ConvolveAxesConfig
	strides           []int
	paddings          [][2]int
	inputDilations    []int
	kernelDilations   []int
	channelGroupCount int
	batchGroupCount   int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsConvGeneral) Type() NodeType {
	return NodeTypeConvGeneral
}

// String implements the interface NodeInputs.
func (ni *nodeInputsConvGeneral) String() string {
	return fmt.Sprintf("%s(input=[#%d], kernel=[#%d], axes=%+v, strides=%v, paddings=%v, inputDilations=%v, kernelDilations=%v, channelGroupCount=%v, batchGroupCount=%v)",
		ni.Type(),
		ni.input.Id(),
		ni.kernel.Id(),
		ni.axes,
		ni.strides,
		ni.paddings,
		ni.inputDilations,
		ni.kernelDilations,
		ni.channelGroupCount,
		ni.batchGroupCount,
	)
}

// backendConvGeneral is a Graph wrapper for the backend.Builder.ConvGeneral method.
func backendConvGeneral(input *Node, kernel *Node, axes backends.ConvolveAxesConfig, strides []int, paddings [][2]int, inputDilations []int, kernelDilations []int, channelGroupCount int, batchGroupCount int) (
	node *Node) {
	inputNodes := []*Node{input, kernel}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsConvGeneral{
		input:             input,
		kernel:            kernel,
		axes:              axes.Clone(),
		strides:           slices.Clone(strides),
		paddings:          slices.Clone(paddings),
		inputDilations:    slices.Clone(inputDilations),
		kernelDilations:   slices.Clone(kernelDilations),
		channelGroupCount: channelGroupCount,
		batchGroupCount:   batchGroupCount,
	}
	result, err := g.builder.ConvGeneral(input.outputOps[0], kernel.outputOps[0], inputs.axes, inputs.strides, inputs.paddings, inputs.inputDilations, inputs.kernelDilations, inputs.channelGroupCount, inputs.batchGroupCount)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsConvertDType holds the inputs used for the call to backends.ConvertDType.
type nodeInputsConvertDType struct {
	x     *Node
	dtype dtypes.DType
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsConvertDType) Type() NodeType {
	return NodeTypeConvertDType
}

// String implements the interface NodeInputs.
func (ni *nodeInputsConvertDType) String() string {
	return fmt.Sprintf("%s(x=[#%d], dtype=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.dtype,
	)
}

// backendConvertDType is a Graph wrapper for the backend.Builder.ConvertDType method.
func backendConvertDType(x *Node, dtype dtypes.DType) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsConvertDType{
		x:     x,
		dtype: dtype,
	}
	result, err := g.builder.ConvertDType(x.outputOps[0], inputs.dtype)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsCos holds the inputs used for the call to backends.Cos.
type nodeInputsCos struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsCos) Type() NodeType {
	return NodeTypeCos
}

// String implements the interface NodeInputs.
func (ni *nodeInputsCos) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Cos returns the Op that represents the output of the corresponding operation.
func Cos(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsCos{
		x: x,
	}
	result, err := g.builder.Cos(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsDiv holds the inputs used for the call to backends.Div.
type nodeInputsDiv struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsDiv) Type() NodeType {
	return NodeTypeDiv
}

// String implements the interface NodeInputs.
func (ni *nodeInputsDiv) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// Div returns the element-wise division of the two values.
// Standard broadcasting rules apply (see documentation).
func Div(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsDiv{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.Div(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsDot holds the inputs used for the call to backends.Dot.
type nodeInputsDot struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsDot) Type() NodeType {
	return NodeTypeDot
}

// String implements the interface NodeInputs.
func (ni *nodeInputsDot) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// Dot returns the "dot product" operation.
// The exact semantics of this operation depend on the ranks of the operands:
// | Input | Output | Semantics |
// | vector [n] dot vector [n] | scalar | vector dot product |
// | matrix [m x k] dot vector [k] | vector [m]	matrix-vector multiplication |
// | matrix [m x k] dot matrix [k x n] | matrix [m x n] | matrix-matrix multiplication |
// The operation performs sum of products over the second dimension of x0 (or the first if it has rank 1) and
// the first dimension of x1.
// These are the "contracted" dimensions.
// The contracted dimensions of x0 and x1 must be of the same size.
// In practice, it can be used to perform dot products between vectors, vector/matrix multiplications, or
// matrix/matrix multiplications.
func Dot(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsDot{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.Dot(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsDotGeneral holds the inputs used for the call to backends.DotGeneral.
type nodeInputsDotGeneral struct {
	lhs                *Node
	lhsContractingAxes []int
	lhsBatchAxes       []int
	rhs                *Node
	rhsContractingAxes []int
	rhsBatchAxes       []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsDotGeneral) Type() NodeType {
	return NodeTypeDotGeneral
}

// String implements the interface NodeInputs.
func (ni *nodeInputsDotGeneral) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], lhsContractingAxes=%v, lhsBatchAxes=%v, rhs=[#%d], rhsContractingAxes=%v, rhsBatchAxes=%v)",
		ni.Type(),
		ni.lhs.Id(),
		ni.lhsContractingAxes,
		ni.lhsBatchAxes,
		ni.rhs.Id(),
		ni.rhsContractingAxes,
		ni.rhsBatchAxes,
	)
}

// backendDotGeneral is a Graph wrapper for the backend.Builder.DotGeneral method.
func backendDotGeneral(lhs *Node, lhsContractingAxes []int, lhsBatchAxes []int, rhs *Node, rhsContractingAxes []int, rhsBatchAxes []int) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsDotGeneral{
		lhs:                lhs,
		lhsContractingAxes: slices.Clone(lhsContractingAxes),
		lhsBatchAxes:       slices.Clone(lhsBatchAxes),
		rhs:                rhs,
		rhsContractingAxes: slices.Clone(rhsContractingAxes),
		rhsBatchAxes:       slices.Clone(rhsBatchAxes),
	}
	result, err := g.builder.DotGeneral(lhs.outputOps[0], inputs.lhsContractingAxes, inputs.lhsBatchAxes, rhs.outputOps[0], inputs.rhsContractingAxes, inputs.rhsBatchAxes)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsDynamicSlice holds the inputs used for the call to backends.DynamicSlice.
type nodeInputsDynamicSlice struct {
	operand      *Node
	startIndices []*Node
	sliceDims    []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsDynamicSlice) Type() NodeType {
	return NodeTypeDynamicSlice
}

// String implements the interface NodeInputs.
func (ni *nodeInputsDynamicSlice) String() string {
	return fmt.Sprintf("%s(operand=[#%d], startIndices=[#%s], sliceDims=%v)",
		ni.Type(),
		ni.operand.Id(),
		strings.Join(xslices.Map(ni.startIndices, func(node *Node) string { return fmt.Sprintf("#%d", node.Id()) }), ", "),
		ni.sliceDims,
	)
}

// DynamicSlice extracts a slice from the operand at the startIndices position and the given sliceSizes.
//
// - operand: tensor from where to take the slice.
// - startIndices: scalar tensors, one per axis of operand: len(startIndices) == operand.Rank().
// - sliceSizes: static values and fixed to keep the shape of the output static.
//
// The startIndices are adjusted as follows:
//
//	adjustedStartIndices[i] = clamp(0, StartIndices[i], operand.Dimensions[i] - sliceSizes[i])
//
// See description in https://openxla.org/xla/operation_semantics#dynamicslice
func DynamicSlice(operand *Node, startIndices []*Node, sliceDims []int) (
	node *Node) {
	inputNodes := []*Node{operand}
	inputNodes = append(inputNodes, startIndices...)
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsDynamicSlice{
		operand:      operand,
		startIndices: slices.Clone(startIndices),
		sliceDims:    slices.Clone(sliceDims),
	}
	result, err := g.builder.DynamicSlice(operand.outputOps[0], xslices.Map(startIndices, func(node *Node) backends.Op { return node.outputOps[0] }), inputs.sliceDims)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsDynamicUpdateSlice holds the inputs used for the call to backends.DynamicUpdateSlice.
type nodeInputsDynamicUpdateSlice struct {
	operand      *Node
	update       *Node
	startIndices []*Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsDynamicUpdateSlice) Type() NodeType {
	return NodeTypeDynamicUpdateSlice
}

// String implements the interface NodeInputs.
func (ni *nodeInputsDynamicUpdateSlice) String() string {
	return fmt.Sprintf("%s(operand=[#%d], update=[#%d], startIndices=[#%s])",
		ni.Type(),
		ni.operand.Id(),
		ni.update.Id(),
		strings.Join(xslices.Map(ni.startIndices, func(node *Node) string { return fmt.Sprintf("#%d", node.Id()) }), ", "),
	)
}

// DynamicUpdateSlice updates the operand with the values given in update, at the position given by startIndices.
//
// - operand: original value that to be updated.
// - update: values to "paste" on top of operand, at position startIndices.
// - startIndices: scalar tensors, one per axis of operand: len(startIndices) == operand.Rank().
// - sliceSizes: static values and fixed to keep the shape of the output static.
//
// It returns a value with the same shape as the operand, with the values updated.
//
// The startIndices are adjusted as follows:
//
//	adjustedStartIndices[i] = clamp(0, StartIndices[i], operand.Dimensions[i] - update.Dimensions[i])
func DynamicUpdateSlice(operand *Node, update *Node, startIndices []*Node) (
	node *Node) {
	inputNodes := []*Node{operand, update}
	inputNodes = append(inputNodes, startIndices...)
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsDynamicUpdateSlice{
		operand:      operand,
		update:       update,
		startIndices: slices.Clone(startIndices),
	}
	result, err := g.builder.DynamicUpdateSlice(operand.outputOps[0], update.outputOps[0], xslices.Map(startIndices, func(node *Node) backends.Op { return node.outputOps[0] }))
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsEqual holds the inputs used for the call to backends.Equal.
type nodeInputsEqual struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsEqual) Type() NodeType {
	return NodeTypeEqual
}

// String implements the interface NodeInputs.
func (ni *nodeInputsEqual) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// Equal performs element-wise equality check, returns boolean results with the same dimensions as input.
func Equal(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsEqual{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.Equal(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsEqualTotalOrder holds the inputs used for the call to backends.EqualTotalOrder.
type nodeInputsEqualTotalOrder struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsEqualTotalOrder) Type() NodeType {
	return NodeTypeEqualTotalOrder
}

// String implements the interface NodeInputs.
func (ni *nodeInputsEqualTotalOrder) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// EqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
func EqualTotalOrder(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsEqualTotalOrder{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.EqualTotalOrder(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsErf holds the inputs used for the call to backends.Erf.
type nodeInputsErf struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsErf) Type() NodeType {
	return NodeTypeErf
}

// String implements the interface NodeInputs.
func (ni *nodeInputsErf) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Erf returns the "error function", defined as erf(x) = 2/Pi * \int_{0}^{x}{e^{-t^2}dt}.
func Erf(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsErf{
		x: x,
	}
	result, err := g.builder.Erf(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsExp holds the inputs used for the call to backends.Exp.
type nodeInputsExp struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsExp) Type() NodeType {
	return NodeTypeExp
}

// String implements the interface NodeInputs.
func (ni *nodeInputsExp) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Exp returns the Op that represents the output of the corresponding operation.
func Exp(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsExp{
		x: x,
	}
	result, err := g.builder.Exp(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsExpm1 holds the inputs used for the call to backends.Expm1.
type nodeInputsExpm1 struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsExpm1) Type() NodeType {
	return NodeTypeExpm1
}

// String implements the interface NodeInputs.
func (ni *nodeInputsExpm1) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Expm1 returns the Op that represents the output of the corresponding operation.
func Expm1(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsExpm1{
		x: x,
	}
	result, err := g.builder.Expm1(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsFFT holds the inputs used for the call to backends.FFT.
type nodeInputsFFT struct {
	operand   *Node
	fftType   backends.FFTType
	fftLength []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsFFT) Type() NodeType {
	return NodeTypeFFT
}

// String implements the interface NodeInputs.
func (ni *nodeInputsFFT) String() string {
	return fmt.Sprintf("%s(operand=[#%d], fftType=%s, fftLength=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.fftType,
		ni.fftLength,
	)
}

// backendFFT is a Graph wrapper for the backend.Builder.FFT method.
func backendFFT(operand *Node, fftType backends.FFTType, fftLength []int) (
	node *Node) {
	inputNodes := []*Node{operand}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsFFT{
		operand:   operand,
		fftType:   fftType,
		fftLength: slices.Clone(fftLength),
	}
	result, err := g.builder.FFT(operand.outputOps[0], inputs.fftType, inputs.fftLength)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsFloor holds the inputs used for the call to backends.Floor.
type nodeInputsFloor struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsFloor) Type() NodeType {
	return NodeTypeFloor
}

// String implements the interface NodeInputs.
func (ni *nodeInputsFloor) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Floor returns the Op that represents the output of the corresponding operation.
func Floor(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsFloor{
		x: x,
	}
	result, err := g.builder.Floor(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsGather holds the inputs used for the call to backends.Gather.
type nodeInputsGather struct {
	operand            *Node
	startIndices       *Node
	indexVectorAxis    int
	offsetOutputAxes   []int
	collapsedSliceAxes []int
	startIndexMap      []int
	sliceSizes         []int
	indicesAreSorted   bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGather) Type() NodeType {
	return NodeTypeGather
}

// String implements the interface NodeInputs.
func (ni *nodeInputsGather) String() string {
	return fmt.Sprintf("%s(operand=[#%d], startIndices=[#%d], indexVectorAxis=%v, offsetOutputAxes=%v, collapsedSliceAxes=%v, startIndexMap=%v, sliceSizes=%v, indicesAreSorted=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.startIndices.Id(),
		ni.indexVectorAxis,
		ni.offsetOutputAxes,
		ni.collapsedSliceAxes,
		ni.startIndexMap,
		ni.sliceSizes,
		ni.indicesAreSorted,
	)
}

// backendGather is a Graph wrapper for the backend.Builder.Gather method.
func backendGather(operand *Node, startIndices *Node, indexVectorAxis int, offsetOutputAxes []int, collapsedSliceAxes []int, startIndexMap []int, sliceSizes []int, indicesAreSorted bool) (
	node *Node) {
	inputNodes := []*Node{operand, startIndices}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsGather{
		operand:            operand,
		startIndices:       startIndices,
		indexVectorAxis:    indexVectorAxis,
		offsetOutputAxes:   slices.Clone(offsetOutputAxes),
		collapsedSliceAxes: slices.Clone(collapsedSliceAxes),
		startIndexMap:      slices.Clone(startIndexMap),
		sliceSizes:         slices.Clone(sliceSizes),
		indicesAreSorted:   indicesAreSorted,
	}
	result, err := g.builder.Gather(operand.outputOps[0], startIndices.outputOps[0], inputs.indexVectorAxis, inputs.offsetOutputAxes, inputs.collapsedSliceAxes, inputs.startIndexMap, inputs.sliceSizes, inputs.indicesAreSorted)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsGreaterOrEqual holds the inputs used for the call to backends.GreaterOrEqual.
type nodeInputsGreaterOrEqual struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGreaterOrEqual) Type() NodeType {
	return NodeTypeGreaterOrEqual
}

// String implements the interface NodeInputs.
func (ni *nodeInputsGreaterOrEqual) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// GreaterOrEqual performs element-wise comparison, returns boolean results with the same dimensions as input.
func GreaterOrEqual(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsGreaterOrEqual{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.GreaterOrEqual(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsGreaterOrEqualTotalOrder holds the inputs used for the call to backends.GreaterOrEqualTotalOrder.
type nodeInputsGreaterOrEqualTotalOrder struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGreaterOrEqualTotalOrder) Type() NodeType {
	return NodeTypeGreaterOrEqualTotalOrder
}

// String implements the interface NodeInputs.
func (ni *nodeInputsGreaterOrEqualTotalOrder) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// GreaterOrEqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
func GreaterOrEqualTotalOrder(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsGreaterOrEqualTotalOrder{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.GreaterOrEqualTotalOrder(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsGreaterThan holds the inputs used for the call to backends.GreaterThan.
type nodeInputsGreaterThan struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGreaterThan) Type() NodeType {
	return NodeTypeGreaterThan
}

// String implements the interface NodeInputs.
func (ni *nodeInputsGreaterThan) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// GreaterThan performs element-wise comparison, returns boolean results with the same dimensions as input.
func GreaterThan(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsGreaterThan{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.GreaterThan(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsGreaterThanTotalOrder holds the inputs used for the call to backends.GreaterThanTotalOrder.
type nodeInputsGreaterThanTotalOrder struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGreaterThanTotalOrder) Type() NodeType {
	return NodeTypeGreaterThanTotalOrder
}

// String implements the interface NodeInputs.
func (ni *nodeInputsGreaterThanTotalOrder) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// GreaterThanTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
func GreaterThanTotalOrder(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsGreaterThanTotalOrder{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.GreaterThanTotalOrder(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsIdentity holds the inputs used for the call to backends.Identity.
type nodeInputsIdentity struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsIdentity) Type() NodeType {
	return NodeTypeIdentity
}

// String implements the interface NodeInputs.
func (ni *nodeInputsIdentity) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Identity returns an Op whose output is the same as its input.
// It's a no-op that can serve as a place-holder.
func Identity(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsIdentity{
		x: x,
	}
	result, err := g.builder.Identity(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsImag holds the inputs used for the call to backends.Imag.
type nodeInputsImag struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsImag) Type() NodeType {
	return NodeTypeImag
}

// String implements the interface NodeInputs.
func (ni *nodeInputsImag) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Imag returns the imaginary part of a complex number. It returns 0 if the x is a float number.
func Imag(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsImag{
		x: x,
	}
	result, err := g.builder.Imag(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsIota holds the inputs used for the call to backends.Iota.
type nodeInputsIota struct {
	shape    shapes.Shape
	iotaAxis int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsIota) Type() NodeType {
	return NodeTypeIota
}

// String implements the interface NodeInputs.
func (ni *nodeInputsIota) String() string {
	return fmt.Sprintf("%s(shape=%v, iotaAxis=%v)",
		ni.Type(),
		ni.shape,
		ni.iotaAxis,
	)
}

// backendIota is a Graph wrapper for the backend.Builder.Iota method.
func backendIota(g *Graph, shape shapes.Shape, iotaAxis int) (
	node *Node) {
	g.AssertBuilding()
	inputs := &nodeInputsIota{
		shape:    shape,
		iotaAxis: iotaAxis,
	}
	result, err := g.builder.Iota(inputs.shape, inputs.iotaAxis)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
	}
	g.registerNode(node)
	return
}

// nodeInputsIsFinite holds the inputs used for the call to backends.IsFinite.
type nodeInputsIsFinite struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsIsFinite) Type() NodeType {
	return NodeTypeIsFinite
}

// String implements the interface NodeInputs.
func (ni *nodeInputsIsFinite) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// IsFinite tests whether each element of operand is finite, i.e., if it is not positive nor negative infinity, and it is not NaN.
// It returns the same shape as the input, but with boolean values where each element is true if and only if
// the corresponding input element is finite.
func IsFinite(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsIsFinite{
		x: x,
	}
	result, err := g.builder.IsFinite(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsIsNaN holds the inputs used for the call to backends.IsNaN.
type nodeInputsIsNaN struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsIsNaN) Type() NodeType {
	return NodeTypeIsNaN
}

// String implements the interface NodeInputs.
func (ni *nodeInputsIsNaN) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// IsNaN tests whether each element of operand is NaN, i.e., if it is not a finite number.
func IsNaN(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsIsNaN{
		x: x,
	}
	result, err := g.builder.IsNaN(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLessOrEqual holds the inputs used for the call to backends.LessOrEqual.
type nodeInputsLessOrEqual struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLessOrEqual) Type() NodeType {
	return NodeTypeLessOrEqual
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLessOrEqual) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// LessOrEqual performs element-wise comparison, returns boolean results with the same dimensions as input.
func LessOrEqual(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsLessOrEqual{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.LessOrEqual(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsLessOrEqualTotalOrder holds the inputs used for the call to backends.LessOrEqualTotalOrder.
type nodeInputsLessOrEqualTotalOrder struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLessOrEqualTotalOrder) Type() NodeType {
	return NodeTypeLessOrEqualTotalOrder
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLessOrEqualTotalOrder) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// LessOrEqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
func LessOrEqualTotalOrder(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsLessOrEqualTotalOrder{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.LessOrEqualTotalOrder(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsLessThan holds the inputs used for the call to backends.LessThan.
type nodeInputsLessThan struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLessThan) Type() NodeType {
	return NodeTypeLessThan
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLessThan) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// LessThan performs element-wise comparison, returns boolean results with the same dimensions as input.
func LessThan(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsLessThan{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.LessThan(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsLessThanTotalOrder holds the inputs used for the call to backends.LessThanTotalOrder.
type nodeInputsLessThanTotalOrder struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLessThanTotalOrder) Type() NodeType {
	return NodeTypeLessThanTotalOrder
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLessThanTotalOrder) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// LessThanTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
func LessThanTotalOrder(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsLessThanTotalOrder{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.LessThanTotalOrder(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsLog holds the inputs used for the call to backends.Log.
type nodeInputsLog struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLog) Type() NodeType {
	return NodeTypeLog
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLog) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Log returns the Op that represents the output of the corresponding operation.
func Log(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsLog{
		x: x,
	}
	result, err := g.builder.Log(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLog1p holds the inputs used for the call to backends.Log1p.
type nodeInputsLog1p struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLog1p) Type() NodeType {
	return NodeTypeLog1p
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLog1p) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Log1p returns the expression log(x+1).
func Log1p(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsLog1p{
		x: x,
	}
	result, err := g.builder.Log1p(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLogicalAnd holds the inputs used for the call to backends.LogicalAnd.
type nodeInputsLogicalAnd struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLogicalAnd) Type() NodeType {
	return NodeTypeLogicalAnd
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLogicalAnd) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// LogicalAnd returns the element-wise logical AND operation.
func LogicalAnd(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsLogicalAnd{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.LogicalAnd(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLogicalNot holds the inputs used for the call to backends.LogicalNot.
type nodeInputsLogicalNot struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLogicalNot) Type() NodeType {
	return NodeTypeLogicalNot
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLogicalNot) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// LogicalNot returns the Op that represents the output of the corresponding operation.
func LogicalNot(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsLogicalNot{
		x: x,
	}
	result, err := g.builder.LogicalNot(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsLogicalOr holds the inputs used for the call to backends.LogicalOr.
type nodeInputsLogicalOr struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLogicalOr) Type() NodeType {
	return NodeTypeLogicalOr
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLogicalOr) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// LogicalOr returns the element-wise logical OR operation.
func LogicalOr(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsLogicalOr{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.LogicalOr(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLogicalXor holds the inputs used for the call to backends.LogicalXor.
type nodeInputsLogicalXor struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLogicalXor) Type() NodeType {
	return NodeTypeLogicalXor
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLogicalXor) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// LogicalXor returns the element-wise logical XOR operator.
func LogicalXor(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsLogicalXor{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.LogicalXor(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLogistic holds the inputs used for the call to backends.Logistic.
type nodeInputsLogistic struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLogistic) Type() NodeType {
	return NodeTypeLogistic
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLogistic) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Logistic returns the element-wise expression 1/(1+exp(-x)). Also known as the Sigmoid function.
func Logistic(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsLogistic{
		x: x,
	}
	result, err := g.builder.Logistic(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsMax holds the inputs used for the call to backends.Max.
type nodeInputsMax struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsMax) Type() NodeType {
	return NodeTypeMax
}

// String implements the interface NodeInputs.
func (ni *nodeInputsMax) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// Max returns the element-wise highest value among the two.
func Max(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsMax{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.Max(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsMin holds the inputs used for the call to backends.Min.
type nodeInputsMin struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsMin) Type() NodeType {
	return NodeTypeMin
}

// String implements the interface NodeInputs.
func (ni *nodeInputsMin) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// Min returns the element-wise smallest value among the two.
func Min(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsMin{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.Min(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsMul holds the inputs used for the call to backends.Mul.
type nodeInputsMul struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsMul) Type() NodeType {
	return NodeTypeMul
}

// String implements the interface NodeInputs.
func (ni *nodeInputsMul) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// Mul returns the element-wise multiplication of the two values.
// Standard broadcasting rules apply (see documentation).
func Mul(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsMul{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.Mul(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsNeg holds the inputs used for the call to backends.Neg.
type nodeInputsNeg struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsNeg) Type() NodeType {
	return NodeTypeNeg
}

// String implements the interface NodeInputs.
func (ni *nodeInputsNeg) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Neg returns the Op that represents the output of the corresponding operation.
func Neg(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsNeg{
		x: x,
	}
	result, err := g.builder.Neg(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsNotEqual holds the inputs used for the call to backends.NotEqual.
type nodeInputsNotEqual struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsNotEqual) Type() NodeType {
	return NodeTypeNotEqual
}

// String implements the interface NodeInputs.
func (ni *nodeInputsNotEqual) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// NotEqual performs element-wise inequality check, returns boolean results with the same dimensions as input.
func NotEqual(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsNotEqual{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.NotEqual(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsNotEqualTotalOrder holds the inputs used for the call to backends.NotEqualTotalOrder.
type nodeInputsNotEqualTotalOrder struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsNotEqualTotalOrder) Type() NodeType {
	return NodeTypeNotEqualTotalOrder
}

// String implements the interface NodeInputs.
func (ni *nodeInputsNotEqualTotalOrder) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// NotEqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
func NotEqualTotalOrder(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsNotEqualTotalOrder{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.NotEqualTotalOrder(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
		stopGradient: true,
	}
	g.registerNode(node)
	return
}

// nodeInputsPad holds the inputs used for the call to backends.Pad.
type nodeInputsPad struct {
	x          *Node
	fillValue  *Node
	axesConfig []backends.PadAxis
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsPad) Type() NodeType {
	return NodeTypePad
}

// String implements the interface NodeInputs.
func (ni *nodeInputsPad) String() string {
	return fmt.Sprintf("%s(x=[#%d], fillValue=[#%d], axesConfig=%+v)",
		ni.Type(),
		ni.x.Id(),
		ni.fillValue.Id(),
		ni.axesConfig,
	)
}

// Pad injects padding on the start, end, or interior (in between each element) of the given operand.
// There must be at most `operand.Rank()` axesConfig values. Missing PadAxis are assumed to be zeros,
// that is, no padding for those axes.
func Pad(x *Node, fillValue *Node, axesConfig ...backends.PadAxis) (
	node *Node) {
	inputNodes := []*Node{x, fillValue}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsPad{
		x:          x,
		fillValue:  fillValue,
		axesConfig: slices.Clone(axesConfig),
	}
	result, err := g.builder.Pad(x.outputOps[0], fillValue.outputOps[0], inputs.axesConfig...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsPow holds the inputs used for the call to backends.Pow.
type nodeInputsPow struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsPow) Type() NodeType {
	return NodeTypePow
}

// String implements the interface NodeInputs.
func (ni *nodeInputsPow) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// Pow returns the Op that represents the output of the corresponding operation.
func Pow(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsPow{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.Pow(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsRNGBitGenerator holds the inputs used for the call to backends.RNGBitGenerator.
type nodeInputsRNGBitGenerator struct {
	state *Node
	shape shapes.Shape
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsRNGBitGenerator) Type() NodeType {
	return NodeTypeRNGBitGenerator
}

// String implements the interface NodeInputs.
func (ni *nodeInputsRNGBitGenerator) String() string {
	return fmt.Sprintf("%s(state=[#%d], shape=%v)",
		ni.Type(),
		ni.state.Id(),
		ni.shape,
	)
}

// backendRNGBitGenerator is a Graph wrapper for the backend.Builder.RNGBitGenerator method.
func backendRNGBitGenerator(state *Node, shape shapes.Shape) (
	newState, values *Node) {
	inputNodes := []*Node{state}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsRNGBitGenerator{
		state: state,
		shape: shape,
	}
	v0, v1, err := g.builder.RNGBitGenerator(state.outputOps[0], inputs.shape)
	if err != nil {
		panic(err)
	}
	node := &Node{
		outputOps:    []backends.Op{v0, v1},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(v0)), mustNoError(g.builder.OpShape(v1))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	splitNodes := splitNode(node)
	newState, values = splitNodes[0], splitNodes[1]
	return
}

// nodeInputsReal holds the inputs used for the call to backends.Real.
type nodeInputsReal struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReal) Type() NodeType {
	return NodeTypeReal
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReal) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Real return the real part of a complex number. It returns x if the x is a float number.
func Real(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReal{
		x: x,
	}
	result, err := g.builder.Real(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceBitwiseAnd holds the inputs used for the call to backends.ReduceBitwiseAnd.
type nodeInputsReduceBitwiseAnd struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceBitwiseAnd) Type() NodeType {
	return NodeTypeReduceBitwiseAnd
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceBitwiseAnd) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceBitwiseAnd is a Graph wrapper for the backend.Builder.ReduceBitwiseAnd method.
func backendReduceBitwiseAnd(x *Node, axes ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReduceBitwiseAnd{
		x:    x,
		axes: slices.Clone(axes),
	}
	result, err := g.builder.ReduceBitwiseAnd(x.outputOps[0], inputs.axes...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceBitwiseOr holds the inputs used for the call to backends.ReduceBitwiseOr.
type nodeInputsReduceBitwiseOr struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceBitwiseOr) Type() NodeType {
	return NodeTypeReduceBitwiseOr
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceBitwiseOr) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceBitwiseOr is a Graph wrapper for the backend.Builder.ReduceBitwiseOr method.
func backendReduceBitwiseOr(x *Node, axes ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReduceBitwiseOr{
		x:    x,
		axes: slices.Clone(axes),
	}
	result, err := g.builder.ReduceBitwiseOr(x.outputOps[0], inputs.axes...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceBitwiseXor holds the inputs used for the call to backends.ReduceBitwiseXor.
type nodeInputsReduceBitwiseXor struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceBitwiseXor) Type() NodeType {
	return NodeTypeReduceBitwiseXor
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceBitwiseXor) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceBitwiseXor is a Graph wrapper for the backend.Builder.ReduceBitwiseXor method.
func backendReduceBitwiseXor(x *Node, axes ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReduceBitwiseXor{
		x:    x,
		axes: slices.Clone(axes),
	}
	result, err := g.builder.ReduceBitwiseXor(x.outputOps[0], inputs.axes...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceLogicalAnd holds the inputs used for the call to backends.ReduceLogicalAnd.
type nodeInputsReduceLogicalAnd struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceLogicalAnd) Type() NodeType {
	return NodeTypeReduceLogicalAnd
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceLogicalAnd) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceLogicalAnd is a Graph wrapper for the backend.Builder.ReduceLogicalAnd method.
func backendReduceLogicalAnd(x *Node, axes ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReduceLogicalAnd{
		x:    x,
		axes: slices.Clone(axes),
	}
	result, err := g.builder.ReduceLogicalAnd(x.outputOps[0], inputs.axes...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceLogicalOr holds the inputs used for the call to backends.ReduceLogicalOr.
type nodeInputsReduceLogicalOr struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceLogicalOr) Type() NodeType {
	return NodeTypeReduceLogicalOr
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceLogicalOr) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceLogicalOr is a Graph wrapper for the backend.Builder.ReduceLogicalOr method.
func backendReduceLogicalOr(x *Node, axes ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReduceLogicalOr{
		x:    x,
		axes: slices.Clone(axes),
	}
	result, err := g.builder.ReduceLogicalOr(x.outputOps[0], inputs.axes...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceLogicalXor holds the inputs used for the call to backends.ReduceLogicalXor.
type nodeInputsReduceLogicalXor struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceLogicalXor) Type() NodeType {
	return NodeTypeReduceLogicalXor
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceLogicalXor) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceLogicalXor is a Graph wrapper for the backend.Builder.ReduceLogicalXor method.
func backendReduceLogicalXor(x *Node, axes ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReduceLogicalXor{
		x:    x,
		axes: slices.Clone(axes),
	}
	result, err := g.builder.ReduceLogicalXor(x.outputOps[0], inputs.axes...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceMax holds the inputs used for the call to backends.ReduceMax.
type nodeInputsReduceMax struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceMax) Type() NodeType {
	return NodeTypeReduceMax
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceMax) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceMax is a Graph wrapper for the backend.Builder.ReduceMax method.
func backendReduceMax(x *Node, axes ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReduceMax{
		x:    x,
		axes: slices.Clone(axes),
	}
	result, err := g.builder.ReduceMax(x.outputOps[0], inputs.axes...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceMin holds the inputs used for the call to backends.ReduceMin.
type nodeInputsReduceMin struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceMin) Type() NodeType {
	return NodeTypeReduceMin
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceMin) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceMin is a Graph wrapper for the backend.Builder.ReduceMin method.
func backendReduceMin(x *Node, axes ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReduceMin{
		x:    x,
		axes: slices.Clone(axes),
	}
	result, err := g.builder.ReduceMin(x.outputOps[0], inputs.axes...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceProduct holds the inputs used for the call to backends.ReduceProduct.
type nodeInputsReduceProduct struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceProduct) Type() NodeType {
	return NodeTypeReduceProduct
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceProduct) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceProduct is a Graph wrapper for the backend.Builder.ReduceProduct method.
func backendReduceProduct(x *Node, axes ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReduceProduct{
		x:    x,
		axes: slices.Clone(axes),
	}
	result, err := g.builder.ReduceProduct(x.outputOps[0], inputs.axes...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceSum holds the inputs used for the call to backends.ReduceSum.
type nodeInputsReduceSum struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceSum) Type() NodeType {
	return NodeTypeReduceSum
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceSum) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceSum is a Graph wrapper for the backend.Builder.ReduceSum method.
func backendReduceSum(x *Node, axes ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReduceSum{
		x:    x,
		axes: slices.Clone(axes),
	}
	result, err := g.builder.ReduceSum(x.outputOps[0], inputs.axes...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceWindow holds the inputs used for the call to backends.ReduceWindow.
type nodeInputsReduceWindow struct {
	x                *Node
	reductionType    ReduceOpType
	windowDimensions []int
	strides          []int
	baseDilations    []int
	windowDilations  []int
	paddings         [][2]int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceWindow) Type() NodeType {
	return NodeTypeReduceWindow
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceWindow) String() string {
	return fmt.Sprintf("%s(x=[#%d], reductionType=%v, windowDimensions=%v, strides=%v, baseDilations=%v, windowDilations=%v, paddings=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.reductionType,
		ni.windowDimensions,
		ni.strides,
		ni.baseDilations,
		ni.windowDilations,
		ni.paddings,
	)
}

// backendReduceWindow is a Graph wrapper for the backend.Builder.ReduceWindow method.
func backendReduceWindow(x *Node, reductionType ReduceOpType, windowDimensions []int, strides []int, baseDilations []int, windowDilations []int, paddings [][2]int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReduceWindow{
		x:                x,
		reductionType:    reductionType,
		windowDimensions: slices.Clone(windowDimensions),
		strides:          slices.Clone(strides),
		baseDilations:    slices.Clone(baseDilations),
		windowDilations:  slices.Clone(windowDilations),
		paddings:         slices.Clone(paddings),
	}
	result, err := g.builder.ReduceWindow(x.outputOps[0], inputs.reductionType, inputs.windowDimensions, inputs.strides, inputs.baseDilations, inputs.windowDilations, inputs.paddings)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsRem holds the inputs used for the call to backends.Rem.
type nodeInputsRem struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsRem) Type() NodeType {
	return NodeTypeRem
}

// String implements the interface NodeInputs.
func (ni *nodeInputsRem) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// Rem returns the remainder operation, also known as modulo (or Mod for short).
// Notice despite the name XLA implements Mod not IEEE754 Remainder operation.
func Rem(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsRem{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.Rem(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReshape holds the inputs used for the call to backends.Reshape.
type nodeInputsReshape struct {
	x          *Node
	dimensions []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReshape) Type() NodeType {
	return NodeTypeReshape
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReshape) String() string {
	return fmt.Sprintf("%s(x=[#%d], dimensions=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.dimensions,
	)
}

// backendReshape is a Graph wrapper for the backend.Builder.Reshape method.
func backendReshape(x *Node, dimensions ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReshape{
		x:          x,
		dimensions: slices.Clone(dimensions),
	}
	result, err := g.builder.Reshape(x.outputOps[0], inputs.dimensions...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReverse holds the inputs used for the call to backends.Reverse.
type nodeInputsReverse struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReverse) Type() NodeType {
	return NodeTypeReverse
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReverse) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReverse is a Graph wrapper for the backend.Builder.Reverse method.
func backendReverse(x *Node, axes ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsReverse{
		x:    x,
		axes: slices.Clone(axes),
	}
	result, err := g.builder.Reverse(x.outputOps[0], inputs.axes...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsRound holds the inputs used for the call to backends.Round.
type nodeInputsRound struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsRound) Type() NodeType {
	return NodeTypeRound
}

// String implements the interface NodeInputs.
func (ni *nodeInputsRound) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Round returns the Op that represents the output of the corresponding operation.
// This operation rounds to the nearest even.
func Round(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsRound{
		x: x,
	}
	result, err := g.builder.Round(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsRsqrt holds the inputs used for the call to backends.Rsqrt.
type nodeInputsRsqrt struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsRsqrt) Type() NodeType {
	return NodeTypeRsqrt
}

// String implements the interface NodeInputs.
func (ni *nodeInputsRsqrt) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Rsqrt returns the element-wise reciprocal of square root operation 1/sqrt(x).
func Rsqrt(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsRsqrt{
		x: x,
	}
	result, err := g.builder.Rsqrt(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsScatterMax holds the inputs used for the call to backends.ScatterMax.
type nodeInputsScatterMax struct {
	operand                  *Node
	scatterIndices           *Node
	updates                  *Node
	indexVectorAxis          int
	updateWindowAxes         []int
	insertedWindowAxes       []int
	scatterAxesToOperandAxes []int
	indicesAreSorted         bool
	uniqueIndices            bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsScatterMax) Type() NodeType {
	return NodeTypeScatterMax
}

// String implements the interface NodeInputs.
func (ni *nodeInputsScatterMax) String() string {
	return fmt.Sprintf("%s(operand=[#%d], scatterIndices=[#%d], updates=[#%d], indexVectorAxis=%v, updateWindowAxes=%v, insertedWindowAxes=%v, scatterAxesToOperandAxes=%v, indicesAreSorted=%v, uniqueIndices=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.scatterIndices.Id(),
		ni.updates.Id(),
		ni.indexVectorAxis,
		ni.updateWindowAxes,
		ni.insertedWindowAxes,
		ni.scatterAxesToOperandAxes,
		ni.indicesAreSorted,
		ni.uniqueIndices,
	)
}

// backendScatterMax is a Graph wrapper for the backend.Builder.ScatterMax method.
func backendScatterMax(operand *Node, scatterIndices *Node, updates *Node, indexVectorAxis int, updateWindowAxes []int, insertedWindowAxes []int, scatterAxesToOperandAxes []int, indicesAreSorted bool, uniqueIndices bool) (
	node *Node) {
	inputNodes := []*Node{operand, scatterIndices, updates}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsScatterMax{
		operand:                  operand,
		scatterIndices:           scatterIndices,
		updates:                  updates,
		indexVectorAxis:          indexVectorAxis,
		updateWindowAxes:         slices.Clone(updateWindowAxes),
		insertedWindowAxes:       slices.Clone(insertedWindowAxes),
		scatterAxesToOperandAxes: slices.Clone(scatterAxesToOperandAxes),
		indicesAreSorted:         indicesAreSorted,
		uniqueIndices:            uniqueIndices,
	}
	result, err := g.builder.ScatterMax(operand.outputOps[0], scatterIndices.outputOps[0], updates.outputOps[0], inputs.indexVectorAxis, inputs.updateWindowAxes, inputs.insertedWindowAxes, inputs.scatterAxesToOperandAxes, inputs.indicesAreSorted, inputs.uniqueIndices)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsScatterMin holds the inputs used for the call to backends.ScatterMin.
type nodeInputsScatterMin struct {
	operand                  *Node
	scatterIndices           *Node
	updates                  *Node
	indexVectorAxis          int
	updateWindowAxes         []int
	insertedWindowAxes       []int
	scatterAxesToOperandAxes []int
	indicesAreSorted         bool
	uniqueIndices            bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsScatterMin) Type() NodeType {
	return NodeTypeScatterMin
}

// String implements the interface NodeInputs.
func (ni *nodeInputsScatterMin) String() string {
	return fmt.Sprintf("%s(operand=[#%d], scatterIndices=[#%d], updates=[#%d], indexVectorAxis=%v, updateWindowAxes=%v, insertedWindowAxes=%v, scatterAxesToOperandAxes=%v, indicesAreSorted=%v, uniqueIndices=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.scatterIndices.Id(),
		ni.updates.Id(),
		ni.indexVectorAxis,
		ni.updateWindowAxes,
		ni.insertedWindowAxes,
		ni.scatterAxesToOperandAxes,
		ni.indicesAreSorted,
		ni.uniqueIndices,
	)
}

// backendScatterMin is a Graph wrapper for the backend.Builder.ScatterMin method.
func backendScatterMin(operand *Node, scatterIndices *Node, updates *Node, indexVectorAxis int, updateWindowAxes []int, insertedWindowAxes []int, scatterAxesToOperandAxes []int, indicesAreSorted bool, uniqueIndices bool) (
	node *Node) {
	inputNodes := []*Node{operand, scatterIndices, updates}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsScatterMin{
		operand:                  operand,
		scatterIndices:           scatterIndices,
		updates:                  updates,
		indexVectorAxis:          indexVectorAxis,
		updateWindowAxes:         slices.Clone(updateWindowAxes),
		insertedWindowAxes:       slices.Clone(insertedWindowAxes),
		scatterAxesToOperandAxes: slices.Clone(scatterAxesToOperandAxes),
		indicesAreSorted:         indicesAreSorted,
		uniqueIndices:            uniqueIndices,
	}
	result, err := g.builder.ScatterMin(operand.outputOps[0], scatterIndices.outputOps[0], updates.outputOps[0], inputs.indexVectorAxis, inputs.updateWindowAxes, inputs.insertedWindowAxes, inputs.scatterAxesToOperandAxes, inputs.indicesAreSorted, inputs.uniqueIndices)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsScatterSum holds the inputs used for the call to backends.ScatterSum.
type nodeInputsScatterSum struct {
	operand                  *Node
	scatterIndices           *Node
	updates                  *Node
	indexVectorAxis          int
	updateWindowAxes         []int
	insertedWindowAxes       []int
	scatterAxesToOperandAxes []int
	indicesAreSorted         bool
	uniqueIndices            bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsScatterSum) Type() NodeType {
	return NodeTypeScatterSum
}

// String implements the interface NodeInputs.
func (ni *nodeInputsScatterSum) String() string {
	return fmt.Sprintf("%s(operand=[#%d], scatterIndices=[#%d], updates=[#%d], indexVectorAxis=%v, updateWindowAxes=%v, insertedWindowAxes=%v, scatterAxesToOperandAxes=%v, indicesAreSorted=%v, uniqueIndices=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.scatterIndices.Id(),
		ni.updates.Id(),
		ni.indexVectorAxis,
		ni.updateWindowAxes,
		ni.insertedWindowAxes,
		ni.scatterAxesToOperandAxes,
		ni.indicesAreSorted,
		ni.uniqueIndices,
	)
}

// backendScatterSum is a Graph wrapper for the backend.Builder.ScatterSum method.
func backendScatterSum(operand *Node, scatterIndices *Node, updates *Node, indexVectorAxis int, updateWindowAxes []int, insertedWindowAxes []int, scatterAxesToOperandAxes []int, indicesAreSorted bool, uniqueIndices bool) (
	node *Node) {
	inputNodes := []*Node{operand, scatterIndices, updates}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsScatterSum{
		operand:                  operand,
		scatterIndices:           scatterIndices,
		updates:                  updates,
		indexVectorAxis:          indexVectorAxis,
		updateWindowAxes:         slices.Clone(updateWindowAxes),
		insertedWindowAxes:       slices.Clone(insertedWindowAxes),
		scatterAxesToOperandAxes: slices.Clone(scatterAxesToOperandAxes),
		indicesAreSorted:         indicesAreSorted,
		uniqueIndices:            uniqueIndices,
	}
	result, err := g.builder.ScatterSum(operand.outputOps[0], scatterIndices.outputOps[0], updates.outputOps[0], inputs.indexVectorAxis, inputs.updateWindowAxes, inputs.insertedWindowAxes, inputs.scatterAxesToOperandAxes, inputs.indicesAreSorted, inputs.uniqueIndices)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSelectAndScatterMax holds the inputs used for the call to backends.SelectAndScatterMax.
type nodeInputsSelectAndScatterMax struct {
	operand          *Node
	source           *Node
	windowDimensions []int
	windowStrides    []int
	paddings         [][2]int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterMax) Type() NodeType {
	return NodeTypeSelectAndScatterMax
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterMax) String() string {
	return fmt.Sprintf("%s(operand=[#%d], source=[#%d], windowDimensions=%v, windowStrides=%v, paddings=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.source.Id(),
		ni.windowDimensions,
		ni.windowStrides,
		ni.paddings,
	)
}

// backendSelectAndScatterMax is a Graph wrapper for the backend.Builder.SelectAndScatterMax method.
func backendSelectAndScatterMax(operand *Node, source *Node, windowDimensions []int, windowStrides []int, paddings [][2]int) (
	node *Node) {
	inputNodes := []*Node{operand, source}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsSelectAndScatterMax{
		operand:          operand,
		source:           source,
		windowDimensions: slices.Clone(windowDimensions),
		windowStrides:    slices.Clone(windowStrides),
		paddings:         slices.Clone(paddings),
	}
	result, err := g.builder.SelectAndScatterMax(operand.outputOps[0], source.outputOps[0], inputs.windowDimensions, inputs.windowStrides, inputs.paddings)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSelectAndScatterMin holds the inputs used for the call to backends.SelectAndScatterMin.
type nodeInputsSelectAndScatterMin struct {
	operand          *Node
	source           *Node
	windowDimensions []int
	windowStrides    []int
	paddings         [][2]int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterMin) Type() NodeType {
	return NodeTypeSelectAndScatterMin
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterMin) String() string {
	return fmt.Sprintf("%s(operand=[#%d], source=[#%d], windowDimensions=%v, windowStrides=%v, paddings=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.source.Id(),
		ni.windowDimensions,
		ni.windowStrides,
		ni.paddings,
	)
}

// backendSelectAndScatterMin is a Graph wrapper for the backend.Builder.SelectAndScatterMin method.
func backendSelectAndScatterMin(operand *Node, source *Node, windowDimensions []int, windowStrides []int, paddings [][2]int) (
	node *Node) {
	inputNodes := []*Node{operand, source}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsSelectAndScatterMin{
		operand:          operand,
		source:           source,
		windowDimensions: slices.Clone(windowDimensions),
		windowStrides:    slices.Clone(windowStrides),
		paddings:         slices.Clone(paddings),
	}
	result, err := g.builder.SelectAndScatterMin(operand.outputOps[0], source.outputOps[0], inputs.windowDimensions, inputs.windowStrides, inputs.paddings)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsShiftLeft holds the inputs used for the call to backends.ShiftLeft.
type nodeInputsShiftLeft struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsShiftLeft) Type() NodeType {
	return NodeTypeShiftLeft
}

// String implements the interface NodeInputs.
func (ni *nodeInputsShiftLeft) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// backendShiftLeft is a Graph wrapper for the backend.Builder.ShiftLeft method.
func backendShiftLeft(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsShiftLeft{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.ShiftLeft(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsShiftRightArithmetic holds the inputs used for the call to backends.ShiftRightArithmetic.
type nodeInputsShiftRightArithmetic struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsShiftRightArithmetic) Type() NodeType {
	return NodeTypeShiftRightArithmetic
}

// String implements the interface NodeInputs.
func (ni *nodeInputsShiftRightArithmetic) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// backendShiftRightArithmetic is a Graph wrapper for the backend.Builder.ShiftRightArithmetic method.
func backendShiftRightArithmetic(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsShiftRightArithmetic{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.ShiftRightArithmetic(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsShiftRightLogical holds the inputs used for the call to backends.ShiftRightLogical.
type nodeInputsShiftRightLogical struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsShiftRightLogical) Type() NodeType {
	return NodeTypeShiftRightLogical
}

// String implements the interface NodeInputs.
func (ni *nodeInputsShiftRightLogical) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// backendShiftRightLogical is a Graph wrapper for the backend.Builder.ShiftRightLogical method.
func backendShiftRightLogical(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsShiftRightLogical{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.ShiftRightLogical(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSign holds the inputs used for the call to backends.Sign.
type nodeInputsSign struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSign) Type() NodeType {
	return NodeTypeSign
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSign) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// backendSign is a Graph wrapper for the backend.Builder.Sign method.
func backendSign(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsSign{
		x: x,
	}
	result, err := g.builder.Sign(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSin holds the inputs used for the call to backends.Sin.
type nodeInputsSin struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSin) Type() NodeType {
	return NodeTypeSin
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSin) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Sin returns the Op that represents the output of the corresponding operation.
func Sin(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsSin{
		x: x,
	}
	result, err := g.builder.Sin(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSlice holds the inputs used for the call to backends.Slice.
type nodeInputsSlice struct {
	x       *Node
	starts  []int
	limits  []int
	strides []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSlice) Type() NodeType {
	return NodeTypeSlice
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSlice) String() string {
	return fmt.Sprintf("%s(x=[#%d], starts=%v, limits=%v, strides=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.starts,
		ni.limits,
		ni.strides,
	)
}

// backendSlice is a Graph wrapper for the backend.Builder.Slice method.
func backendSlice(x *Node, starts []int, limits []int, strides []int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsSlice{
		x:       x,
		starts:  slices.Clone(starts),
		limits:  slices.Clone(limits),
		strides: slices.Clone(strides),
	}
	result, err := g.builder.Slice(x.outputOps[0], inputs.starts, inputs.limits, inputs.strides)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSqrt holds the inputs used for the call to backends.Sqrt.
type nodeInputsSqrt struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSqrt) Type() NodeType {
	return NodeTypeSqrt
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSqrt) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Sqrt returns the Op that represents the output of the corresponding operation.
func Sqrt(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsSqrt{
		x: x,
	}
	result, err := g.builder.Sqrt(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSub holds the inputs used for the call to backends.Sub.
type nodeInputsSub struct {
	lhs *Node
	rhs *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSub) Type() NodeType {
	return NodeTypeSub
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSub) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], rhs=[#%d])",
		ni.Type(),
		ni.lhs.Id(),
		ni.rhs.Id(),
	)
}

// Sub returns the element-wise subtraction of the two values.
// Standard broadcasting rules apply (see documentation).
func Sub(lhs *Node, rhs *Node) (
	node *Node) {
	inputNodes := []*Node{lhs, rhs}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsSub{
		lhs: lhs,
		rhs: rhs,
	}
	result, err := g.builder.Sub(lhs.outputOps[0], rhs.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsTanh holds the inputs used for the call to backends.Tanh.
type nodeInputsTanh struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsTanh) Type() NodeType {
	return NodeTypeTanh
}

// String implements the interface NodeInputs.
func (ni *nodeInputsTanh) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Tanh returns the Op that represents the output of the corresponding operation.
func Tanh(x *Node) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsTanh{
		x: x,
	}
	result, err := g.builder.Tanh(x.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsTranspose holds the inputs used for the call to backends.Transpose.
type nodeInputsTranspose struct {
	x           *Node
	permutation []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsTranspose) Type() NodeType {
	return NodeTypeTranspose
}

// String implements the interface NodeInputs.
func (ni *nodeInputsTranspose) String() string {
	return fmt.Sprintf("%s(x=[#%d], permutation=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.permutation,
	)
}

// backendTranspose is a Graph wrapper for the backend.Builder.Transpose method.
func backendTranspose(x *Node, permutation ...int) (
	node *Node) {
	inputNodes := []*Node{x}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsTranspose{
		x:           x,
		permutation: slices.Clone(permutation),
	}
	result, err := g.builder.Transpose(x.outputOps[0], inputs.permutation...)
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsWhere holds the inputs used for the call to backends.Where.
type nodeInputsWhere struct {
	condition *Node
	onTrue    *Node
	onFalse   *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsWhere) Type() NodeType {
	return NodeTypeWhere
}

// String implements the interface NodeInputs.
func (ni *nodeInputsWhere) String() string {
	return fmt.Sprintf("%s(condition=[#%d], onTrue=[#%d], onFalse=[#%d])",
		ni.Type(),
		ni.condition.Id(),
		ni.onTrue.Id(),
		ni.onFalse.Id(),
	)
}

// backendWhere is a Graph wrapper for the backend.Builder.Where method.
func backendWhere(condition *Node, onTrue *Node, onFalse *Node) (
	node *Node) {
	inputNodes := []*Node{condition, onTrue, onFalse}
	g := validateBuildingGraphFromInputs(inputNodes...)
	inputs := &nodeInputsWhere{
		condition: condition,
		onTrue:    onTrue,
		onFalse:   onFalse,
	}
	result, err := g.builder.Where(condition.outputOps[0], onTrue.outputOps[0], onFalse.outputOps[0])
	if err != nil {
		panic(err)
	}
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{mustNoError(g.builder.OpShape(result))},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}
