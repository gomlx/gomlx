package builderif

// Code generated by internal/cmd/builderif. DO NOT EDIT.

import (
	"github.com/gomlx/gomlx/graph"
	"github.com/pkg/errors"
)

// BuilderFn is the function actually used by the models.Exec object.
// But this method provide a converter from various Builder methods to a BuilderFn, see ConvertToBuilderFn().
type BuilderFn func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node)

type Builder1N interface {
	Build(input0 *graph.Node)
}

type Builder1NOut1N interface {
	Build(input0 *graph.Node) (*graph.Node)
}

type Builder1NOut2N interface {
	Build(input0 *graph.Node) (*graph.Node, *graph.Node)
}

type Builder1NOut3N interface {
	Build(input0 *graph.Node) (*graph.Node, *graph.Node, *graph.Node)
}

type Builder1NOut4N interface {
	Build(input0 *graph.Node) (*graph.Node, *graph.Node, *graph.Node, *graph.Node)
}

type Builder1NOutMany interface {
	Build(input0 *graph.Node) (outputs []*graph.Node)
}

type Builder2N interface {
	Build(input0, input1 *graph.Node)
}

type Builder2NOut1N interface {
	Build(input0, input1 *graph.Node) (*graph.Node)
}

type Builder2NOut2N interface {
	Build(input0, input1 *graph.Node) (*graph.Node, *graph.Node)
}

type Builder2NOut3N interface {
	Build(input0, input1 *graph.Node) (*graph.Node, *graph.Node, *graph.Node)
}

type Builder2NOut4N interface {
	Build(input0, input1 *graph.Node) (*graph.Node, *graph.Node, *graph.Node, *graph.Node)
}

type Builder2NOutMany interface {
	Build(input0, input1 *graph.Node) (outputs []*graph.Node)
}

type Builder3N interface {
	Build(input0, input1, input2 *graph.Node)
}

type Builder3NOut1N interface {
	Build(input0, input1, input2 *graph.Node) (*graph.Node)
}

type Builder3NOut2N interface {
	Build(input0, input1, input2 *graph.Node) (*graph.Node, *graph.Node)
}

type Builder3NOut3N interface {
	Build(input0, input1, input2 *graph.Node) (*graph.Node, *graph.Node, *graph.Node)
}

type Builder3NOut4N interface {
	Build(input0, input1, input2 *graph.Node) (*graph.Node, *graph.Node, *graph.Node, *graph.Node)
}

type Builder3NOutMany interface {
	Build(input0, input1, input2 *graph.Node) (outputs []*graph.Node)
}

type Builder4N interface {
	Build(input0, input1, input2, input3 *graph.Node)
}

type Builder4NOut1N interface {
	Build(input0, input1, input2, input3 *graph.Node) (*graph.Node)
}

type Builder4NOut2N interface {
	Build(input0, input1, input2, input3 *graph.Node) (*graph.Node, *graph.Node)
}

type Builder4NOut3N interface {
	Build(input0, input1, input2, input3 *graph.Node) (*graph.Node, *graph.Node, *graph.Node)
}

type Builder4NOut4N interface {
	Build(input0, input1, input2, input3 *graph.Node) (*graph.Node, *graph.Node, *graph.Node, *graph.Node)
}

type Builder4NOutMany interface {
	Build(input0, input1, input2, input3 *graph.Node) (outputs []*graph.Node)
}

type BuilderMany interface {
	Build(inputs ...*graph.Node)
}

type BuilderManyOut1N interface {
	Build(inputs ...*graph.Node) (*graph.Node)
}

type BuilderManyOut2N interface {
	Build(inputs ...*graph.Node) (*graph.Node, *graph.Node)
}

type BuilderManyOut3N interface {
	Build(inputs ...*graph.Node) (*graph.Node, *graph.Node, *graph.Node)
}

type BuilderManyOut4N interface {
	Build(inputs ...*graph.Node) (*graph.Node, *graph.Node, *graph.Node, *graph.Node)
}

type BuilderManyOutMany interface {
	Build(inputs ...*graph.Node) (outputs []*graph.Node)
}

type BuilderG0N interface {
	Build(g *graph.Graph)
}

type BuilderG0NOut1N interface {
	Build(g *graph.Graph) (*graph.Node)
}

type BuilderG0NOut2N interface {
	Build(g *graph.Graph) (*graph.Node, *graph.Node)
}

type BuilderG0NOut3N interface {
	Build(g *graph.Graph) (*graph.Node, *graph.Node, *graph.Node)
}

type BuilderG0NOut4N interface {
	Build(g *graph.Graph) (*graph.Node, *graph.Node, *graph.Node, *graph.Node)
}

type BuilderG0NOutMany interface {
	Build(g *graph.Graph) (outputs []*graph.Node)
}

type BuilderG1N interface {
	Build(g *graph.Graph, input0 *graph.Node)
}

type BuilderG1NOut1N interface {
	Build(g *graph.Graph, input0 *graph.Node) (*graph.Node)
}

type BuilderG1NOut2N interface {
	Build(g *graph.Graph, input0 *graph.Node) (*graph.Node, *graph.Node)
}

type BuilderG1NOut3N interface {
	Build(g *graph.Graph, input0 *graph.Node) (*graph.Node, *graph.Node, *graph.Node)
}

type BuilderG1NOut4N interface {
	Build(g *graph.Graph, input0 *graph.Node) (*graph.Node, *graph.Node, *graph.Node, *graph.Node)
}

type BuilderG1NOutMany interface {
	Build(g *graph.Graph, input0 *graph.Node) (outputs []*graph.Node)
}

type BuilderG2N interface {
	Build(g *graph.Graph, input0, input1 *graph.Node)
}

type BuilderG2NOut1N interface {
	Build(g *graph.Graph, input0, input1 *graph.Node) (*graph.Node)
}

type BuilderG2NOut2N interface {
	Build(g *graph.Graph, input0, input1 *graph.Node) (*graph.Node, *graph.Node)
}

type BuilderG2NOut3N interface {
	Build(g *graph.Graph, input0, input1 *graph.Node) (*graph.Node, *graph.Node, *graph.Node)
}

type BuilderG2NOut4N interface {
	Build(g *graph.Graph, input0, input1 *graph.Node) (*graph.Node, *graph.Node, *graph.Node, *graph.Node)
}

type BuilderG2NOutMany interface {
	Build(g *graph.Graph, input0, input1 *graph.Node) (outputs []*graph.Node)
}

type BuilderG3N interface {
	Build(g *graph.Graph, input0, input1, input2 *graph.Node)
}

type BuilderG3NOut1N interface {
	Build(g *graph.Graph, input0, input1, input2 *graph.Node) (*graph.Node)
}

type BuilderG3NOut2N interface {
	Build(g *graph.Graph, input0, input1, input2 *graph.Node) (*graph.Node, *graph.Node)
}

type BuilderG3NOut3N interface {
	Build(g *graph.Graph, input0, input1, input2 *graph.Node) (*graph.Node, *graph.Node, *graph.Node)
}

type BuilderG3NOut4N interface {
	Build(g *graph.Graph, input0, input1, input2 *graph.Node) (*graph.Node, *graph.Node, *graph.Node, *graph.Node)
}

type BuilderG3NOutMany interface {
	Build(g *graph.Graph, input0, input1, input2 *graph.Node) (outputs []*graph.Node)
}

type BuilderG4N interface {
	Build(g *graph.Graph, input0, input1, input2, input3 *graph.Node)
}

type BuilderG4NOut1N interface {
	Build(g *graph.Graph, input0, input1, input2, input3 *graph.Node) (*graph.Node)
}

type BuilderG4NOut2N interface {
	Build(g *graph.Graph, input0, input1, input2, input3 *graph.Node) (*graph.Node, *graph.Node)
}

type BuilderG4NOut3N interface {
	Build(g *graph.Graph, input0, input1, input2, input3 *graph.Node) (*graph.Node, *graph.Node, *graph.Node)
}

type BuilderG4NOut4N interface {
	Build(g *graph.Graph, input0, input1, input2, input3 *graph.Node) (*graph.Node, *graph.Node, *graph.Node, *graph.Node)
}

type BuilderG4NOutMany interface {
	Build(g *graph.Graph, input0, input1, input2, input3 *graph.Node) (outputs []*graph.Node)
}

type BuilderGMany interface {
	Build(g *graph.Graph, inputs ...*graph.Node)
}

type BuilderGManyOut1N interface {
	Build(g *graph.Graph, inputs ...*graph.Node) (*graph.Node)
}

type BuilderGManyOut2N interface {
	Build(g *graph.Graph, inputs ...*graph.Node) (*graph.Node, *graph.Node)
}

type BuilderGManyOut3N interface {
	Build(g *graph.Graph, inputs ...*graph.Node) (*graph.Node, *graph.Node, *graph.Node)
}

type BuilderGManyOut4N interface {
	Build(g *graph.Graph, inputs ...*graph.Node) (*graph.Node, *graph.Node, *graph.Node, *graph.Node)
}

type BuilderGManyOutMany interface {
	Build(g *graph.Graph, inputs ...*graph.Node) (outputs []*graph.Node)
}

// ConvertToBuilderFn converts a model object to a BuilderFn, matching the corresponding parameters.
// It also returns the number of inputs and outputs of the underlying Builder.
func ConvertToBuilderFn(builderAny any) (builderFn BuilderFn, numInputs, numOutputs int, err error) {
	if builder, ok := builderAny.(Builder1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 1 {
				panic(errors.Errorf("wrong number of inputs for model, expected 1, got %d", len(inputs)))
			}
			builder.Build(inputs[0])
			return nil
		}, 1, 0, nil
	}

	if builder, ok := builderAny.(Builder1NOut1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 1 {
				panic(errors.Errorf("wrong number of inputs for model, expected 1, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 1)
			outputs[0] = builder.Build(inputs[0])
			return outputs
		}, 1, 1, nil
	}

	if builder, ok := builderAny.(Builder1NOut2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 1 {
				panic(errors.Errorf("wrong number of inputs for model, expected 1, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 2)
			outputs[0], outputs[1] = builder.Build(inputs[0])
			return outputs
		}, 1, 2, nil
	}

	if builder, ok := builderAny.(Builder1NOut3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 1 {
				panic(errors.Errorf("wrong number of inputs for model, expected 1, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 3)
			outputs[0], outputs[1], outputs[2] = builder.Build(inputs[0])
			return outputs
		}, 1, 3, nil
	}

	if builder, ok := builderAny.(Builder1NOut4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 1 {
				panic(errors.Errorf("wrong number of inputs for model, expected 1, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 4)
			outputs[0], outputs[1], outputs[2], outputs[3] = builder.Build(inputs[0])
			return outputs
		}, 1, 4, nil
	}

	if builder, ok := builderAny.(Builder1NOutMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 1 {
				panic(errors.Errorf("wrong number of inputs for model, expected 1, got %d", len(inputs)))
			}
			return builder.Build(inputs[0])
		}, 1, -1, nil
	}

	if builder, ok := builderAny.(Builder2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 2 {
				panic(errors.Errorf("wrong number of inputs for model, expected 2, got %d", len(inputs)))
			}
			builder.Build(inputs[0], inputs[1])
			return nil
		}, 2, 0, nil
	}

	if builder, ok := builderAny.(Builder2NOut1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 2 {
				panic(errors.Errorf("wrong number of inputs for model, expected 2, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 1)
			outputs[0] = builder.Build(inputs[0], inputs[1])
			return outputs
		}, 2, 1, nil
	}

	if builder, ok := builderAny.(Builder2NOut2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 2 {
				panic(errors.Errorf("wrong number of inputs for model, expected 2, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 2)
			outputs[0], outputs[1] = builder.Build(inputs[0], inputs[1])
			return outputs
		}, 2, 2, nil
	}

	if builder, ok := builderAny.(Builder2NOut3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 2 {
				panic(errors.Errorf("wrong number of inputs for model, expected 2, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 3)
			outputs[0], outputs[1], outputs[2] = builder.Build(inputs[0], inputs[1])
			return outputs
		}, 2, 3, nil
	}

	if builder, ok := builderAny.(Builder2NOut4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 2 {
				panic(errors.Errorf("wrong number of inputs for model, expected 2, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 4)
			outputs[0], outputs[1], outputs[2], outputs[3] = builder.Build(inputs[0], inputs[1])
			return outputs
		}, 2, 4, nil
	}

	if builder, ok := builderAny.(Builder2NOutMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 2 {
				panic(errors.Errorf("wrong number of inputs for model, expected 2, got %d", len(inputs)))
			}
			return builder.Build(inputs[0], inputs[1])
		}, 2, -1, nil
	}

	if builder, ok := builderAny.(Builder3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 3 {
				panic(errors.Errorf("wrong number of inputs for model, expected 3, got %d", len(inputs)))
			}
			builder.Build(inputs[0], inputs[1], inputs[2])
			return nil
		}, 3, 0, nil
	}

	if builder, ok := builderAny.(Builder3NOut1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 3 {
				panic(errors.Errorf("wrong number of inputs for model, expected 3, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 1)
			outputs[0] = builder.Build(inputs[0], inputs[1], inputs[2])
			return outputs
		}, 3, 1, nil
	}

	if builder, ok := builderAny.(Builder3NOut2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 3 {
				panic(errors.Errorf("wrong number of inputs for model, expected 3, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 2)
			outputs[0], outputs[1] = builder.Build(inputs[0], inputs[1], inputs[2])
			return outputs
		}, 3, 2, nil
	}

	if builder, ok := builderAny.(Builder3NOut3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 3 {
				panic(errors.Errorf("wrong number of inputs for model, expected 3, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 3)
			outputs[0], outputs[1], outputs[2] = builder.Build(inputs[0], inputs[1], inputs[2])
			return outputs
		}, 3, 3, nil
	}

	if builder, ok := builderAny.(Builder3NOut4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 3 {
				panic(errors.Errorf("wrong number of inputs for model, expected 3, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 4)
			outputs[0], outputs[1], outputs[2], outputs[3] = builder.Build(inputs[0], inputs[1], inputs[2])
			return outputs
		}, 3, 4, nil
	}

	if builder, ok := builderAny.(Builder3NOutMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 3 {
				panic(errors.Errorf("wrong number of inputs for model, expected 3, got %d", len(inputs)))
			}
			return builder.Build(inputs[0], inputs[1], inputs[2])
		}, 3, -1, nil
	}

	if builder, ok := builderAny.(Builder4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 4 {
				panic(errors.Errorf("wrong number of inputs for model, expected 4, got %d", len(inputs)))
			}
			builder.Build(inputs[0], inputs[1], inputs[2], inputs[3])
			return nil
		}, 4, 0, nil
	}

	if builder, ok := builderAny.(Builder4NOut1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 4 {
				panic(errors.Errorf("wrong number of inputs for model, expected 4, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 1)
			outputs[0] = builder.Build(inputs[0], inputs[1], inputs[2], inputs[3])
			return outputs
		}, 4, 1, nil
	}

	if builder, ok := builderAny.(Builder4NOut2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 4 {
				panic(errors.Errorf("wrong number of inputs for model, expected 4, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 2)
			outputs[0], outputs[1] = builder.Build(inputs[0], inputs[1], inputs[2], inputs[3])
			return outputs
		}, 4, 2, nil
	}

	if builder, ok := builderAny.(Builder4NOut3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 4 {
				panic(errors.Errorf("wrong number of inputs for model, expected 4, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 3)
			outputs[0], outputs[1], outputs[2] = builder.Build(inputs[0], inputs[1], inputs[2], inputs[3])
			return outputs
		}, 4, 3, nil
	}

	if builder, ok := builderAny.(Builder4NOut4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 4 {
				panic(errors.Errorf("wrong number of inputs for model, expected 4, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 4)
			outputs[0], outputs[1], outputs[2], outputs[3] = builder.Build(inputs[0], inputs[1], inputs[2], inputs[3])
			return outputs
		}, 4, 4, nil
	}

	if builder, ok := builderAny.(Builder4NOutMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 4 {
				panic(errors.Errorf("wrong number of inputs for model, expected 4, got %d", len(inputs)))
			}
			return builder.Build(inputs[0], inputs[1], inputs[2], inputs[3])
		}, 4, -1, nil
	}

	if builder, ok := builderAny.(BuilderMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			builder.Build(inputs...)
			return nil
		}, -1, 0, nil
	}

	if builder, ok := builderAny.(BuilderManyOut1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			outputs := make([]*graph.Node, 1)
			outputs[0] = builder.Build(inputs...)
			return outputs
		}, -1, 1, nil
	}

	if builder, ok := builderAny.(BuilderManyOut2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			outputs := make([]*graph.Node, 2)
			outputs[0], outputs[1] = builder.Build(inputs...)
			return outputs
		}, -1, 2, nil
	}

	if builder, ok := builderAny.(BuilderManyOut3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			outputs := make([]*graph.Node, 3)
			outputs[0], outputs[1], outputs[2] = builder.Build(inputs...)
			return outputs
		}, -1, 3, nil
	}

	if builder, ok := builderAny.(BuilderManyOut4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			outputs := make([]*graph.Node, 4)
			outputs[0], outputs[1], outputs[2], outputs[3] = builder.Build(inputs...)
			return outputs
		}, -1, 4, nil
	}

	if builder, ok := builderAny.(BuilderManyOutMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			return builder.Build(inputs...)
		}, -1, -1, nil
	}

	if builder, ok := builderAny.(BuilderG0N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 0 {
				panic(errors.Errorf("wrong number of inputs for model, expected 0, got %d", len(inputs)))
			}
			builder.Build(g)
			return nil
		}, 0, 0, nil
	}

	if builder, ok := builderAny.(BuilderG0NOut1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 0 {
				panic(errors.Errorf("wrong number of inputs for model, expected 0, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 1)
			outputs[0] = builder.Build(g)
			return outputs
		}, 0, 1, nil
	}

	if builder, ok := builderAny.(BuilderG0NOut2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 0 {
				panic(errors.Errorf("wrong number of inputs for model, expected 0, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 2)
			outputs[0], outputs[1] = builder.Build(g)
			return outputs
		}, 0, 2, nil
	}

	if builder, ok := builderAny.(BuilderG0NOut3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 0 {
				panic(errors.Errorf("wrong number of inputs for model, expected 0, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 3)
			outputs[0], outputs[1], outputs[2] = builder.Build(g)
			return outputs
		}, 0, 3, nil
	}

	if builder, ok := builderAny.(BuilderG0NOut4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 0 {
				panic(errors.Errorf("wrong number of inputs for model, expected 0, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 4)
			outputs[0], outputs[1], outputs[2], outputs[3] = builder.Build(g)
			return outputs
		}, 0, 4, nil
	}

	if builder, ok := builderAny.(BuilderG0NOutMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 0 {
				panic(errors.Errorf("wrong number of inputs for model, expected 0, got %d", len(inputs)))
			}
			return builder.Build(g)
		}, 0, -1, nil
	}

	if builder, ok := builderAny.(BuilderG1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 1 {
				panic(errors.Errorf("wrong number of inputs for model, expected 1, got %d", len(inputs)))
			}
			builder.Build(g, inputs[0])
			return nil
		}, 1, 0, nil
	}

	if builder, ok := builderAny.(BuilderG1NOut1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 1 {
				panic(errors.Errorf("wrong number of inputs for model, expected 1, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 1)
			outputs[0] = builder.Build(g, inputs[0])
			return outputs
		}, 1, 1, nil
	}

	if builder, ok := builderAny.(BuilderG1NOut2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 1 {
				panic(errors.Errorf("wrong number of inputs for model, expected 1, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 2)
			outputs[0], outputs[1] = builder.Build(g, inputs[0])
			return outputs
		}, 1, 2, nil
	}

	if builder, ok := builderAny.(BuilderG1NOut3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 1 {
				panic(errors.Errorf("wrong number of inputs for model, expected 1, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 3)
			outputs[0], outputs[1], outputs[2] = builder.Build(g, inputs[0])
			return outputs
		}, 1, 3, nil
	}

	if builder, ok := builderAny.(BuilderG1NOut4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 1 {
				panic(errors.Errorf("wrong number of inputs for model, expected 1, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 4)
			outputs[0], outputs[1], outputs[2], outputs[3] = builder.Build(g, inputs[0])
			return outputs
		}, 1, 4, nil
	}

	if builder, ok := builderAny.(BuilderG1NOutMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 1 {
				panic(errors.Errorf("wrong number of inputs for model, expected 1, got %d", len(inputs)))
			}
			return builder.Build(g, inputs[0])
		}, 1, -1, nil
	}

	if builder, ok := builderAny.(BuilderG2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 2 {
				panic(errors.Errorf("wrong number of inputs for model, expected 2, got %d", len(inputs)))
			}
			builder.Build(g, inputs[0], inputs[1])
			return nil
		}, 2, 0, nil
	}

	if builder, ok := builderAny.(BuilderG2NOut1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 2 {
				panic(errors.Errorf("wrong number of inputs for model, expected 2, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 1)
			outputs[0] = builder.Build(g, inputs[0], inputs[1])
			return outputs
		}, 2, 1, nil
	}

	if builder, ok := builderAny.(BuilderG2NOut2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 2 {
				panic(errors.Errorf("wrong number of inputs for model, expected 2, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 2)
			outputs[0], outputs[1] = builder.Build(g, inputs[0], inputs[1])
			return outputs
		}, 2, 2, nil
	}

	if builder, ok := builderAny.(BuilderG2NOut3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 2 {
				panic(errors.Errorf("wrong number of inputs for model, expected 2, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 3)
			outputs[0], outputs[1], outputs[2] = builder.Build(g, inputs[0], inputs[1])
			return outputs
		}, 2, 3, nil
	}

	if builder, ok := builderAny.(BuilderG2NOut4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 2 {
				panic(errors.Errorf("wrong number of inputs for model, expected 2, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 4)
			outputs[0], outputs[1], outputs[2], outputs[3] = builder.Build(g, inputs[0], inputs[1])
			return outputs
		}, 2, 4, nil
	}

	if builder, ok := builderAny.(BuilderG2NOutMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 2 {
				panic(errors.Errorf("wrong number of inputs for model, expected 2, got %d", len(inputs)))
			}
			return builder.Build(g, inputs[0], inputs[1])
		}, 2, -1, nil
	}

	if builder, ok := builderAny.(BuilderG3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 3 {
				panic(errors.Errorf("wrong number of inputs for model, expected 3, got %d", len(inputs)))
			}
			builder.Build(g, inputs[0], inputs[1], inputs[2])
			return nil
		}, 3, 0, nil
	}

	if builder, ok := builderAny.(BuilderG3NOut1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 3 {
				panic(errors.Errorf("wrong number of inputs for model, expected 3, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 1)
			outputs[0] = builder.Build(g, inputs[0], inputs[1], inputs[2])
			return outputs
		}, 3, 1, nil
	}

	if builder, ok := builderAny.(BuilderG3NOut2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 3 {
				panic(errors.Errorf("wrong number of inputs for model, expected 3, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 2)
			outputs[0], outputs[1] = builder.Build(g, inputs[0], inputs[1], inputs[2])
			return outputs
		}, 3, 2, nil
	}

	if builder, ok := builderAny.(BuilderG3NOut3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 3 {
				panic(errors.Errorf("wrong number of inputs for model, expected 3, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 3)
			outputs[0], outputs[1], outputs[2] = builder.Build(g, inputs[0], inputs[1], inputs[2])
			return outputs
		}, 3, 3, nil
	}

	if builder, ok := builderAny.(BuilderG3NOut4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 3 {
				panic(errors.Errorf("wrong number of inputs for model, expected 3, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 4)
			outputs[0], outputs[1], outputs[2], outputs[3] = builder.Build(g, inputs[0], inputs[1], inputs[2])
			return outputs
		}, 3, 4, nil
	}

	if builder, ok := builderAny.(BuilderG3NOutMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 3 {
				panic(errors.Errorf("wrong number of inputs for model, expected 3, got %d", len(inputs)))
			}
			return builder.Build(g, inputs[0], inputs[1], inputs[2])
		}, 3, -1, nil
	}

	if builder, ok := builderAny.(BuilderG4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 4 {
				panic(errors.Errorf("wrong number of inputs for model, expected 4, got %d", len(inputs)))
			}
			builder.Build(g, inputs[0], inputs[1], inputs[2], inputs[3])
			return nil
		}, 4, 0, nil
	}

	if builder, ok := builderAny.(BuilderG4NOut1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 4 {
				panic(errors.Errorf("wrong number of inputs for model, expected 4, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 1)
			outputs[0] = builder.Build(g, inputs[0], inputs[1], inputs[2], inputs[3])
			return outputs
		}, 4, 1, nil
	}

	if builder, ok := builderAny.(BuilderG4NOut2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 4 {
				panic(errors.Errorf("wrong number of inputs for model, expected 4, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 2)
			outputs[0], outputs[1] = builder.Build(g, inputs[0], inputs[1], inputs[2], inputs[3])
			return outputs
		}, 4, 2, nil
	}

	if builder, ok := builderAny.(BuilderG4NOut3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 4 {
				panic(errors.Errorf("wrong number of inputs for model, expected 4, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 3)
			outputs[0], outputs[1], outputs[2] = builder.Build(g, inputs[0], inputs[1], inputs[2], inputs[3])
			return outputs
		}, 4, 3, nil
	}

	if builder, ok := builderAny.(BuilderG4NOut4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 4 {
				panic(errors.Errorf("wrong number of inputs for model, expected 4, got %d", len(inputs)))
			}
			outputs := make([]*graph.Node, 4)
			outputs[0], outputs[1], outputs[2], outputs[3] = builder.Build(g, inputs[0], inputs[1], inputs[2], inputs[3])
			return outputs
		}, 4, 4, nil
	}

	if builder, ok := builderAny.(BuilderG4NOutMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			if len(inputs) != 4 {
				panic(errors.Errorf("wrong number of inputs for model, expected 4, got %d", len(inputs)))
			}
			return builder.Build(g, inputs[0], inputs[1], inputs[2], inputs[3])
		}, 4, -1, nil
	}

	if builder, ok := builderAny.(BuilderGMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			builder.Build(g, inputs...)
			return nil
		}, -1, 0, nil
	}

	if builder, ok := builderAny.(BuilderGManyOut1N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			outputs := make([]*graph.Node, 1)
			outputs[0] = builder.Build(g, inputs...)
			return outputs
		}, -1, 1, nil
	}

	if builder, ok := builderAny.(BuilderGManyOut2N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			outputs := make([]*graph.Node, 2)
			outputs[0], outputs[1] = builder.Build(g, inputs...)
			return outputs
		}, -1, 2, nil
	}

	if builder, ok := builderAny.(BuilderGManyOut3N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			outputs := make([]*graph.Node, 3)
			outputs[0], outputs[1], outputs[2] = builder.Build(g, inputs...)
			return outputs
		}, -1, 3, nil
	}

	if builder, ok := builderAny.(BuilderGManyOut4N); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			outputs := make([]*graph.Node, 4)
			outputs[0], outputs[1], outputs[2], outputs[3] = builder.Build(g, inputs...)
			return outputs
		}, -1, 4, nil
	}

	if builder, ok := builderAny.(BuilderGManyOutMany); ok {
		return func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {
			return builder.Build(g, inputs...)
		}, -1, -1, nil
	}

	return nil, 0, 0, errors.Errorf("model object passed (%!T(MISSING)) doesn't implement any of the valid Build methods signatures supported, see documentation in models.NewExec for details", builderAny)
}

