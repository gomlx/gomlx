// Copyright 2023-2026 The GoMLX Authors. SPDX-License-Identifier: Apache-2.0

package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"

	"github.com/gomlx/gomlx/internal/must"
	"k8s.io/klog/v2"
)

const AltPrefix = "//alt:"

// processLine transforms a single line based on the target tag.
// If the line has a comment like `//alt:tag1|tag2|...` at the start, and any of the tags match
// `targetTag`, the comment is moved to the end, effectively "uncommenting" the code.
// Otherwise, the line is returned as is.
func processLine(line string, targetTag string) string {
	// Check for the presence of alt tag
	idx := strings.Index(line, AltPrefix)
	if idx == -1 {
		return line
	}

	// Find where the tag ends (at the first space, "{" or end of the line)
	tagStart := idx + len(AltPrefix)
	tagEnd := strings.IndexAny(line[tagStart:], " \t{")
	var lineTag string
	var rest string
	var separator string

	if tagEnd == -1 {
		// No separator found - the entire rest is the tag
		lineTag = line[tagStart:]
		rest = ""
	} else {
		lineTag = line[tagStart : tagStart+tagEnd]
		separator = line[tagStart+tagEnd : tagStart+tagEnd+1]
		rest = line[tagStart+tagEnd+1:]
	}

	// Remove the alt tag part from the line
	beforeTag := line[:idx]
	beforeTag = strings.TrimRight(beforeTag, " \t")

	// Combine all parts
	// Split lineTag into multiple tags if pipe separator exists
	tags := strings.SplitSeq(lineTag, "|")
	for tag := range tags {
		if tag == targetTag {
			// Move tag to the end
			if rest == "" && beforeTag == "" {
				return AltPrefix + lineTag + separator
			}
			return strings.TrimSpace(beforeTag+" "+rest) + " " + AltPrefix + lineTag + separator
		}
	}

	// Move tag to the beginning
	combined := strings.TrimSpace(beforeTag + " " + rest)
	if combined == "" {
		return AltPrefix + lineTag + separator
	}
	return AltPrefix + lineTag + separator + " " + combined
}

func main() {
	// 1. Define and parse command-line flags.
	baseFile := flag.String("base", "", "The base Go file to process (e.g., app.go).")
	tagsStr := flag.String("tags", "", "A comma-separated list of tags (e.g., free,pro).")
	flag.Parse()

	if *baseFile == "" || *tagsStr == "" {
		fmt.Println("‚ùå Both -base and -tags flags are required.")
		flag.Usage()
		os.Exit(1)
	}

	// 2. Read the entire base file into memory.
	content, err := os.ReadFile(*baseFile)
	if err != nil {
		klog.Fatalf("üö® Failed to read base file %s: %v", *baseFile, err)
	}
	lines := strings.Split(string(content), "\n")

	// 3. Get information for naming the output files.
	tags := strings.Split(*tagsStr, ",")
	baseFileName := filepath.Base(*baseFile)
	baseName := strings.TrimSuffix(baseFileName, filepath.Ext(baseFileName))
	baseName, _ = strings.CutSuffix(baseName, "_base") // "_base" at the end is replaced by the tags we are generating.

	// 4. Process the file for each specified tag.
	for _, tag := range tags {
		trimmedTag := strings.TrimSpace(tag)
		if trimmedTag == "" {
			continue
		}
		processFileForTag(trimmedTag, baseName, baseFileName, lines)
	}
}

// matchesTag checks if the given lineTag (potentially containing multiple tags separated by "|")
// matches the targetTag.
func matchesTag(lineTag, targetTag string) bool {
	tags := strings.SplitSeq(lineTag, "|")
	for tag := range tags {
		if tag == targetTag {
			return true
		}
	}
	return false
}

func processFileForTag(targetTag string, baseName, sourceFileName string, lines []string) {
	// Create the output file.
	outputFileName := fmt.Sprintf("gen_%s_%s.go", baseName, targetTag)
	outputFileName = path.Join(must.M1(os.Getwd()), outputFileName)
	outFile, err := os.Create(outputFileName)
	if err != nil {
		klog.Fatalf("üö® Failed to create output file %s: %v", outputFileName, err)
		return
	}
	defer outFile.Close()
	writer := bufio.NewWriter(outFile)

	// Write header.
	fmt.Fprint(writer, "// *** DO NOT EDIT ***: File generated by internal/cmd/alternates_generator.\n")
	fmt.Fprintf(writer, "// - Base source file (edit this one): %s\n", sourceFileName)
	fmt.Fprintf(writer, "// - Tag used for this generation: %s\n\n", targetTag)

	// State for block processing
	var (
		inBlock      bool
		blockMatches bool
		blockTags    string
	)

	// Process each line and write to the new file.
	for i, line := range lines {
		// Avoid writing an extra newline if the original file ends with one.
		if i == len(lines)-1 && line == "" {
			continue
		}

		// Check for block markers
		trimmed := strings.TrimSpace(line)

		// Helper to check for strict block markers
		// Returns (isMarker, tags, isStart, isEnd, isBlockCommentV)
		// isBlockCommentV means it uses /* ... */ style (either start or end)
		parseMarker := func(s string) (bool, string, bool, bool, bool) {
			s = strings.TrimSpace(s)
			isStart := false
			isEnd := false
			isBlockComment := false
			var inner string

			// Check styles
			if strings.HasPrefix(s, "//alt:") {
				inner = strings.TrimPrefix(s, "//alt:")
			} else if strings.HasPrefix(s, "/* //alt:") {
				inner = strings.TrimPrefix(s, "/* //alt:")
				isBlockComment = true
			} else if strings.HasPrefix(s, "*/ //alt:") {
				inner = strings.TrimPrefix(s, "*/ //alt:")
				isBlockComment = true
			} else {
				return false, "", false, false, false
			}

			// Check suffix
			if strings.HasSuffix(inner, "{") {
				isStart = true
				inner = strings.TrimSuffix(inner, "{")
			} else if strings.HasSuffix(inner, "}") {
				isEnd = true
				inner = strings.TrimSuffix(inner, "}")
			} else {
				return false, "", false, false, false
			}

			// Validate strictly no spaces in tags
			// The requirement is "lines containing only spaces and //alt:<tags>{",
			// meaning the line content is just the marker.
			if strings.ContainsAny(inner, " \t") {
				return false, "", false, false, false
			}

			return true, inner, isStart, isEnd, isBlockComment
		}

		isMarker, markerTags, isStart, isEnd, _ := parseMarker(trimmed)

		if isMarker {
			if isStart {
				if inBlock {
					klog.Warningf("Line %d: Nested blocks are not fully supported, behavior may be unexpected.", i+1)
				}
				inBlock = true
				blockTags = markerTags
				blockMatches = matchesTag(blockTags, targetTag)

				// Write marker
				if blockMatches {
					fmt.Fprintf(writer, "//alt:%s{\n", blockTags)
				} else {
					fmt.Fprintf(writer, "/* //alt:%s{\n", blockTags)
				}
				continue
			} else if isEnd {
				if inBlock {
					// Check if tags match?
					// Trust structure
					if blockMatches {
						fmt.Fprintf(writer, "//alt:%s}\n", blockTags)
					} else {
						fmt.Fprintf(writer, "*/ //alt:%s}\n", blockTags)
					}

					inBlock = false
					blockMatches = false
					blockTags = ""
					continue
				}
			}
		}

		// Process Content
		// In all cases, we process the line to handle any line-level alternates.
		// If in a disabled block (not matching), it's inside /* ... */ so processed content is just comment text.
		processedLine := processLine(line, targetTag)
		fmt.Fprintln(writer, processedLine)
	}

	if err := writer.Flush(); err != nil {
		klog.Fatalf("üö® Failed to write to %s: %v", outputFileName, err)
	}

	// Run go fmt on the generated file
	cmd := exec.Command("go", "fmt", outputFileName)
	if err := cmd.Run(); err != nil {
		klog.Warningf("Failed to run go fmt on %s: %v", outputFileName, err)
	}
	fmt.Printf("‚úÖ alternates_generator:\tsuccessfully generated %s\n", outputFileName)
}
