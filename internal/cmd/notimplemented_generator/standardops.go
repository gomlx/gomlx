// Copyright 2023-2026 The GoMLX Authors. SPDX-License-Identifier: Apache-2.0

package main

import (
	"os"
	"os/exec"
	"path"
	"slices"
	"strings"
	"text/template"

	"fmt"

	"github.com/gomlx/gomlx/internal/backendparser"
	"github.com/gomlx/gomlx/internal/must"
	"github.com/gomlx/gomlx/pkg/support/sets"
	"k8s.io/klog/v2"
)

const (
	standardOpsInterfaceFile = "gen_standard_ops.go"
)

var (
	// methodsNotGenerated because they are maintained manually.
	methodsNotGenerated = sets.MakeWith(
		"Constant", "Parameter", "Identity", "ReduceWindow",
		"BatchNormForInference", "BatchNormForTraining", "BatchNormGradient",
		"And", "Or", "Xor", "Not", "ReduceAnd", "ReduceOr", "ReduceXor", "ScatterAdd",
		"AllReduce",      // Output is not standard
		"FusedQKVDense",  // Multi-output op, maintained manually
		"Return", "Closure", "Name",
	)

	// methodsExcluded from generating and even from having a NodeType.
	// These are utility methods, not part of building a graph.
	methodsExcluded = sets.MakeWith(
		"Name", "Compile", "OpShape", "Main", "NewFunction",
		"DistributedSPMD", "DistributedAutoSharding", "DeviceAssignment")

	standardOpsTemplate = template.Must(template.New(standardOpsInterfaceFile).Parse(
		`/***** File generated by ./internal/cmd/notimplemented_generator, based on github.com/gomlx/gomlx/backends/. Don't edit it directly. *****/

package notimplemented

import (
	"github.com/gomlx/gomlx/backends"
	"github.com/gomlx/gomlx/pkg/core/shapes"
	"github.com/gomlx/gomlx/pkg/core/dtypes"
)

{{- range .}}
{{- range .Comments}}
{{.}}
{{- end}}
func (f Function) {{.Name}}({{range .Parameters}}{{.Name}} {{.Type}},{{end}}) (backends.Value, error) {
	return nil, f.baseErrFn(backends.OpType{{.Name}})
}
{{end}}
`))
)

// GenerateStandardOpsInterface generates the interface for the various standard ops.
// The rest of the ops are maintained manually.
func GenerateStandardOpsInterface(methods []backendparser.Method) {
	newMethods := make([]backendparser.Method, 0, len(methods))
	for _, method := range methods {
		if methodsExcluded.Has(method.Name) || methodsNotGenerated.Has(method.Name) {
			continue
		}
		if len(method.Outputs) != 2 || method.Outputs[0].Type != "Value" || method.Outputs[1].Type != "error" {
			// Non-conventional op, skipping.
			continue
		}
		for i := range method.Parameters {
			pi := &method.Parameters[i]
			switch pi.Type {
			case "Value":
				pi.Type = "backends.Value"
			case "...Value":
				pi.Type = "...backends.Value"
			case "[]Value":
				pi.Type = "[]backends.Value"
			case "Shape":
				pi.Type = "shapes.Shape"
			case "xla_data.FftType", "FFTType":
				pi.Type = "backends.FFTType"
			case "ConvolveAxesConfig":
				pi.Type = "backends.ConvolveAxesConfig"
			case "...PadAxis":
				pi.Type = "...backends.PadAxis"
			case "ActivationType":
				pi.Type = "backends.ActivationType"
			case "AxesLayout":
				pi.Type = "backends.AxesLayout"
			}
		}
		newMethods = append(newMethods, method)
	}
	methods = newMethods
	slices.SortFunc(methods, func(a, b backendparser.Method) int { return strings.Compare(a.Name, b.Name) })

	fileName := path.Join(must.M1(os.Getwd()), standardOpsInterfaceFile)
	f := must.M1(os.Create(fileName))
	must.M(standardOpsTemplate.Execute(f, methods))
	cmd := exec.Command("go", "fmt", fileName)
	klog.V(1).Infof("\t%s\n", cmd)
	must.M(cmd.Run())
	fmt.Printf("âœ… notimplemented_generator:\tsuccessfully generated %s\n", fileName)
}
