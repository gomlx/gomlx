package main

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path"
	"text/template"

	"github.com/gomlx/gomlx/internal/must"
	"github.com/gomlx/gomlx/pkg/core/dtypes"
	"k8s.io/klog/v2"
)

var (
	// Types that one may want to upcast to float32 during matmul:
	float32UpcastDTypes = []dtypes.DType{
		dtypes.Float16,
		dtypes.BFloat16,
	}
	int32UpcastDTypes = []dtypes.DType{
		dtypes.Int8,
		dtypes.Int16,
	}
	uint32UpcastDTypes = []dtypes.DType{
		dtypes.Uint8,
		dtypes.Uint16,
	}
)

type DTypePair struct {
	InputDType, OutputDType   string
	InputGoType, OutputGoType string
	CastFormat                string
}

func newDTypePair(inputDType, outputDType dtypes.DType) DTypePair {
	pair := DTypePair{
		InputDType:   inputDType.String(),
		OutputDType:  outputDType.String(),
		InputGoType:  inputDType.GoType().String(),
		OutputGoType: outputDType.GoType().String(),
	}
	switch outputDType {
	case dtypes.Complex64:
		pair.CastFormat = "complex(float32(%s), 0)"
	case dtypes.Complex128:
		pair.CastFormat = "complex(%s, 0)"
	case dtypes.Float16:
		pair.CastFormat = "float16.Fromfloat32(float32(%s))"
	case dtypes.BFloat16:
		pair.CastFormat = "bfloat16.FromFloat32(float32(%s))"
	default:
		pair.CastFormat = pair.OutputGoType + "(%s)"
	}
	return pair
}

var (
	DataPairs []DTypePair
)

func main() {
	klog.InitFlags(nil)
	flag.Parse()

	// Add symmetric data pairs: same input/output dtypes
	for dtypeIdx, included := range dtypes.SupportedDTypes {
		if !included {
			continue
		}
		dtype := dtypes.DType(dtypeIdx)
		if dtype == dtypes.Bool {
			// No bool support.
			continue
		}
		DataPairs = append(DataPairs, newDTypePair(dtype, dtype))
	}
	for _, inputDType := range float32UpcastDTypes {
		DataPairs = append(DataPairs, newDTypePair(inputDType, dtypes.Float32))
	}
	for _, inputDType := range int32UpcastDTypes {
		DataPairs = append(DataPairs, newDTypePair(inputDType, dtypes.Int32))
	}
	for _, inputDType := range uint32UpcastDTypes {
		DataPairs = append(DataPairs, newDTypePair(inputDType, dtypes.Uint32))
	}

	fileName := "gen_packgemm.go"
	templateName := "gen_packgemm"
	registerTemplate := template.Must(
		template.
			New(templateName).
			Funcs(template.FuncMap{
				"cast": func(format string, value string) string {
					return fmt.Sprintf(format, value)
				},
			}).
			Parse(`/***** File generated by ./internal/cmd/packgemm_generator. Don't edit it directly. *****/

package packgemm

import (
	"github.com/gomlx/gomlx/pkg/core/dtypes/bfloat16"
	"github.com/gomlx/gomlx/pkg/core/dtypes"
	"github.com/pkg/errors"
	"github.com/x448/float16"
)

// GEMMDynamic dispatches the GEMM function for the given dtypes.
// It is a dynamic switch around GEMM[TInput, TOutput].
// 
// The lhsFlat, rhsFlat and outputFlat parameters must be slices of the corresponding DType.
// The buffAllocAnyFn must yield a slice of the configured input DType, but cast as "any".
func GEMMDynamic(inputDType, outputDType dtypes.DType,
	alpha, beta float64, lhsFlat, rhsFlat any, batchSize,
	lhsCrossSize, rhsCrossSize, contractingSize int, outputFlat any,
	bufAllocAnyFn BufAllocAnyFn, bufReleaseFn BufReleaseFn, starter GoroutineStarter) error {

	pair := DTypePair{Input: inputDType, Output: outputDType}
	switch pair {
{{- range .}}
	case DTypePair{Input: dtypes.{{.InputDType}}, Output: dtypes.{{.OutputDType}}}:
		bufAllocFn := func(size int) (ref any, data []{{.InputGoType}}) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]{{.InputGoType}})
		}
		return GEMM({{cast .CastFormat "alpha"}}, {{cast .CastFormat "beta"}}, 
			lhsFlat.([]{{.InputGoType}}), rhsFlat.([]{{.InputGoType}}), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]{{.OutputGoType}}),
			bufAllocFn, bufReleaseFn, starter)
{{- end}}
	default:
		return errors.Errorf("Input/Output dtypes %s%s not configured in GEMM functions dispatcher",
			inputDType, outputDType)
	}
}

`))
	fullPath := path.Join(must.M1(os.Getwd()), fileName)
	f := must.M1(os.Create(fullPath))
	must.M(registerTemplate.Execute(f, DataPairs))
	must.M(f.Close())

	cmd := exec.Command("gofmt", "-w", fullPath)
	klog.V(1).Infof("\t%s\n", cmd)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	must.M(cmd.Run())
	fmt.Printf("âœ… packgemm_dispatcher:  \tsuccessfully generated %s\n", fullPath)
}
