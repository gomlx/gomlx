package main

import (
	"fmt"
	"iter"
	"os"

	"github.com/gomlx/exceptions"
	"github.com/gomlx/gomlx/internal/must"
)

const outputFile = "gen_builder_interfaces.go"

type config struct {
	hasGraph              bool
	numInputs, numOutputs int
}

func iterConfig() iter.Seq2[int, config] {
	return func(yield func(int, config) bool) {
		var count int
		for _, hasGraph := range []bool{false, true} {
			for _, numInputs := range []int{0, 1, 2, 3, 4, -1} {
				if !hasGraph && numInputs == 0 {
					continue
				}
				for _, numOutputs := range []int{0, 1, 2, 3, 4, -1} {
					if !yield(count, config{hasGraph, numInputs, numOutputs}) {
						return
					}
					count++
				}
			}
		}
	}
}

func main() {
	f := must.M1(os.Create(outputFile))
	defer func() { must.M(f.Close()) }()

	w := func(format string, args ...any) {
		_, err := fmt.Fprintf(f, format, args...)
		if err != nil {
			exceptions.Panicf("Failed to write to stdout: %v", err)
		}
	}

	w("package builderif\n\n")
	w("// Code generated by internal/cmd/builderif. DO NOT EDIT.\n\n")
	w("import (\n")
	w("\t\"github.com/gomlx/gomlx/graph\"\n")
	w("\t\"github.com/pkg/errors\"\n")
	w(")\n\n")

	w("// BuilderFn is the function actually used by the models.Exec object.\n")
	w("// But this method provide a converter from various Builder methods to a BuilderFn, see ConvertToBuilderFn().\n")
	w("type BuilderFn func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node)\n\n")

	// A negative value of numInputs or numOutputs mean "many".
	wName := func(c config) {
		w("Builder")
		if c.hasGraph {
			w("G")
		}
		if c.numInputs < 0 {
			w("Many")
		} else {
			w("%dN", c.numInputs)
		}
		if c.numOutputs != 0 {
			w("Out")
			if c.numOutputs < 0 {
				w("Many")
			} else {
				w("%dN", c.numOutputs)
			}
		}
	}

	wInterface := func(c config) {
		w("type ")
		wName(c)

		w(" interface {\n\tBuild(")
		if c.hasGraph {
			w("g *graph.Graph")
			if c.numInputs != 0 {
				w(", ")
			}
		}
		if c.numInputs < 0 {
			w("inputs ...*graph.Node")
		} else if c.numInputs > 0 {
			for i := range c.numInputs {
				if i > 0 {
					w(", ")
				}
				w("input%d", i)
			}
			w(" *graph.Node")
		}
		w(")")
		if c.numOutputs != 0 {
			w(" (")
			if c.numOutputs != 0 {
				if c.numOutputs < 0 {
					w("outputs []*graph.Node")
				} else {
					for i := range c.numOutputs {
						if i > 0 {
							w(", ")
						}
						w("*graph.Node")
					}
				}
			}
			w(")")
		}
		w("\n}\n\n")
	}

	// Write individual interfaces.
	for _, c := range iterConfig() {
		wInterface(c)
	}

	// wInvocation writes the invocation of the builder object, given g, inputs and outputs parameters.
	wInvocation := func(indent string, c config) {

		// Checks the number of inputs passed.
		if c.numInputs >= 0 {
			w("%sif len(inputs) != %d {\n", indent, c.numInputs)
			w("%s\tpanic(errors.Errorf(\"wrong number of inputs for model, expected %d, got %%d\", len(inputs)))\n", indent, c.numInputs)
			w("%s}\n", indent)
		}

		// Assign results to outputs.
		w("%s", indent)
		if c.numOutputs == -1 {
			w("return ")
		} else if c.numOutputs > 0 {
			w("outputs := make([]*graph.Node, %d)\n%s", c.numOutputs, indent)
			for i := range c.numOutputs {
				if i > 0 {
					w(", ")
				}
				w("outputs[%d]", i)
			}
			w(" = ")
		}

		// Write invocation.
		w("builder.Build(")
		if c.hasGraph {
			w("g")
			if c.numInputs != 0 {
				w(", ")
			}
		}
		if c.numInputs < 0 {
			w("inputs...")
		} else if c.numInputs > 0 {
			for i := range c.numInputs {
				if i > 0 {
					w(", ")
				}
				w("inputs[%d]", i)
			}
		}
		w(")")

		// Write return.
		if c.numOutputs == 0 {
			// No outputs.
			w("\n%sreturn nil", indent)
		} else if c.numOutputs > 0 {
			w("\n%sreturn outputs", indent)
		}
		w("\n")
	}

	// Write converter of a model to a generic
	w("// ConvertToBuilderFn converts a model object to a BuilderFn, matching the corresponding parameters.\n")
	w("func ConvertToBuilderFn(builderAny any) (BuilderFn, error) {\n")
	for _, c := range iterConfig() {
		w("\tif builder, ok := builderAny.(")
		wName(c)
		w("); ok {\n")
		w("\t\treturn func (g *graph.Graph, inputs []*graph.Node) ([]*graph.Node) {\n")
		wInvocation("\t\t\t", c)
		w("\t\t}, nil\n")
		w("\t}\n\n")
	}
	w("\treturn nil, errors.Errorf(\"model object passed (%T) doesn't implement any of the valid Build methods signatures supported, see documentation in models.NewExec for details\", builderAny)\n}\n\n")
}
