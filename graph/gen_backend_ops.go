/***** File generated by ./cmd/graphs_codegen, based on backends.Builder interface. Don't edit it directly. *****/

package graph

import (
	"fmt"
	"github.com/gomlx/gomlx/backends"
	"github.com/gomlx/gomlx/types/shapes"
	"github.com/gomlx/gomlx/types/xslices"
	"github.com/gomlx/gopjrt/dtypes"
	"slices"
	"strings"
)

type NodeType int

const (
	NodeTypeInvalid NodeType = iota
	NodeTypeSplitNode
	NodeTypeAbs
	NodeTypeAdd
	NodeTypeAnd
	NodeTypeArgMinMax
	NodeTypeBatchNormForInference
	NodeTypeBatchNormForTraining
	NodeTypeBatchNormGradient
	NodeTypeBroadcast
	NodeTypeBroadcastInDim
	NodeTypeCeil
	NodeTypeClz
	NodeTypeComplex
	NodeTypeConcatenate
	NodeTypeConj
	NodeTypeConstant
	NodeTypeConvGeneralDilated
	NodeTypeConvertDType
	NodeTypeCos
	NodeTypeDiv
	NodeTypeDot
	NodeTypeDotGeneral
	NodeTypeEqual
	NodeTypeEqualTotalOrder
	NodeTypeExp
	NodeTypeExpm1
	NodeTypeFFT
	NodeTypeFloor
	NodeTypeGather
	NodeTypeGreaterOrEqual
	NodeTypeGreaterOrEqualTotalOrder
	NodeTypeGreaterThan
	NodeTypeGreaterThanTotalOrder
	NodeTypeIdentity
	NodeTypeImag
	NodeTypeIota
	NodeTypeLessOrEqual
	NodeTypeLessOrEqualTotalOrder
	NodeTypeLessThan
	NodeTypeLessThanTotalOrder
	NodeTypeLog
	NodeTypeLog1p
	NodeTypeLogicalNot
	NodeTypeLogistic
	NodeTypeMax
	NodeTypeMin
	NodeTypeMul
	NodeTypeNeg
	NodeTypeNotEqual
	NodeTypeNotEqualTotalOrder
	NodeTypeOr
	NodeTypePad
	NodeTypeParameter
	NodeTypePow
	NodeTypeReal
	NodeTypeReduceMax
	NodeTypeReduceMin
	NodeTypeReduceProduct
	NodeTypeReduceSum
	NodeTypeReduceWindow
	NodeTypeRem
	NodeTypeReshape
	NodeTypeReverse
	NodeTypeRngBitGenerator
	NodeTypeRound
	NodeTypeRsqrt
	NodeTypeScatterAdd
	NodeTypeScatterMax
	NodeTypeScatterMin
	NodeTypeSelectAndScatterMax
	NodeTypeSelectAndScatterMin
	NodeTypeSelectAndScatterSum
	NodeTypeSign
	NodeTypeSin
	NodeTypeSlice
	NodeTypeSqrt
	NodeTypeSub
	NodeTypeTanh
	NodeTypeTranspose
	NodeTypeWhere
	NodeTypeXor
)

// nodeInputsAbs holds the inputs used for the call to backends.Abs.
type nodeInputsAbs struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsAbs) Type() NodeType {
	return NodeTypeAbs
}

// String implements the interface NodeInputs.
func (ni *nodeInputsAbs) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Abs returns the Op that represents the output of the corresponding operation.
func Abs(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsAbs{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Abs(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsAdd holds the inputs used for the call to backends.Add.
type nodeInputsAdd struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsAdd) Type() NodeType {
	return NodeTypeAdd
}

// String implements the interface NodeInputs.
func (ni *nodeInputsAdd) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Add returns the element-wise sum of the two values.
// Standard broadcasting rules apply (see documentation).
// The op is created on the same XlaBuilder as used for x0 and x1.
func Add(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsAdd{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Add(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsAnd holds the inputs used for the call to backends.And.
type nodeInputsAnd struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsAnd) Type() NodeType {
	return NodeTypeAnd
}

// String implements the interface NodeInputs.
func (ni *nodeInputsAnd) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// And returns the element-wise logic "and" operator.
// The op is created on the same XlaBuilder as used for x0 and x1.
func And(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsAnd{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.And(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsArgMinMax holds the inputs used for the call to backends.ArgMinMax.
type nodeInputsArgMinMax struct {
	x           *Node
	axis        int
	outputDType dtypes.DType
	isMin       bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsArgMinMax) Type() NodeType {
	return NodeTypeArgMinMax
}

// String implements the interface NodeInputs.
func (ni *nodeInputsArgMinMax) String() string {
	return fmt.Sprintf("%s(x=[#%d], axis=%v, outputDType=%v, isMin=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axis,
		ni.outputDType,
		ni.isMin,
	)
}

// backendArgMinMax is a Graph wrapper for the backend.Builder.ArgMinMax method.
func backendArgMinMax(x *Node, axis int, outputDType dtypes.DType, isMin bool) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsArgMinMax{
		x:           x,
		axis:        axis,
		outputDType: outputDType,
		isMin:       isMin,
	}
	inputNodes := []*Node{x}
	result := g.builder.ArgMinMax(x.outputOps[0], inputs.axis, inputs.outputDType, inputs.isMin)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsBatchNormForInference holds the inputs used for the call to backends.BatchNormForInference.
type nodeInputsBatchNormForInference struct {
	operand  *Node
	scale    *Node
	offset   *Node
	mean     *Node
	variance *Node
	epsilon  float32
	axis     int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBatchNormForInference) Type() NodeType {
	return NodeTypeBatchNormForInference
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBatchNormForInference) String() string {
	return fmt.Sprintf("%s(operand=[#%d], scale=[#%d], offset=[#%d], mean=[#%d], variance=[#%d], epsilon=%v, axis=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.scale.Id(),
		ni.offset.Id(),
		ni.mean.Id(),
		ni.variance.Id(),
		ni.epsilon,
		ni.axis,
	)
}

// backendBatchNormForInference is a Graph wrapper for the backend.Builder.BatchNormForInference method.
func backendBatchNormForInference(operand *Node, scale *Node, offset *Node, mean *Node, variance *Node, epsilon float32, axis int) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, scale, offset, mean, variance)
	inputs := &nodeInputsBatchNormForInference{
		operand:  operand,
		scale:    scale,
		offset:   offset,
		mean:     mean,
		variance: variance,
		epsilon:  epsilon,
		axis:     axis,
	}
	inputNodes := []*Node{operand, scale, offset, mean, variance}
	result := g.builder.BatchNormForInference(operand.outputOps[0], scale.outputOps[0], offset.outputOps[0], mean.outputOps[0], variance.outputOps[0], inputs.epsilon, inputs.axis)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsBatchNormForTraining holds the inputs used for the call to backends.BatchNormForTraining.
type nodeInputsBatchNormForTraining struct {
	operand *Node
	scale   *Node
	offset  *Node
	epsilon float32
	axis    int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBatchNormForTraining) Type() NodeType {
	return NodeTypeBatchNormForTraining
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBatchNormForTraining) String() string {
	return fmt.Sprintf("%s(operand=[#%d], scale=[#%d], offset=[#%d], epsilon=%v, axis=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.scale.Id(),
		ni.offset.Id(),
		ni.epsilon,
		ni.axis,
	)
}

// backendBatchNormForTraining is a Graph wrapper for the backend.Builder.BatchNormForTraining method.
func backendBatchNormForTraining(operand *Node, scale *Node, offset *Node, epsilon float32, axis int) (normalized, batchMean, batchVariance *Node) {
	g := validateBuildingGraphFromInputs(operand, scale, offset)
	inputs := &nodeInputsBatchNormForTraining{
		operand: operand,
		scale:   scale,
		offset:  offset,
		epsilon: epsilon,
		axis:    axis,
	}
	inputNodes := []*Node{operand, scale, offset}
	v0, v1, v2 := g.builder.BatchNormForTraining(operand.outputOps[0], scale.outputOps[0], offset.outputOps[0], inputs.epsilon, inputs.axis)
	node := &Node{
		outputOps:    []backends.Op{v0, v1, v2},
		outputShapes: []shapes.Shape{g.builder.OpShape(v0), g.builder.OpShape(v1), g.builder.OpShape(v2)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	splitNodes := splitNode(node)
	normalized, batchMean, batchVariance = splitNodes[0], splitNodes[1], splitNodes[2]
	return
}

// nodeInputsBatchNormGradient holds the inputs used for the call to backends.BatchNormGradient.
type nodeInputsBatchNormGradient struct {
	operand    *Node
	scale      *Node
	mean       *Node
	variance   *Node
	gradOutput *Node
	epsilon    float32
	axis       int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBatchNormGradient) Type() NodeType {
	return NodeTypeBatchNormGradient
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBatchNormGradient) String() string {
	return fmt.Sprintf("%s(operand=[#%d], scale=[#%d], mean=[#%d], variance=[#%d], gradOutput=[#%d], epsilon=%v, axis=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.scale.Id(),
		ni.mean.Id(),
		ni.variance.Id(),
		ni.gradOutput.Id(),
		ni.epsilon,
		ni.axis,
	)
}

// backendBatchNormGradient is a Graph wrapper for the backend.Builder.BatchNormGradient method.
func backendBatchNormGradient(operand *Node, scale *Node, mean *Node, variance *Node, gradOutput *Node, epsilon float32, axis int) (gradOperand, gradScale, gradOffset *Node) {
	g := validateBuildingGraphFromInputs(operand, scale, mean, variance, gradOutput)
	inputs := &nodeInputsBatchNormGradient{
		operand:    operand,
		scale:      scale,
		mean:       mean,
		variance:   variance,
		gradOutput: gradOutput,
		epsilon:    epsilon,
		axis:       axis,
	}
	inputNodes := []*Node{operand, scale, mean, variance, gradOutput}
	v0, v1, v2 := g.builder.BatchNormGradient(operand.outputOps[0], scale.outputOps[0], mean.outputOps[0], variance.outputOps[0], gradOutput.outputOps[0], inputs.epsilon, inputs.axis)
	node := &Node{
		outputOps:    []backends.Op{v0, v1, v2},
		outputShapes: []shapes.Shape{g.builder.OpShape(v0), g.builder.OpShape(v1), g.builder.OpShape(v2)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	splitNodes := splitNode(node)
	gradOperand, gradScale, gradOffset = splitNodes[0], splitNodes[1], splitNodes[2]
	return
}

// nodeInputsBroadcast holds the inputs used for the call to backends.Broadcast.
type nodeInputsBroadcast struct {
	x          *Node
	prefixDims []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBroadcast) Type() NodeType {
	return NodeTypeBroadcast
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBroadcast) String() string {
	return fmt.Sprintf("%s(x=[#%d], prefixDims=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.prefixDims,
	)
}

// backendBroadcast is a Graph wrapper for the backend.Builder.Broadcast method.
func backendBroadcast(x *Node, prefixDims ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsBroadcast{
		x:          x,
		prefixDims: slices.Clone(prefixDims),
	}
	inputNodes := []*Node{x}
	result := g.builder.Broadcast(x.outputOps[0], inputs.prefixDims...)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsBroadcastInDim holds the inputs used for the call to backends.BroadcastInDim.
type nodeInputsBroadcastInDim struct {
	x             *Node
	outputShape   shapes.Shape
	broadcastAxes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsBroadcastInDim) Type() NodeType {
	return NodeTypeBroadcastInDim
}

// String implements the interface NodeInputs.
func (ni *nodeInputsBroadcastInDim) String() string {
	return fmt.Sprintf("%s(x=[#%d], outputShape=%v, broadcastAxes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.outputShape,
		ni.broadcastAxes,
	)
}

// backendBroadcastInDim is a Graph wrapper for the backend.Builder.BroadcastInDim method.
func backendBroadcastInDim(x *Node, outputShape shapes.Shape, broadcastAxes []int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsBroadcastInDim{
		x:             x,
		outputShape:   outputShape,
		broadcastAxes: broadcastAxes,
	}
	inputNodes := []*Node{x}
	result := g.builder.BroadcastInDim(x.outputOps[0], inputs.outputShape, inputs.broadcastAxes)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsCeil holds the inputs used for the call to backends.Ceil.
type nodeInputsCeil struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsCeil) Type() NodeType {
	return NodeTypeCeil
}

// String implements the interface NodeInputs.
func (ni *nodeInputsCeil) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Ceil returns the Op that represents the output of the corresponding operation.
func Ceil(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsCeil{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Ceil(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsClz holds the inputs used for the call to backends.Clz.
type nodeInputsClz struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsClz) Type() NodeType {
	return NodeTypeClz
}

// String implements the interface NodeInputs.
func (ni *nodeInputsClz) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Clz returns element-wise the "count leading zeros" bits of input node x -- for integer values.
func Clz(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsClz{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Clz(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsComplex holds the inputs used for the call to backends.Complex.
type nodeInputsComplex struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsComplex) Type() NodeType {
	return NodeTypeComplex
}

// String implements the interface NodeInputs.
func (ni *nodeInputsComplex) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Complex returns the complex number taking x0 as the real part and x1 as the imaginary part.
// The real (x0) and imaginary (x1) must have the same dtype, and they must be either `dtypes.Float32` or
// `dtypes.Float64`.
// The output will be either `shapes.Complex64` or `shapes.Complex128`, depending on x0 and x1 dtypes.
// The shapes of `real` or `imaginary` must be the same, or one must be a scalar, in which case
// the value is broadcast to every other value.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Complex(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsComplex{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Complex(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsConcatenate holds the inputs used for the call to backends.Concatenate.
type nodeInputsConcatenate struct {
	axis     int
	operands []*Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsConcatenate) Type() NodeType {
	return NodeTypeConcatenate
}

// String implements the interface NodeInputs.
func (ni *nodeInputsConcatenate) String() string {
	return fmt.Sprintf("%s(axis=%v, operands=[#%s])",
		ni.Type(),
		ni.axis,
		strings.Join(xslices.Map(ni.operands, func(node *Node) string { return fmt.Sprintf("#%d", node.Id()) }), ", "),
	)
}

// backendConcatenate is a Graph wrapper for the backend.Builder.Concatenate method.
func backendConcatenate(axis int, operands ...*Node) (node *Node) {
	g := validateBuildingGraphFromInputs(operands...)
	inputs := &nodeInputsConcatenate{
		axis:     axis,
		operands: slices.Clone(operands),
	}
	inputNodes := operands
	result := g.builder.Concatenate(inputs.axis, xslices.Map(operands, func(node *Node) backends.Op { return node.outputOps[0] }))
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsConj holds the inputs used for the call to backends.Conj.
type nodeInputsConj struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsConj) Type() NodeType {
	return NodeTypeConj
}

// String implements the interface NodeInputs.
func (ni *nodeInputsConj) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Conj returns the conjugate of a complex number. E.g: Conj(1+3i) = 1-3i
func Conj(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsConj{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Conj(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsConvGeneralDilated holds the inputs used for the call to backends.ConvGeneralDilated.
type nodeInputsConvGeneralDilated struct {
	operand          *Node
	filter           *Node
	axes             backends.ConvolveAxesConfig
	strides          []int
	paddings         [][2]int
	inputDilation    []int
	filterDilation   []int
	filterGroupCount int
	batchGroupCount  int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsConvGeneralDilated) Type() NodeType {
	return NodeTypeConvGeneralDilated
}

// String implements the interface NodeInputs.
func (ni *nodeInputsConvGeneralDilated) String() string {
	return fmt.Sprintf("%s(operand=[#%d], filter=[#%d], axes=%+v, strides=%v, paddings=%v, inputDilation=%v, filterDilation=%v, filterGroupCount=%v, batchGroupCount=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.filter.Id(),
		ni.axes,
		ni.strides,
		ni.paddings,
		ni.inputDilation,
		ni.filterDilation,
		ni.filterGroupCount,
		ni.batchGroupCount,
	)
}

// backendConvGeneralDilated is a Graph wrapper for the backend.Builder.ConvGeneralDilated method.
func backendConvGeneralDilated(operand *Node, filter *Node, axes backends.ConvolveAxesConfig, strides []int, paddings [][2]int, inputDilation []int, filterDilation []int, filterGroupCount int, batchGroupCount int) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, filter)
	inputs := &nodeInputsConvGeneralDilated{
		operand:          operand,
		filter:           filter,
		axes:             axes.Clone(),
		strides:          strides,
		paddings:         paddings,
		inputDilation:    inputDilation,
		filterDilation:   filterDilation,
		filterGroupCount: filterGroupCount,
		batchGroupCount:  batchGroupCount,
	}
	inputNodes := []*Node{operand, filter}
	result := g.builder.ConvGeneralDilated(operand.outputOps[0], filter.outputOps[0], inputs.axes, inputs.strides, inputs.paddings, inputs.inputDilation, inputs.filterDilation, inputs.filterGroupCount, inputs.batchGroupCount)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsConvertDType holds the inputs used for the call to backends.ConvertDType.
type nodeInputsConvertDType struct {
	x     *Node
	dtype dtypes.DType
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsConvertDType) Type() NodeType {
	return NodeTypeConvertDType
}

// String implements the interface NodeInputs.
func (ni *nodeInputsConvertDType) String() string {
	return fmt.Sprintf("%s(x=[#%d], dtype=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.dtype,
	)
}

// ConvertDType of x to dtype.
func ConvertDType(x *Node, dtype dtypes.DType) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsConvertDType{
		x:     x,
		dtype: dtype,
	}
	inputNodes := []*Node{x}
	result := g.builder.ConvertDType(x.outputOps[0], inputs.dtype)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsCos holds the inputs used for the call to backends.Cos.
type nodeInputsCos struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsCos) Type() NodeType {
	return NodeTypeCos
}

// String implements the interface NodeInputs.
func (ni *nodeInputsCos) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Cos returns the Op that represents the output of the corresponding operation.
func Cos(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsCos{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Cos(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsDiv holds the inputs used for the call to backends.Div.
type nodeInputsDiv struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsDiv) Type() NodeType {
	return NodeTypeDiv
}

// String implements the interface NodeInputs.
func (ni *nodeInputsDiv) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Div returns the element-wise subtraction of the two values.
// Standard broadcasting rules apply (see documentation).
// The op is created on the same XlaBuilder as used for x0 and x1.
func Div(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsDiv{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Div(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsDot holds the inputs used for the call to backends.Dot.
type nodeInputsDot struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsDot) Type() NodeType {
	return NodeTypeDot
}

// String implements the interface NodeInputs.
func (ni *nodeInputsDot) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Dot returns the "dot product" operation.
// The exact semantics of this operation depend on the ranks of the operands:
// | Input | Output | Semantics |
// | vector [n] dot vector [n] | scalar | vector dot product |
// | matrix [m x k] dot vector [k] | vector [m]	matrix-vector multiplication |
// | matrix [m x k] dot matrix [k x n] | matrix [m x n] | matrix-matrix multiplication |
// The operation performs sum of products over the second dimension of x0 (or the first if it has rank 1) and
// the first dimension of x1.
// These are the "contracted" dimensions.
// The contracted dimensions of x0 and x1 must be of the same size.
// In practice, it can be used to perform dot products between vectors, vector/matrix multiplications or
// matrix/matrix multiplications.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Dot(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsDot{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Dot(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsDotGeneral holds the inputs used for the call to backends.DotGeneral.
type nodeInputsDotGeneral struct {
	lhs                *Node
	lhsContractingAxes []int
	lhsBatchAxes       []int
	rhs                *Node
	rhsContractingAxes []int
	rhsBatchAxes       []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsDotGeneral) Type() NodeType {
	return NodeTypeDotGeneral
}

// String implements the interface NodeInputs.
func (ni *nodeInputsDotGeneral) String() string {
	return fmt.Sprintf("%s(lhs=[#%d], lhsContractingAxes=%v, lhsBatchAxes=%v, rhs=[#%d], rhsContractingAxes=%v, rhsBatchAxes=%v)",
		ni.Type(),
		ni.lhs.Id(),
		ni.lhsContractingAxes,
		ni.lhsBatchAxes,
		ni.rhs.Id(),
		ni.rhsContractingAxes,
		ni.rhsBatchAxes,
	)
}

// backendDotGeneral is a Graph wrapper for the backend.Builder.DotGeneral method.
func backendDotGeneral(lhs *Node, lhsContractingAxes []int, lhsBatchAxes []int, rhs *Node, rhsContractingAxes []int, rhsBatchAxes []int) (node *Node) {
	g := validateBuildingGraphFromInputs(lhs, rhs)
	inputs := &nodeInputsDotGeneral{
		lhs:                lhs,
		lhsContractingAxes: lhsContractingAxes,
		lhsBatchAxes:       lhsBatchAxes,
		rhs:                rhs,
		rhsContractingAxes: rhsContractingAxes,
		rhsBatchAxes:       rhsBatchAxes,
	}
	inputNodes := []*Node{lhs, rhs}
	result := g.builder.DotGeneral(lhs.outputOps[0], inputs.lhsContractingAxes, inputs.lhsBatchAxes, rhs.outputOps[0], inputs.rhsContractingAxes, inputs.rhsBatchAxes)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsEqual holds the inputs used for the call to backends.EqualAny.
type nodeInputsEqual struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsEqual) Type() NodeType {
	return NodeTypeEqual
}

// String implements the interface NodeInputs.
func (ni *nodeInputsEqual) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Equal performs element-wise equality check, returns boolean results with the same dimensions as input.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Equal(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsEqual{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Equal(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsEqualTotalOrder holds the inputs used for the call to backends.EqualTotalOrder.
type nodeInputsEqualTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsEqualTotalOrder) Type() NodeType {
	return NodeTypeEqualTotalOrder
}

// String implements the interface NodeInputs.
func (ni *nodeInputsEqualTotalOrder) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// EqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func EqualTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsEqualTotalOrder{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.EqualTotalOrder(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsExp holds the inputs used for the call to backends.Exp.
type nodeInputsExp struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsExp) Type() NodeType {
	return NodeTypeExp
}

// String implements the interface NodeInputs.
func (ni *nodeInputsExp) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Exp returns the Op that represents the output of the corresponding operation.
func Exp(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsExp{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Exp(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsExpm1 holds the inputs used for the call to backends.Expm1.
type nodeInputsExpm1 struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsExpm1) Type() NodeType {
	return NodeTypeExpm1
}

// String implements the interface NodeInputs.
func (ni *nodeInputsExpm1) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Expm1 returns the Op that represents the output of the corresponding operation.
func Expm1(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsExpm1{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Expm1(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsFFT holds the inputs used for the call to backends.FFT.
type nodeInputsFFT struct {
	operand   *Node
	fftType   backends.FFTType
	fftLength []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsFFT) Type() NodeType {
	return NodeTypeFFT
}

// String implements the interface NodeInputs.
func (ni *nodeInputsFFT) String() string {
	return fmt.Sprintf("%s(operand=[#%d], fftType=%s, fftLength=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.fftType,
		ni.fftLength,
	)
}

// backendFFT is a Graph wrapper for the backend.Builder.FFT method.
func backendFFT(operand *Node, fftType backends.FFTType, fftLength []int) (node *Node) {
	g := validateBuildingGraphFromInputs(operand)
	inputs := &nodeInputsFFT{
		operand:   operand,
		fftType:   fftType,
		fftLength: fftLength,
	}
	inputNodes := []*Node{operand}
	result := g.builder.FFT(operand.outputOps[0], inputs.fftType, inputs.fftLength)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsFloor holds the inputs used for the call to backends.Floor.
type nodeInputsFloor struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsFloor) Type() NodeType {
	return NodeTypeFloor
}

// String implements the interface NodeInputs.
func (ni *nodeInputsFloor) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Floor returns the Op that represents the output of the corresponding operation.
func Floor(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsFloor{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Floor(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsGather holds the inputs used for the call to backends.Gather.
type nodeInputsGather struct {
	operand            *Node
	startIndices       *Node
	indexVectorAxis    int
	offsetAxes         []int
	collapsedSliceAxes []int
	startIndexMap      []int
	sliceSizes         []int
	indicesAreSorted   bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGather) Type() NodeType {
	return NodeTypeGather
}

// String implements the interface NodeInputs.
func (ni *nodeInputsGather) String() string {
	return fmt.Sprintf("%s(operand=[#%d], startIndices=[#%d], indexVectorAxis=%v, offsetAxes=%v, collapsedSliceAxes=%v, startIndexMap=%v, sliceSizes=%v, indicesAreSorted=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.startIndices.Id(),
		ni.indexVectorAxis,
		ni.offsetAxes,
		ni.collapsedSliceAxes,
		ni.startIndexMap,
		ni.sliceSizes,
		ni.indicesAreSorted,
	)
}

// backendGather is a Graph wrapper for the backend.Builder.Gather method.
func backendGather(operand *Node, startIndices *Node, indexVectorAxis int, offsetAxes []int, collapsedSliceAxes []int, startIndexMap []int, sliceSizes []int, indicesAreSorted bool) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, startIndices)
	inputs := &nodeInputsGather{
		operand:            operand,
		startIndices:       startIndices,
		indexVectorAxis:    indexVectorAxis,
		offsetAxes:         offsetAxes,
		collapsedSliceAxes: collapsedSliceAxes,
		startIndexMap:      startIndexMap,
		sliceSizes:         sliceSizes,
		indicesAreSorted:   indicesAreSorted,
	}
	inputNodes := []*Node{operand, startIndices}
	result := g.builder.Gather(operand.outputOps[0], startIndices.outputOps[0], inputs.indexVectorAxis, inputs.offsetAxes, inputs.collapsedSliceAxes, inputs.startIndexMap, inputs.sliceSizes, inputs.indicesAreSorted)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsGreaterOrEqual holds the inputs used for the call to backends.GreaterOrEqual.
type nodeInputsGreaterOrEqual struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGreaterOrEqual) Type() NodeType {
	return NodeTypeGreaterOrEqual
}

// String implements the interface NodeInputs.
func (ni *nodeInputsGreaterOrEqual) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// GreaterOrEqual performs element-wise comparison, returns boolean results with the same dimensions as input.
// The op is created on the same XlaBuilder as used for x0 and x1.
func GreaterOrEqual(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsGreaterOrEqual{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.GreaterOrEqual(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsGreaterOrEqualTotalOrder holds the inputs used for the call to backends.GreaterOrEqualTotalOrder.
type nodeInputsGreaterOrEqualTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGreaterOrEqualTotalOrder) Type() NodeType {
	return NodeTypeGreaterOrEqualTotalOrder
}

// String implements the interface NodeInputs.
func (ni *nodeInputsGreaterOrEqualTotalOrder) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// GreaterOrEqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func GreaterOrEqualTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsGreaterOrEqualTotalOrder{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.GreaterOrEqualTotalOrder(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsGreaterThan holds the inputs used for the call to backends.GreaterThan.
type nodeInputsGreaterThan struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGreaterThan) Type() NodeType {
	return NodeTypeGreaterThan
}

// String implements the interface NodeInputs.
func (ni *nodeInputsGreaterThan) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// GreaterThan performs element-wise comparison, returns boolean results with the same dimensions as input.
// The op is created on the same XlaBuilder as used for x0 and x1.
func GreaterThan(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsGreaterThan{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.GreaterThan(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsGreaterThanTotalOrder holds the inputs used for the call to backends.GreaterThanTotalOrder.
type nodeInputsGreaterThanTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsGreaterThanTotalOrder) Type() NodeType {
	return NodeTypeGreaterThanTotalOrder
}

// String implements the interface NodeInputs.
func (ni *nodeInputsGreaterThanTotalOrder) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// GreaterThanTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func GreaterThanTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsGreaterThanTotalOrder{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.GreaterThanTotalOrder(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsIdentity holds the inputs used for the call to backends.Identity.
type nodeInputsIdentity struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsIdentity) Type() NodeType {
	return NodeTypeIdentity
}

// String implements the interface NodeInputs.
func (ni *nodeInputsIdentity) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Identity returns an Op whose output is the same as its input.
// It's a no-op that can serve as a place-holder.
func Identity(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsIdentity{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Identity(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsImag holds the inputs used for the call to backends.Imag.
type nodeInputsImag struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsImag) Type() NodeType {
	return NodeTypeImag
}

// String implements the interface NodeInputs.
func (ni *nodeInputsImag) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Imag returns the imaginary part of a complex number. It returns 0 if the x is a float number.
func Imag(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsImag{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Imag(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsIota holds the inputs used for the call to backends.Iota.
type nodeInputsIota struct {
	shape    shapes.Shape
	iotaAxis int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsIota) Type() NodeType {
	return NodeTypeIota
}

// String implements the interface NodeInputs.
func (ni *nodeInputsIota) String() string {
	return fmt.Sprintf("%s(shape=%v, iotaAxis=%v)",
		ni.Type(),
		ni.shape,
		ni.iotaAxis,
	)
}

// backendIota is a Graph wrapper for the backend.Builder.Iota method.
func backendIota(g *Graph, shape shapes.Shape, iotaAxis int) (node *Node) {
	g.AssertBuilding()
	inputs := &nodeInputsIota{
		shape:    shape,
		iotaAxis: iotaAxis,
	}
	result := g.builder.Iota(inputs.shape, inputs.iotaAxis)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
	}
	g.registerNode(node)
	return
}

// nodeInputsLessOrEqual holds the inputs used for the call to backends.LessOrEqual.
type nodeInputsLessOrEqual struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLessOrEqual) Type() NodeType {
	return NodeTypeLessOrEqual
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLessOrEqual) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// LessOrEqual performs element-wise comparison, returns boolean results with the same dimensions as input.
// The op is created on the same XlaBuilder as used for x0 and x1.
func LessOrEqual(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsLessOrEqual{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.LessOrEqual(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLessOrEqualTotalOrder holds the inputs used for the call to backends.LessOrEqualTotalOrder.
type nodeInputsLessOrEqualTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLessOrEqualTotalOrder) Type() NodeType {
	return NodeTypeLessOrEqualTotalOrder
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLessOrEqualTotalOrder) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// LessOrEqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func LessOrEqualTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsLessOrEqualTotalOrder{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.LessOrEqualTotalOrder(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLessThan holds the inputs used for the call to backends.LessThan.
type nodeInputsLessThan struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLessThan) Type() NodeType {
	return NodeTypeLessThan
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLessThan) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// LessThan performs element-wise comparison, returns boolean results with the same dimensions as input.
// The op is created on the same XlaBuilder as used for x0 and x1.
func LessThan(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsLessThan{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.LessThan(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLessThanTotalOrder holds the inputs used for the call to backends.LessThanTotalOrder.
type nodeInputsLessThanTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLessThanTotalOrder) Type() NodeType {
	return NodeTypeLessThanTotalOrder
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLessThanTotalOrder) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// LessThanTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func LessThanTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsLessThanTotalOrder{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.LessThanTotalOrder(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLog holds the inputs used for the call to backends.Log.
type nodeInputsLog struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLog) Type() NodeType {
	return NodeTypeLog
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLog) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Log returns the Op that represents the output of the corresponding operation.
func Log(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsLog{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Log(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLog1p holds the inputs used for the call to backends.Log1p.
type nodeInputsLog1p struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLog1p) Type() NodeType {
	return NodeTypeLog1p
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLog1p) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Log1p returns the expression log(x+1).
func Log1p(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsLog1p{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Log1p(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLogicalNot holds the inputs used for the call to backends.LogicalNot.
type nodeInputsLogicalNot struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLogicalNot) Type() NodeType {
	return NodeTypeLogicalNot
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLogicalNot) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// LogicalNot returns the Op that represents the output of the corresponding operation.
func LogicalNot(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsLogicalNot{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.LogicalNot(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsLogistic holds the inputs used for the call to backends.Logistic.
type nodeInputsLogistic struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsLogistic) Type() NodeType {
	return NodeTypeLogistic
}

// String implements the interface NodeInputs.
func (ni *nodeInputsLogistic) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Logistic returns the element-wise expression 1/(1+exp(-x)). Also known as the Sigmoid function.
func Logistic(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsLogistic{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Logistic(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsMax holds the inputs used for the call to backends.Max.
type nodeInputsMax struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsMax) Type() NodeType {
	return NodeTypeMax
}

// String implements the interface NodeInputs.
func (ni *nodeInputsMax) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Max returns the element-wise highest value among the two.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Max(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsMax{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Max(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsMin holds the inputs used for the call to backends.Min.
type nodeInputsMin struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsMin) Type() NodeType {
	return NodeTypeMin
}

// String implements the interface NodeInputs.
func (ni *nodeInputsMin) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Min returns the element-wise smallest value among the two.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Min(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsMin{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Min(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsMul holds the inputs used for the call to backends.Mul.
type nodeInputsMul struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsMul) Type() NodeType {
	return NodeTypeMul
}

// String implements the interface NodeInputs.
func (ni *nodeInputsMul) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Mul returns the element-wise multiplication of the two values.
// Standard broadcasting rules apply (see documentation).
// The op is created on the same XlaBuilder as used for x0 and x1.
func Mul(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsMul{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Mul(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsNeg holds the inputs used for the call to backends.Neg.
type nodeInputsNeg struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsNeg) Type() NodeType {
	return NodeTypeNeg
}

// String implements the interface NodeInputs.
func (ni *nodeInputsNeg) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Neg returns the Op that represents the output of the corresponding operation.
func Neg(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsNeg{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Neg(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsNotEqual holds the inputs used for the call to backends.NotEqual.
type nodeInputsNotEqual struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsNotEqual) Type() NodeType {
	return NodeTypeNotEqual
}

// String implements the interface NodeInputs.
func (ni *nodeInputsNotEqual) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// NotEqual performs element-wise inequality check, returns boolean results with the same dimensions as input.
// The op is created on the same XlaBuilder as used for x0 and x1.
func NotEqual(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsNotEqual{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.NotEqual(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsNotEqualTotalOrder holds the inputs used for the call to backends.NotEqualTotalOrder.
type nodeInputsNotEqualTotalOrder struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsNotEqualTotalOrder) Type() NodeType {
	return NodeTypeNotEqualTotalOrder
}

// String implements the interface NodeInputs.
func (ni *nodeInputsNotEqualTotalOrder) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// NotEqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func NotEqualTotalOrder(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsNotEqualTotalOrder{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.NotEqualTotalOrder(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsOr holds the inputs used for the call to backends.Or.
type nodeInputsOr struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsOr) Type() NodeType {
	return NodeTypeOr
}

// String implements the interface NodeInputs.
func (ni *nodeInputsOr) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Or returns the element-wise logic "and" operator.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Or(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsOr{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Or(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsPad holds the inputs used for the call to backends.Pad.
type nodeInputsPad struct {
	x          *Node
	fillValue  *Node
	axesConfig []backends.PadAxis
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsPad) Type() NodeType {
	return NodeTypePad
}

// String implements the interface NodeInputs.
func (ni *nodeInputsPad) String() string {
	return fmt.Sprintf("%s(x=[#%d], fillValue=[#%d], axesConfig=%+v)",
		ni.Type(),
		ni.x.Id(),
		ni.fillValue.Id(),
		ni.axesConfig,
	)
}

// Pad injects padding on the start, end or interior (in between each element) of the given operand.
// There must be at most `operand.Rank()` axesConfig values. Missing PadAxis are assumed to be zeros,
// that is, no padding for those axes.
func Pad(x *Node, fillValue *Node, axesConfig ...backends.PadAxis) (node *Node) {
	g := validateBuildingGraphFromInputs(x, fillValue)
	inputs := &nodeInputsPad{
		x:          x,
		fillValue:  fillValue,
		axesConfig: slices.Clone(axesConfig),
	}
	inputNodes := []*Node{x, fillValue}
	result := g.builder.Pad(x.outputOps[0], fillValue.outputOps[0], inputs.axesConfig...)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsPow holds the inputs used for the call to backends.Pow.
type nodeInputsPow struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsPow) Type() NodeType {
	return NodeTypePow
}

// String implements the interface NodeInputs.
func (ni *nodeInputsPow) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Pow returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Pow(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsPow{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Pow(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReal holds the inputs used for the call to backends.Real.
type nodeInputsReal struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReal) Type() NodeType {
	return NodeTypeReal
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReal) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Real return the real part of a complex number. It returns x if the x is a float number.
func Real(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsReal{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Real(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceMax holds the inputs used for the call to backends.ReduceMax.
type nodeInputsReduceMax struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceMax) Type() NodeType {
	return NodeTypeReduceMax
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceMax) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceMax is a Graph wrapper for the backend.Builder.ReduceMax method.
func backendReduceMax(x *Node, axes ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsReduceMax{
		x:    x,
		axes: slices.Clone(axes),
	}
	inputNodes := []*Node{x}
	result := g.builder.ReduceMax(x.outputOps[0], inputs.axes...)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceMin holds the inputs used for the call to backends.ReduceMin.
type nodeInputsReduceMin struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceMin) Type() NodeType {
	return NodeTypeReduceMin
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceMin) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceMin is a Graph wrapper for the backend.Builder.ReduceMin method.
func backendReduceMin(x *Node, axes ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsReduceMin{
		x:    x,
		axes: slices.Clone(axes),
	}
	inputNodes := []*Node{x}
	result := g.builder.ReduceMin(x.outputOps[0], inputs.axes...)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceProduct holds the inputs used for the call to backends.ReduceProduct.
type nodeInputsReduceProduct struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceProduct) Type() NodeType {
	return NodeTypeReduceProduct
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceProduct) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceProduct is a Graph wrapper for the backend.Builder.ReduceProduct method.
func backendReduceProduct(x *Node, axes ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsReduceProduct{
		x:    x,
		axes: slices.Clone(axes),
	}
	inputNodes := []*Node{x}
	result := g.builder.ReduceProduct(x.outputOps[0], inputs.axes...)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceSum holds the inputs used for the call to backends.ReduceSum.
type nodeInputsReduceSum struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceSum) Type() NodeType {
	return NodeTypeReduceSum
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceSum) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReduceSum is a Graph wrapper for the backend.Builder.ReduceSum method.
func backendReduceSum(x *Node, axes ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsReduceSum{
		x:    x,
		axes: slices.Clone(axes),
	}
	inputNodes := []*Node{x}
	result := g.builder.ReduceSum(x.outputOps[0], inputs.axes...)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReduceWindow holds the inputs used for the call to backends.ReduceWindow.
type nodeInputsReduceWindow struct {
	x                *Node
	reductionType    ReduceOpType
	windowDimensions []int
	strides          []int
	baseDilations    []int
	windowDilations  []int
	paddings         [][2]int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReduceWindow) Type() NodeType {
	return NodeTypeReduceWindow
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReduceWindow) String() string {
	return fmt.Sprintf("%s(x=[#%d], reductionType=%v, windowDimensions=%v, strides=%v, baseDilations=%v, windowDilations=%v, paddings=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.reductionType,
		ni.windowDimensions,
		ni.strides,
		ni.baseDilations,
		ni.windowDilations,
		ni.paddings,
	)
}

// backendReduceWindow is a Graph wrapper for the backend.Builder.ReduceWindow method.
func backendReduceWindow(x *Node, reductionType ReduceOpType, windowDimensions []int, strides []int, baseDilations []int, windowDilations []int, paddings [][2]int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsReduceWindow{
		x:                x,
		reductionType:    reductionType,
		windowDimensions: windowDimensions,
		strides:          strides,
		baseDilations:    baseDilations,
		windowDilations:  windowDilations,
		paddings:         paddings,
	}
	inputNodes := []*Node{x}
	result := g.builder.ReduceWindow(x.outputOps[0], inputs.reductionType, inputs.windowDimensions, inputs.strides, inputs.baseDilations, inputs.windowDilations, inputs.paddings)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsRem holds the inputs used for the call to backends.Rem.
type nodeInputsRem struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsRem) Type() NodeType {
	return NodeTypeRem
}

// String implements the interface NodeInputs.
func (ni *nodeInputsRem) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Rem returns the remainder operation, also known as modulo (or Mod for short).
// Notice despite the name XLA implements Mod not IEEE754 Remainder operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Rem(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsRem{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Rem(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReshape holds the inputs used for the call to backends.Reshape.
type nodeInputsReshape struct {
	x          *Node
	dimensions []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReshape) Type() NodeType {
	return NodeTypeReshape
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReshape) String() string {
	return fmt.Sprintf("%s(x=[#%d], dimensions=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.dimensions,
	)
}

// backendReshape is a Graph wrapper for the backend.Builder.Reshape method.
func backendReshape(x *Node, dimensions ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsReshape{
		x:          x,
		dimensions: slices.Clone(dimensions),
	}
	inputNodes := []*Node{x}
	result := g.builder.Reshape(x.outputOps[0], inputs.dimensions...)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsReverse holds the inputs used for the call to backends.Reverse.
type nodeInputsReverse struct {
	x    *Node
	axes []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsReverse) Type() NodeType {
	return NodeTypeReverse
}

// String implements the interface NodeInputs.
func (ni *nodeInputsReverse) String() string {
	return fmt.Sprintf("%s(x=[#%d], axes=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.axes,
	)
}

// backendReverse is a Graph wrapper for the backend.Builder.Reverse method.
func backendReverse(x *Node, axes ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsReverse{
		x:    x,
		axes: slices.Clone(axes),
	}
	inputNodes := []*Node{x}
	result := g.builder.Reverse(x.outputOps[0], inputs.axes...)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsRngBitGenerator holds the inputs used for the call to backends.RngBitGenerator.
type nodeInputsRngBitGenerator struct {
	state *Node
	shape shapes.Shape
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsRngBitGenerator) Type() NodeType {
	return NodeTypeRngBitGenerator
}

// String implements the interface NodeInputs.
func (ni *nodeInputsRngBitGenerator) String() string {
	return fmt.Sprintf("%s(state=[#%d], shape=%v)",
		ni.Type(),
		ni.state.Id(),
		ni.shape,
	)
}

// backendRngBitGenerator is a Graph wrapper for the backend.Builder.RngBitGenerator method.
func backendRngBitGenerator(state *Node, shape shapes.Shape) (newState, values *Node) {
	g := validateBuildingGraphFromInputs(state)
	inputs := &nodeInputsRngBitGenerator{
		state: state,
		shape: shape,
	}
	inputNodes := []*Node{state}
	v0, v1 := g.builder.RngBitGenerator(state.outputOps[0], inputs.shape)
	node := &Node{
		outputOps:    []backends.Op{v0, v1},
		outputShapes: []shapes.Shape{g.builder.OpShape(v0), g.builder.OpShape(v1)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	splitNodes := splitNode(node)
	newState, values = splitNodes[0], splitNodes[1]
	return
}

// nodeInputsRound holds the inputs used for the call to backends.Round.
type nodeInputsRound struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsRound) Type() NodeType {
	return NodeTypeRound
}

// String implements the interface NodeInputs.
func (ni *nodeInputsRound) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Round returns the Op that represents the output of the corresponding operation.
func Round(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsRound{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Round(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsRsqrt holds the inputs used for the call to backends.Rsqrt.
type nodeInputsRsqrt struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsRsqrt) Type() NodeType {
	return NodeTypeRsqrt
}

// String implements the interface NodeInputs.
func (ni *nodeInputsRsqrt) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Rsqrt returns the element-wise reciprocal of square root operation 1/sqrt(x).
func Rsqrt(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsRsqrt{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Rsqrt(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsScatterAdd holds the inputs used for the call to backends.ScatterAdd.
type nodeInputsScatterAdd struct {
	operand                  *Node
	scatterIndices           *Node
	updates                  *Node
	indexVectorAxis          int
	updateWindowAxes         []int
	insertedWindowAxes       []int
	scatterAxesToOperandAxes []int
	indicesAreSorted         bool
	uniqueIndices            bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsScatterAdd) Type() NodeType {
	return NodeTypeScatterAdd
}

// String implements the interface NodeInputs.
func (ni *nodeInputsScatterAdd) String() string {
	return fmt.Sprintf("%s(operand=[#%d], scatterIndices=[#%d], updates=[#%d], indexVectorAxis=%v, updateWindowAxes=%v, insertedWindowAxes=%v, scatterAxesToOperandAxes=%v, indicesAreSorted=%v, uniqueIndices=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.scatterIndices.Id(),
		ni.updates.Id(),
		ni.indexVectorAxis,
		ni.updateWindowAxes,
		ni.insertedWindowAxes,
		ni.scatterAxesToOperandAxes,
		ni.indicesAreSorted,
		ni.uniqueIndices,
	)
}

// backendScatterAdd is a Graph wrapper for the backend.Builder.ScatterAdd method.
func backendScatterAdd(operand *Node, scatterIndices *Node, updates *Node, indexVectorAxis int, updateWindowAxes []int, insertedWindowAxes []int, scatterAxesToOperandAxes []int, indicesAreSorted bool, uniqueIndices bool) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, scatterIndices, updates)
	inputs := &nodeInputsScatterAdd{
		operand:                  operand,
		scatterIndices:           scatterIndices,
		updates:                  updates,
		indexVectorAxis:          indexVectorAxis,
		updateWindowAxes:         updateWindowAxes,
		insertedWindowAxes:       insertedWindowAxes,
		scatterAxesToOperandAxes: scatterAxesToOperandAxes,
		indicesAreSorted:         indicesAreSorted,
		uniqueIndices:            uniqueIndices,
	}
	inputNodes := []*Node{operand, scatterIndices, updates}
	result := g.builder.ScatterAdd(operand.outputOps[0], scatterIndices.outputOps[0], updates.outputOps[0], inputs.indexVectorAxis, inputs.updateWindowAxes, inputs.insertedWindowAxes, inputs.scatterAxesToOperandAxes, inputs.indicesAreSorted, inputs.uniqueIndices)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsScatterMax holds the inputs used for the call to backends.ScatterMax.
type nodeInputsScatterMax struct {
	operand                  *Node
	scatterIndices           *Node
	updates                  *Node
	indexVectorAxis          int
	updateWindowAxes         []int
	insertedWindowAxes       []int
	scatterAxesToOperandAxes []int
	indicesAreSorted         bool
	uniqueIndices            bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsScatterMax) Type() NodeType {
	return NodeTypeScatterMax
}

// String implements the interface NodeInputs.
func (ni *nodeInputsScatterMax) String() string {
	return fmt.Sprintf("%s(operand=[#%d], scatterIndices=[#%d], updates=[#%d], indexVectorAxis=%v, updateWindowAxes=%v, insertedWindowAxes=%v, scatterAxesToOperandAxes=%v, indicesAreSorted=%v, uniqueIndices=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.scatterIndices.Id(),
		ni.updates.Id(),
		ni.indexVectorAxis,
		ni.updateWindowAxes,
		ni.insertedWindowAxes,
		ni.scatterAxesToOperandAxes,
		ni.indicesAreSorted,
		ni.uniqueIndices,
	)
}

// ScatterMax scatter values from updates pointed by scatterIndices to operand, by taking the Max.
func ScatterMax(operand *Node, scatterIndices *Node, updates *Node, indexVectorAxis int, updateWindowAxes []int, insertedWindowAxes []int, scatterAxesToOperandAxes []int, indicesAreSorted bool, uniqueIndices bool) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, scatterIndices, updates)
	inputs := &nodeInputsScatterMax{
		operand:                  operand,
		scatterIndices:           scatterIndices,
		updates:                  updates,
		indexVectorAxis:          indexVectorAxis,
		updateWindowAxes:         updateWindowAxes,
		insertedWindowAxes:       insertedWindowAxes,
		scatterAxesToOperandAxes: scatterAxesToOperandAxes,
		indicesAreSorted:         indicesAreSorted,
		uniqueIndices:            uniqueIndices,
	}
	inputNodes := []*Node{operand, scatterIndices, updates}
	result := g.builder.ScatterMax(operand.outputOps[0], scatterIndices.outputOps[0], updates.outputOps[0], inputs.indexVectorAxis, inputs.updateWindowAxes, inputs.insertedWindowAxes, inputs.scatterAxesToOperandAxes, inputs.indicesAreSorted, inputs.uniqueIndices)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsScatterMin holds the inputs used for the call to backends.ScatterMin.
type nodeInputsScatterMin struct {
	operand                  *Node
	scatterIndices           *Node
	updates                  *Node
	indexVectorAxis          int
	updateWindowAxes         []int
	insertedWindowAxes       []int
	scatterAxesToOperandAxes []int
	indicesAreSorted         bool
	uniqueIndices            bool
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsScatterMin) Type() NodeType {
	return NodeTypeScatterMin
}

// String implements the interface NodeInputs.
func (ni *nodeInputsScatterMin) String() string {
	return fmt.Sprintf("%s(operand=[#%d], scatterIndices=[#%d], updates=[#%d], indexVectorAxis=%v, updateWindowAxes=%v, insertedWindowAxes=%v, scatterAxesToOperandAxes=%v, indicesAreSorted=%v, uniqueIndices=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.scatterIndices.Id(),
		ni.updates.Id(),
		ni.indexVectorAxis,
		ni.updateWindowAxes,
		ni.insertedWindowAxes,
		ni.scatterAxesToOperandAxes,
		ni.indicesAreSorted,
		ni.uniqueIndices,
	)
}

// ScatterMin scatter values from updates pointed by scatterIndices to operand, by taking the Min.
func ScatterMin(operand *Node, scatterIndices *Node, updates *Node, indexVectorAxis int, updateWindowAxes []int, insertedWindowAxes []int, scatterAxesToOperandAxes []int, indicesAreSorted bool, uniqueIndices bool) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, scatterIndices, updates)
	inputs := &nodeInputsScatterMin{
		operand:                  operand,
		scatterIndices:           scatterIndices,
		updates:                  updates,
		indexVectorAxis:          indexVectorAxis,
		updateWindowAxes:         updateWindowAxes,
		insertedWindowAxes:       insertedWindowAxes,
		scatterAxesToOperandAxes: scatterAxesToOperandAxes,
		indicesAreSorted:         indicesAreSorted,
		uniqueIndices:            uniqueIndices,
	}
	inputNodes := []*Node{operand, scatterIndices, updates}
	result := g.builder.ScatterMin(operand.outputOps[0], scatterIndices.outputOps[0], updates.outputOps[0], inputs.indexVectorAxis, inputs.updateWindowAxes, inputs.insertedWindowAxes, inputs.scatterAxesToOperandAxes, inputs.indicesAreSorted, inputs.uniqueIndices)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSelectAndScatterMax holds the inputs used for the call to backends.SelectAndScatterMax.
type nodeInputsSelectAndScatterMax struct {
	operand          *Node
	source           *Node
	windowDimensions []int
	windowStrides    []int
	paddings         [][2]int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterMax) Type() NodeType {
	return NodeTypeSelectAndScatterMax
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterMax) String() string {
	return fmt.Sprintf("%s(operand=[#%d], source=[#%d], windowDimensions=%v, windowStrides=%v, paddings=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.source.Id(),
		ni.windowDimensions,
		ni.windowStrides,
		ni.paddings,
	)
}

// backendSelectAndScatterMax is a Graph wrapper for the backend.Builder.SelectAndScatterMax method.
func backendSelectAndScatterMax(operand *Node, source *Node, windowDimensions []int, windowStrides []int, paddings [][2]int) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, source)
	inputs := &nodeInputsSelectAndScatterMax{
		operand:          operand,
		source:           source,
		windowDimensions: windowDimensions,
		windowStrides:    windowStrides,
		paddings:         paddings,
	}
	inputNodes := []*Node{operand, source}
	result := g.builder.SelectAndScatterMax(operand.outputOps[0], source.outputOps[0], inputs.windowDimensions, inputs.windowStrides, inputs.paddings)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSelectAndScatterMin holds the inputs used for the call to backends.SelectAndScatterMin.
type nodeInputsSelectAndScatterMin struct {
	operand          *Node
	source           *Node
	windowDimensions []int
	windowStrides    []int
	paddings         [][2]int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterMin) Type() NodeType {
	return NodeTypeSelectAndScatterMin
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterMin) String() string {
	return fmt.Sprintf("%s(operand=[#%d], source=[#%d], windowDimensions=%v, windowStrides=%v, paddings=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.source.Id(),
		ni.windowDimensions,
		ni.windowStrides,
		ni.paddings,
	)
}

// backendSelectAndScatterMin is a Graph wrapper for the backend.Builder.SelectAndScatterMin method.
func backendSelectAndScatterMin(operand *Node, source *Node, windowDimensions []int, windowStrides []int, paddings [][2]int) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, source)
	inputs := &nodeInputsSelectAndScatterMin{
		operand:          operand,
		source:           source,
		windowDimensions: windowDimensions,
		windowStrides:    windowStrides,
		paddings:         paddings,
	}
	inputNodes := []*Node{operand, source}
	result := g.builder.SelectAndScatterMin(operand.outputOps[0], source.outputOps[0], inputs.windowDimensions, inputs.windowStrides, inputs.paddings)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSelectAndScatterSum holds the inputs used for the call to backends.SelectAndScatterSum.
type nodeInputsSelectAndScatterSum struct {
	operand          *Node
	source           *Node
	windowDimensions []int
	windowStrides    []int
	paddings         [][2]int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterSum) Type() NodeType {
	return NodeTypeSelectAndScatterSum
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSelectAndScatterSum) String() string {
	return fmt.Sprintf("%s(operand=[#%d], source=[#%d], windowDimensions=%v, windowStrides=%v, paddings=%v)",
		ni.Type(),
		ni.operand.Id(),
		ni.source.Id(),
		ni.windowDimensions,
		ni.windowStrides,
		ni.paddings,
	)
}

// backendSelectAndScatterSum is a Graph wrapper for the backend.Builder.SelectAndScatterSum method.
func backendSelectAndScatterSum(operand *Node, source *Node, windowDimensions []int, windowStrides []int, paddings [][2]int) (node *Node) {
	g := validateBuildingGraphFromInputs(operand, source)
	inputs := &nodeInputsSelectAndScatterSum{
		operand:          operand,
		source:           source,
		windowDimensions: windowDimensions,
		windowStrides:    windowStrides,
		paddings:         paddings,
	}
	inputNodes := []*Node{operand, source}
	result := g.builder.SelectAndScatterSum(operand.outputOps[0], source.outputOps[0], inputs.windowDimensions, inputs.windowStrides, inputs.paddings)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSign holds the inputs used for the call to backends.Sign.
type nodeInputsSign struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSign) Type() NodeType {
	return NodeTypeSign
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSign) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// backendSign is a Graph wrapper for the backend.Builder.Sign method.
func backendSign(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsSign{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Sign(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSin holds the inputs used for the call to backends.Sin.
type nodeInputsSin struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSin) Type() NodeType {
	return NodeTypeSin
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSin) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Sin returns the Op that represents the output of the corresponding operation.
func Sin(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsSin{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Sin(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSlice holds the inputs used for the call to backends.Slice.
type nodeInputsSlice struct {
	x       *Node
	starts  []int
	limits  []int
	strides []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSlice) Type() NodeType {
	return NodeTypeSlice
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSlice) String() string {
	return fmt.Sprintf("%s(x=[#%d], starts=%v, limits=%v, strides=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.starts,
		ni.limits,
		ni.strides,
	)
}

// backendSlice is a Graph wrapper for the backend.Builder.Slice method.
func backendSlice(x *Node, starts []int, limits []int, strides []int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsSlice{
		x:       x,
		starts:  starts,
		limits:  limits,
		strides: strides,
	}
	inputNodes := []*Node{x}
	result := g.builder.Slice(x.outputOps[0], inputs.starts, inputs.limits, inputs.strides)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSqrt holds the inputs used for the call to backends.Sqrt.
type nodeInputsSqrt struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSqrt) Type() NodeType {
	return NodeTypeSqrt
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSqrt) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Sqrt returns the Op that represents the output of the corresponding operation.
func Sqrt(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsSqrt{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Sqrt(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsSub holds the inputs used for the call to backends.Sub.
type nodeInputsSub struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsSub) Type() NodeType {
	return NodeTypeSub
}

// String implements the interface NodeInputs.
func (ni *nodeInputsSub) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Sub returns the element-wise subtraction of the two values.
// Standard broadcasting rules apply (see documentation).
// The op is created on the same XlaBuilder as used for x0 and x1.
func Sub(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsSub{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Sub(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsTanh holds the inputs used for the call to backends.Tanh.
type nodeInputsTanh struct {
	x *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsTanh) Type() NodeType {
	return NodeTypeTanh
}

// String implements the interface NodeInputs.
func (ni *nodeInputsTanh) String() string {
	return fmt.Sprintf("%s(x=[#%d])",
		ni.Type(),
		ni.x.Id(),
	)
}

// Tanh returns the Op that represents the output of the corresponding operation.
func Tanh(x *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsTanh{
		x: x,
	}
	inputNodes := []*Node{x}
	result := g.builder.Tanh(x.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsTranspose holds the inputs used for the call to backends.Transpose.
type nodeInputsTranspose struct {
	x            *Node
	permutations []int
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsTranspose) Type() NodeType {
	return NodeTypeTranspose
}

// String implements the interface NodeInputs.
func (ni *nodeInputsTranspose) String() string {
	return fmt.Sprintf("%s(x=[#%d], permutations=%v)",
		ni.Type(),
		ni.x.Id(),
		ni.permutations,
	)
}

// backendTranspose is a Graph wrapper for the backend.Builder.Transpose method.
func backendTranspose(x *Node, permutations ...int) (node *Node) {
	g := validateBuildingGraphFromInputs(x)
	inputs := &nodeInputsTranspose{
		x:            x,
		permutations: slices.Clone(permutations),
	}
	inputNodes := []*Node{x}
	result := g.builder.Transpose(x.outputOps[0], inputs.permutations...)
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsWhere holds the inputs used for the call to backends.Where.
type nodeInputsWhere struct {
	condition *Node
	onTrue    *Node
	onFalse   *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsWhere) Type() NodeType {
	return NodeTypeWhere
}

// String implements the interface NodeInputs.
func (ni *nodeInputsWhere) String() string {
	return fmt.Sprintf("%s(condition=[#%d], onTrue=[#%d], onFalse=[#%d])",
		ni.Type(),
		ni.condition.Id(),
		ni.onTrue.Id(),
		ni.onFalse.Id(),
	)
}

// backendWhere is a Graph wrapper for the backend.Builder.Where method.
func backendWhere(condition *Node, onTrue *Node, onFalse *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(condition, onTrue, onFalse)
	inputs := &nodeInputsWhere{
		condition: condition,
		onTrue:    onTrue,
		onFalse:   onFalse,
	}
	inputNodes := []*Node{condition, onTrue, onFalse}
	result := g.builder.Where(condition.outputOps[0], onTrue.outputOps[0], onFalse.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}

// nodeInputsXor holds the inputs used for the call to backends.Xor.
type nodeInputsXor struct {
	x0 *Node
	x1 *Node
}

// Type implements the interface NodeInputs.
func (ni *nodeInputsXor) Type() NodeType {
	return NodeTypeXor
}

// String implements the interface NodeInputs.
func (ni *nodeInputsXor) String() string {
	return fmt.Sprintf("%s(x0=[#%d], x1=[#%d])",
		ni.Type(),
		ni.x0.Id(),
		ni.x1.Id(),
	)
}

// Xor returns the element-wise logic "and" operator.
// The op is created on the same XlaBuilder as used for x0 and x1.
func Xor(x0 *Node, x1 *Node) (node *Node) {
	g := validateBuildingGraphFromInputs(x0, x1)
	inputs := &nodeInputsXor{
		x0: x0,
		x1: x1,
	}
	inputNodes := []*Node{x0, x1}
	result := g.builder.Xor(x0.outputOps[0], x1.outputOps[0])
	node = &Node{
		outputOps:    []backends.Op{result},
		outputShapes: []shapes.Shape{g.builder.OpShape(result)},
		graph:        g,
		inputs:       inputs,
		inputNodes:   inputNodes,
	}
	g.registerNode(node)
	return
}
