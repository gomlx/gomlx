// *** DO NOT EDIT ***: File generated by internal/cmd/alternates_generator.
// - Base source file (edit this one): dotgeneral_normalized_alt_base.go
// - Tag used for this generation: bf16

// Copyright 2023-2026 The GoMLX Authors. SPDX-License-Identifier: Apache-2.0

package simplego

import "github.com/gomlx/gomlx/pkg/core/dtypes/bfloat16" //alt:bf16
//alt:f16  import "github.com/x448/float16"

// This file serves as a base version of the `execDotGeneralNormalized*` functions, as well as a template
// for other versions.
//
// The other versions are generated by `internal/cmd/alternates_generator`, where each line is generated
// according to a pre-set selection of tags. Lines marked with " // alt : tag1|tag2 " are included or excluded
// according to the tags. The // alt:

// execNormalizedDotGeneral* family of functions for the "normalized" (but not blocked) dot-general (einsum) of
// buffers -- they need to be normalized first.
//
//alt:base func execNormalizedDotGeneralGeneric[T PODNumericConstraints](
func execNormalizedDotGeneralBFloat16( //alt:bf16
	//alt:f16  func execNormalizedDotGeneralFloat16(
	lhs, rhs, output *Buffer, params *dotGeneralNodeData, batchStartIdx, batchEndIdx int) {
	//alt:base lhsFlat := lhs.flat.([]T)
	//alt:base rhsFlat := rhs.flat.([]T)
	//alt:base outputFlat := output.flat.([]T)
	lhsFlat := lhs.flat.([]bfloat16.BFloat16) //alt:bf16
	rhsFlat := rhs.flat.([]bfloat16.BFloat16) //alt:bf16
	outputFlat := output.flat.([]float32)     //alt:bf16
	//alt:f16  lhsFlat := lhs.flat.([]float16.Float16)
	//alt:f16  rhsFlat := rhs.flat.([]float16.Float16)
	//alt:f16  outputFlat := output.flat.([]float32)

	// Notice we cannot trust lhs.shape and rhs.shape, in case they haven't been transposed or reshaped.
	contractingSize := params.contractingSize
	lhsCrossSize := params.lhsCrossSize
	rhsCrossSize := params.rhsCrossSize

	// Pre-compute strides to avoid repeated calculations
	lhsBatchStride := lhsCrossSize * contractingSize
	rhsBatchStride := rhsCrossSize * contractingSize
	outputBatchStride := lhsCrossSize * rhsCrossSize

	// Cache block sizes - adjust based on typical matrix sizes and CPU cache
	const blockSize = 64 // Tune this based on your typical workload and L1 cache size
	for batchIdx := batchStartIdx; batchIdx < batchEndIdx; batchIdx++ {
		lhsBaseIdx := batchIdx * lhsBatchStride
		rhsBaseIdx := batchIdx * rhsBatchStride
		outputBaseIdx := batchIdx * outputBatchStride

		// Use blocking to improve cache locality
		for outerIdxLhsCross := 0; outerIdxLhsCross < lhsCrossSize; outerIdxLhsCross += blockSize {
			lhsCrossBlockEnd := min(outerIdxLhsCross+blockSize, lhsCrossSize)

			for outerIdxRhsCross := 0; outerIdxRhsCross < rhsCrossSize; outerIdxRhsCross += blockSize {
				rhsCrossBlockEnd := min(outerIdxRhsCross+blockSize, rhsCrossSize)

				for outerIdxContracting := 0; outerIdxContracting < contractingSize; outerIdxContracting += blockSize {
					contractingBlockEnd := min(outerIdxContracting+blockSize, contractingSize)

					// Process the current block
					for idxLhsCross := outerIdxLhsCross; idxLhsCross < lhsCrossBlockEnd; idxLhsCross++ {
						lhsRowStartIdx := lhsBaseIdx + idxLhsCross*contractingSize
						outputRowStartIdx := outputBaseIdx + idxLhsCross*rhsCrossSize

						for idxRhsCross := outerIdxRhsCross; idxRhsCross < rhsCrossBlockEnd; idxRhsCross++ {
							rhsColStartIdx := rhsBaseIdx + idxRhsCross*contractingSize
							sum := outputFlat[outputRowStartIdx+idxRhsCross]

							// Unroll the innermost loop for better vectorization
							idxContracting := outerIdxContracting
							for ; idxContracting+7 < contractingBlockEnd; idxContracting += 8 {
								// if lhsRowStartIdx+idxContracting+7 >= len(lhsFlat) {
								// 	panic(errors.Errorf("Out-of-bounds for lhs: batchIdx=%d, idxLhsCross=%d, idxRhsCross=%d, idxContracting=%d, len(lhsFlat)=%d, lhsFlatIdx=%d",
								// 		batchIdx, idxLhsCross, idxRhsCross, idxContracting, len(lhsFlat), lhsRowStartIdx+idxContracting+7))
								// }
								// if rhsColStartIdx+idxContracting+7 >= len(rhsFlat) {
								// 	panic(errors.Errorf("Out-of-bounds for rhs: batchIdx=%d, idxLhsCross=%d, idxRhsCross=%d, idxContracting=%d, len(rhsFlat)=%d, rhsFlatIdx=%d",
								// 		batchIdx, idxLhsCross, idxRhsCross, idxContracting, len(rhsFlat), rhsColStartIdx+idxContracting+7))
								// }
								//alt:base sum += lhsFlat[lhsRowStartIdx+idxContracting]*rhsFlat[rhsColStartIdx+idxContracting] +
								//alt:base lhsFlat[lhsRowStartIdx+idxContracting+1]*rhsFlat[rhsColStartIdx+idxContracting+1] +
								//alt:base lhsFlat[lhsRowStartIdx+idxContracting+2]*rhsFlat[rhsColStartIdx+idxContracting+2] +
								//alt:base lhsFlat[lhsRowStartIdx+idxContracting+3]*rhsFlat[rhsColStartIdx+idxContracting+3] +
								//alt:base lhsFlat[lhsRowStartIdx+idxContracting+4]*rhsFlat[rhsColStartIdx+idxContracting+4] +
								//alt:base lhsFlat[lhsRowStartIdx+idxContracting+5]*rhsFlat[rhsColStartIdx+idxContracting+5] +
								//alt:base lhsFlat[lhsRowStartIdx+idxContracting+6]*rhsFlat[rhsColStartIdx+idxContracting+6] +
								//alt:base lhsFlat[lhsRowStartIdx+idxContracting+7]*rhsFlat[rhsColStartIdx+idxContracting+7]

								sum += lhsFlat[lhsRowStartIdx+idxContracting].Float32()*rhsFlat[rhsColStartIdx+idxContracting].Float32() + //alt:bf16|f16
									lhsFlat[lhsRowStartIdx+idxContracting+1].Float32()*rhsFlat[rhsColStartIdx+idxContracting+1].Float32() + //alt:bf16|f16
									lhsFlat[lhsRowStartIdx+idxContracting+2].Float32()*rhsFlat[rhsColStartIdx+idxContracting+2].Float32() + //alt:bf16|f16
									lhsFlat[lhsRowStartIdx+idxContracting+3].Float32()*rhsFlat[rhsColStartIdx+idxContracting+3].Float32() + //alt:bf16|f16
									lhsFlat[lhsRowStartIdx+idxContracting+4].Float32()*rhsFlat[rhsColStartIdx+idxContracting+4].Float32() + //alt:bf16|f16
									lhsFlat[lhsRowStartIdx+idxContracting+5].Float32()*rhsFlat[rhsColStartIdx+idxContracting+5].Float32() + //alt:bf16|f16
									lhsFlat[lhsRowStartIdx+idxContracting+6].Float32()*rhsFlat[rhsColStartIdx+idxContracting+6].Float32() + //alt:bf16|f16
									lhsFlat[lhsRowStartIdx+idxContracting+7].Float32()*rhsFlat[rhsColStartIdx+idxContracting+7].Float32() //alt:bf16|f16
							}

							// Handle remaining elements
							for ; idxContracting < contractingBlockEnd; idxContracting++ {
								//alt:base sum += lhsFlat[lhsRowStartIdx+idxContracting] * rhsFlat[rhsColStartIdx+idxContracting]
								sum += lhsFlat[lhsRowStartIdx+idxContracting].Float32() * rhsFlat[rhsColStartIdx+idxContracting].Float32() //alt:bf16|f16
							}

							outputFlat[outputRowStartIdx+idxRhsCross] = sum
						}
					}
				}
			}
		}
	}
}
