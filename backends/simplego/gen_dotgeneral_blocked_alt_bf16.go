// *** DO NOT EDIT ***: File generated by internal/cmd/alternates_generator.
// - Base source file (edit this one): dotgeneral_blocked_alt_base.go
// - Tag used for this generation: bf16

// Copyright 2023-2026 The GoMLX Authors. SPDX-License-Identifier: Apache-2.0

package simplego

//alt:base import (
//alt:base "github.com/gomlx/gomlx/pkg/core/dtypes/bfloat16"
//alt:base "github.com/x448/float16"
//alt:base )
import "github.com/gomlx/gomlx/pkg/core/dtypes/bfloat16" //alt:bf16
//alt:f16  import	"github.com/x448/float16"

// dgCopyOutputBlockToFlat* copies the blocked output to a flat output, removing the padding.
// The base version works for cases where the blockSource and output have the same dtype.
// (This will not be the case for BFloat16/Float16, as the results are stored in float32 by default)
//
// blockedSource shape: [batchSize, lhsCrossBlocks, rhsCrossBlocks, blockDim, blockDim]
// output shape: [batchSize, lhsCrossSize, rhsCrossSize]
//
//alt:base func dgCopyOutputBlockToFlat[T interface {
//alt:base PODNumericConstraints | bfloat16.BFloat16 | float16.Float16
//alt:base }](
func dgCopyOutputBlockToFlatF32ToBF16( //alt:bf16
	//alt:f16  func dgCopyOutputBlockToFlatF32ToF16(

	blockSource, output *Buffer) {
	sourceDims := blockSource.shape.Dimensions
	outputDims := output.shape.Dimensions

	batchSize := sourceDims[0]
	lhsBlockCross := sourceDims[1]
	rhsBlockCross := sourceDims[2]
	blockDim := sourceDims[3] // Same as sourceDims[4]
	lhsCrossSize := outputDims[1]
	rhsCrossSize := outputDims[2]

	// Pre-calculate strides
	outputRhsStride := 1
	outputLhsStride := rhsCrossSize
	outputBatchStride := lhsCrossSize * rhsCrossSize

	sourceBlockSize := blockDim * blockDim
	sourceRhsBlockStride := sourceBlockSize
	sourceLhsBlockStride := rhsBlockCross * sourceBlockSize
	sourceBatchStride := lhsBlockCross * rhsBlockCross * sourceBlockSize

	//alt:base sourceData := blockSource.flat.([]T)
	//alt:base outputData := output.flat.([]T)
	sourceData := blockSource.flat.([]float32)      //alt:bf16|f16
	outputData := output.flat.([]bfloat16.BFloat16) //alt:bf16
	//alt:f16  outputData := output.flat.([]float16.Float16)

	for batch := range batchSize {
		sourceBatchOffset := batch * sourceBatchStride
		outputBatchOffset := batch * outputBatchStride

		for lhsBlock := 0; lhsBlock < lhsBlockCross && lhsBlock*blockDim < lhsCrossSize; lhsBlock++ {
			lhsStart := lhsBlock * blockDim
			lhsEnd := min(lhsStart+blockDim, lhsCrossSize)
			sourceLhsOffset := sourceBatchOffset + lhsBlock*sourceLhsBlockStride
			outputLhsOffset := outputBatchOffset + lhsStart*outputLhsStride

			for rhsBlock := 0; rhsBlock < rhsBlockCross && rhsBlock*blockDim < rhsCrossSize; rhsBlock++ {
				rhsStart := rhsBlock * blockDim
				rhsEnd := min(rhsStart+blockDim, rhsCrossSize)
				sourceBlockOffset := sourceLhsOffset + rhsBlock*sourceRhsBlockStride
				outputBlockOffset := outputLhsOffset + rhsStart*outputRhsStride

				// Copy valid elements from the block
				for i := 0; i < lhsEnd-lhsStart; i++ {
					sourceRowOffset := sourceBlockOffset + i*blockDim
					outputRowOffset := outputBlockOffset + i*outputLhsStride
					//alt:base copy(outputData[outputRowOffset:outputRowOffset+rhsEnd-rhsStart],
					//alt:base sourceData[sourceRowOffset:sourceRowOffset+rhsEnd-rhsStart])
					for blockCol := range rhsEnd - rhsStart { //alt:bf16|f16
						outputData[outputRowOffset+blockCol] = bfloat16.FromFloat32(sourceData[sourceRowOffset+blockCol]) //alt:bf16
						//alt:f16  outputData[outputRowOffset+blockCol] = float16.Fromfloat32(sourceData[sourceRowOffset+blockCol])
					} //alt:bf16|f16

				}
			}
		}
	}
}

// buildDotGeneralKernel* returns a kernel function that does a DotGeneral (matrix multiplication) of the lhs/rhs block
// to the corresponding output buffer block, given the indices of the square blocks.
//
//alt:base func buildDotGeneralKernel[T PODNumericConstraints](
func buildDotGeneralKernelBFloat16( //alt:bf16
	//alt:f16  func buildDotGeneralKernelFloat16(
	lhs, rhs, output *Buffer, blockDim int) kernelFuncType {
	//alt:base lhsFlat := lhs.flat.([]T)
	//alt:base rhsFlat := rhs.flat.([]T)
	//alt:base outputFlat := output.flat.([]T)
	lhsFlat := lhs.flat.([]bfloat16.BFloat16) //alt:bf16
	rhsFlat := rhs.flat.([]bfloat16.BFloat16) //alt:bf16
	//alt:f16  lhsFlat := lhs.flat.([]float16.Float16)
	//alt:f16  rhsFlat := rhs.flat.([]float16.Float16)
	outputFlat := output.flat.([]float32) //alt:bf16|f16

	blockSize := blockDim * blockDim

	return func(lhsBlockIdx, rhsBlockIdx, outputBlockIdx int) {
		baseLhsIdx := lhsBlockIdx * blockSize
		baseRhsIdx := rhsBlockIdx * blockSize
		outputIdx := outputBlockIdx * blockSize
		for range blockDim { // Loop over lhs rows:
			rhsIdx := baseRhsIdx
			// Loop 4 rows at a time.
			for rhsRow := 0; rhsRow < blockDim; rhsRow += 4 { // range blockDim { // loop over rhs rows:
				lhsIdx := baseLhsIdx
				contractingIdx := 0
				sum0 := outputFlat[outputIdx]
				sum1 := outputFlat[outputIdx+1]
				sum2 := outputFlat[outputIdx+2]
				sum3 := outputFlat[outputIdx+3]
				// Loop unrolled 8 at a time.
				for ; contractingIdx+7 < blockDim; contractingIdx += 8 {
					rhsIdx1 := rhsIdx + blockDim
					rhsIdx2 := rhsIdx + 2*blockDim
					rhsIdx3 := rhsIdx + 3*blockDim
					/* //alt:base{
					sum0 += lhsFlat[lhsIdx]*rhsFlat[rhsIdx] +
						lhsFlat[lhsIdx+1]*rhsFlat[rhsIdx+1] +
						lhsFlat[lhsIdx+2]*rhsFlat[rhsIdx+2] +
						lhsFlat[lhsIdx+3]*rhsFlat[rhsIdx+3] +
						lhsFlat[lhsIdx+4]*rhsFlat[rhsIdx+4] +
						lhsFlat[lhsIdx+5]*rhsFlat[rhsIdx+5] +
						lhsFlat[lhsIdx+6]*rhsFlat[rhsIdx+6] +
						lhsFlat[lhsIdx+7]*rhsFlat[rhsIdx+7]
					sum1 += lhsFlat[lhsIdx]*rhsFlat[rhsIdx1] +
						lhsFlat[lhsIdx+1]*rhsFlat[rhsIdx1+1] +
						lhsFlat[lhsIdx+2]*rhsFlat[rhsIdx1+2] +
						lhsFlat[lhsIdx+3]*rhsFlat[rhsIdx1+3] +
						lhsFlat[lhsIdx+4]*rhsFlat[rhsIdx1+4] +
						lhsFlat[lhsIdx+5]*rhsFlat[rhsIdx1+5] +
						lhsFlat[lhsIdx+6]*rhsFlat[rhsIdx1+6] +
						lhsFlat[lhsIdx+7]*rhsFlat[rhsIdx1+7]
					sum2 += lhsFlat[lhsIdx]*rhsFlat[rhsIdx2] +
						lhsFlat[lhsIdx+1]*rhsFlat[rhsIdx2+1] +
						lhsFlat[lhsIdx+2]*rhsFlat[rhsIdx2+2] +
						lhsFlat[lhsIdx+3]*rhsFlat[rhsIdx2+3] +
						lhsFlat[lhsIdx+4]*rhsFlat[rhsIdx2+4] +
						lhsFlat[lhsIdx+5]*rhsFlat[rhsIdx2+5] +
						lhsFlat[lhsIdx+6]*rhsFlat[rhsIdx2+6] +
						lhsFlat[lhsIdx+7]*rhsFlat[rhsIdx2+7]
					sum3 += lhsFlat[lhsIdx]*rhsFlat[rhsIdx3] +
						lhsFlat[lhsIdx+1]*rhsFlat[rhsIdx3+1] +
						lhsFlat[lhsIdx+2]*rhsFlat[rhsIdx3+2] +
						lhsFlat[lhsIdx+3]*rhsFlat[rhsIdx3+3] +
						lhsFlat[lhsIdx+4]*rhsFlat[rhsIdx3+4] +
						lhsFlat[lhsIdx+5]*rhsFlat[rhsIdx3+5] +
						lhsFlat[lhsIdx+6]*rhsFlat[rhsIdx3+6] +
						lhsFlat[lhsIdx+7]*rhsFlat[rhsIdx3+7]
					*/ //alt:base}
					//alt:bf16|f16{
					sum0 += lhsFlat[lhsIdx].Float32()*rhsFlat[rhsIdx].Float32() +
						lhsFlat[lhsIdx+1].Float32()*rhsFlat[rhsIdx+1].Float32() +
						lhsFlat[lhsIdx+2].Float32()*rhsFlat[rhsIdx+2].Float32() +
						lhsFlat[lhsIdx+3].Float32()*rhsFlat[rhsIdx+3].Float32() +
						lhsFlat[lhsIdx+4].Float32()*rhsFlat[rhsIdx+4].Float32() +
						lhsFlat[lhsIdx+5].Float32()*rhsFlat[rhsIdx+5].Float32() +
						lhsFlat[lhsIdx+6].Float32()*rhsFlat[rhsIdx+6].Float32() +
						lhsFlat[lhsIdx+7].Float32()*rhsFlat[rhsIdx+7].Float32()
					sum1 += lhsFlat[lhsIdx].Float32()*rhsFlat[rhsIdx1].Float32() +
						lhsFlat[lhsIdx+1].Float32()*rhsFlat[rhsIdx1+1].Float32() +
						lhsFlat[lhsIdx+2].Float32()*rhsFlat[rhsIdx1+2].Float32() +
						lhsFlat[lhsIdx+3].Float32()*rhsFlat[rhsIdx1+3].Float32() +
						lhsFlat[lhsIdx+4].Float32()*rhsFlat[rhsIdx1+4].Float32() +
						lhsFlat[lhsIdx+5].Float32()*rhsFlat[rhsIdx1+5].Float32() +
						lhsFlat[lhsIdx+6].Float32()*rhsFlat[rhsIdx1+6].Float32() +
						lhsFlat[lhsIdx+7].Float32()*rhsFlat[rhsIdx1+7].Float32()
					sum2 += lhsFlat[lhsIdx].Float32()*rhsFlat[rhsIdx2].Float32() +
						lhsFlat[lhsIdx+1].Float32()*rhsFlat[rhsIdx2+1].Float32() +
						lhsFlat[lhsIdx+2].Float32()*rhsFlat[rhsIdx2+2].Float32() +
						lhsFlat[lhsIdx+3].Float32()*rhsFlat[rhsIdx2+3].Float32() +
						lhsFlat[lhsIdx+4].Float32()*rhsFlat[rhsIdx2+4].Float32() +
						lhsFlat[lhsIdx+5].Float32()*rhsFlat[rhsIdx2+5].Float32() +
						lhsFlat[lhsIdx+6].Float32()*rhsFlat[rhsIdx2+6].Float32() +
						lhsFlat[lhsIdx+7].Float32()*rhsFlat[rhsIdx2+7].Float32()
					sum3 += lhsFlat[lhsIdx].Float32()*rhsFlat[rhsIdx3].Float32() +
						lhsFlat[lhsIdx+1].Float32()*rhsFlat[rhsIdx3+1].Float32() +
						lhsFlat[lhsIdx+2].Float32()*rhsFlat[rhsIdx3+2].Float32() +
						lhsFlat[lhsIdx+3].Float32()*rhsFlat[rhsIdx3+3].Float32() +
						lhsFlat[lhsIdx+4].Float32()*rhsFlat[rhsIdx3+4].Float32() +
						lhsFlat[lhsIdx+5].Float32()*rhsFlat[rhsIdx3+5].Float32() +
						lhsFlat[lhsIdx+6].Float32()*rhsFlat[rhsIdx3+6].Float32() +
						lhsFlat[lhsIdx+7].Float32()*rhsFlat[rhsIdx3+7].Float32()
						//alt:bf16|f16}
					lhsIdx += 8
					rhsIdx += 8
				}

				// Tail loop.
				for ; contractingIdx < blockDim; contractingIdx++ {
					rhsIdx1 := rhsIdx + blockDim
					rhsIdx2 := rhsIdx + 2*blockDim
					rhsIdx3 := rhsIdx + 3*blockDim
					//alt:base sum0 += lhsFlat[lhsIdx] * rhsFlat[rhsIdx]
					//alt:base sum1 += lhsFlat[lhsIdx] * rhsFlat[rhsIdx1]
					//alt:base sum2 += lhsFlat[lhsIdx] * rhsFlat[rhsIdx2]
					//alt:base sum3 += lhsFlat[lhsIdx] * rhsFlat[rhsIdx3]
					sum0 += lhsFlat[lhsIdx].Float32() * rhsFlat[rhsIdx].Float32()  //alt:bf16|f16
					sum1 += lhsFlat[lhsIdx].Float32() * rhsFlat[rhsIdx1].Float32() //alt:bf16|f16
					sum2 += lhsFlat[lhsIdx].Float32() * rhsFlat[rhsIdx2].Float32() //alt:bf16|f16
					sum3 += lhsFlat[lhsIdx].Float32() * rhsFlat[rhsIdx3].Float32() //alt:bf16|f16
					lhsIdx++
					rhsIdx++
				}
				outputFlat[outputIdx] = sum0
				outputFlat[outputIdx+1] = sum1
				outputFlat[outputIdx+2] = sum2
				outputFlat[outputIdx+3] = sum3
				outputIdx += 4

				// We unrolled 4 rows of RHS, so we need to skip the remaining 3 rows:
				rhsIdx += 3 * blockDim
			} // loop over rhs rows

			// Start next lhs row.
			baseLhsIdx += blockDim
		}
	}
}
