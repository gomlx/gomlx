/***** File generated by ./internal/cmd/packgemm_generator. Don't edit it directly. *****/

package packgemm

import (
	"github.com/gomlx/gomlx/pkg/core/dtypes"
	"github.com/gomlx/gomlx/pkg/core/dtypes/bfloat16"
	"github.com/pkg/errors"
	"github.com/x448/float16"
)

// GEMMDynamic dispatches the GEMM function for the given dtypes.
// It is a dynamic switch around GEMM[TInput, TOutput].
//
// The lhsFlat, rhsFlat and outputFlat parameters must be slices of the corresponding DType.
// The buffAllocAnyFn must yield a slice of the configured input DType, but cast as "any".
func GEMMDynamic(inputDType, outputDType dtypes.DType,
	alpha, beta float64, lhsFlat, rhsFlat any, batchSize,
	lhsCrossSize, rhsCrossSize, contractingSize int, outputFlat any,
	bufAllocAnyFn BufAllocAnyFn, bufReleaseFn BufReleaseFn, starter GoroutineStarter) error {

	pair := DTypePair{Input: inputDType, Output: outputDType}
	switch pair {
	case DTypePair{Input: dtypes.Int8, Output: dtypes.Int8}:
		bufAllocFn := func(size int) (ref any, data []int8) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]int8)
		}
		return GEMM(int8(alpha), int8(beta),
			lhsFlat.([]int8), rhsFlat.([]int8), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]int8),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Int16, Output: dtypes.Int16}:
		bufAllocFn := func(size int) (ref any, data []int16) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]int16)
		}
		return GEMM(int16(alpha), int16(beta),
			lhsFlat.([]int16), rhsFlat.([]int16), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]int16),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Int32, Output: dtypes.Int32}:
		bufAllocFn := func(size int) (ref any, data []int32) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]int32)
		}
		return GEMM(int32(alpha), int32(beta),
			lhsFlat.([]int32), rhsFlat.([]int32), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]int32),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Int64, Output: dtypes.Int64}:
		bufAllocFn := func(size int) (ref any, data []int64) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]int64)
		}
		return GEMM(int64(alpha), int64(beta),
			lhsFlat.([]int64), rhsFlat.([]int64), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]int64),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Uint8, Output: dtypes.Uint8}:
		bufAllocFn := func(size int) (ref any, data []uint8) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]uint8)
		}
		return GEMM(uint8(alpha), uint8(beta),
			lhsFlat.([]uint8), rhsFlat.([]uint8), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]uint8),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Uint16, Output: dtypes.Uint16}:
		bufAllocFn := func(size int) (ref any, data []uint16) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]uint16)
		}
		return GEMM(uint16(alpha), uint16(beta),
			lhsFlat.([]uint16), rhsFlat.([]uint16), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]uint16),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Uint32, Output: dtypes.Uint32}:
		bufAllocFn := func(size int) (ref any, data []uint32) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]uint32)
		}
		return GEMM(uint32(alpha), uint32(beta),
			lhsFlat.([]uint32), rhsFlat.([]uint32), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]uint32),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Uint64, Output: dtypes.Uint64}:
		bufAllocFn := func(size int) (ref any, data []uint64) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]uint64)
		}
		return GEMM(uint64(alpha), uint64(beta),
			lhsFlat.([]uint64), rhsFlat.([]uint64), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]uint64),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Float16, Output: dtypes.Float16}:
		bufAllocFn := func(size int) (ref any, data []float16.Float16) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]float16.Float16)
		}
		return GEMM(float16.Fromfloat32(float32(alpha)), float16.Fromfloat32(float32(beta)),
			lhsFlat.([]float16.Float16), rhsFlat.([]float16.Float16), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]float16.Float16),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Float32, Output: dtypes.Float32}:
		bufAllocFn := func(size int) (ref any, data []float32) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]float32)
		}
		return GEMM(float32(alpha), float32(beta),
			lhsFlat.([]float32), rhsFlat.([]float32), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]float32),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Float64, Output: dtypes.Float64}:
		bufAllocFn := func(size int) (ref any, data []float64) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]float64)
		}
		return GEMM(float64(alpha), float64(beta),
			lhsFlat.([]float64), rhsFlat.([]float64), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]float64),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.BFloat16, Output: dtypes.BFloat16}:
		bufAllocFn := func(size int) (ref any, data []bfloat16.BFloat16) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]bfloat16.BFloat16)
		}
		return GEMM(bfloat16.FromFloat32(float32(alpha)), bfloat16.FromFloat32(float32(beta)),
			lhsFlat.([]bfloat16.BFloat16), rhsFlat.([]bfloat16.BFloat16), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]bfloat16.BFloat16),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Complex64, Output: dtypes.Complex64}:
		bufAllocFn := func(size int) (ref any, data []complex64) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]complex64)
		}
		return GEMM(complex(float32(alpha), 0), complex(float32(beta), 0),
			lhsFlat.([]complex64), rhsFlat.([]complex64), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]complex64),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Complex128, Output: dtypes.Complex128}:
		bufAllocFn := func(size int) (ref any, data []complex128) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]complex128)
		}
		return GEMM(complex(alpha, 0), complex(beta, 0),
			lhsFlat.([]complex128), rhsFlat.([]complex128), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]complex128),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.S4, Output: dtypes.S4}:
		bufAllocFn := func(size int) (ref any, data []int8) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]int8)
		}
		return GEMM(int8(alpha), int8(beta),
			lhsFlat.([]int8), rhsFlat.([]int8), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]int8),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.U4, Output: dtypes.U4}:
		bufAllocFn := func(size int) (ref any, data []uint8) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]uint8)
		}
		return GEMM(uint8(alpha), uint8(beta),
			lhsFlat.([]uint8), rhsFlat.([]uint8), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]uint8),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.S2, Output: dtypes.S2}:
		bufAllocFn := func(size int) (ref any, data []int8) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]int8)
		}
		return GEMM(int8(alpha), int8(beta),
			lhsFlat.([]int8), rhsFlat.([]int8), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]int8),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.U2, Output: dtypes.U2}:
		bufAllocFn := func(size int) (ref any, data []uint8) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]uint8)
		}
		return GEMM(uint8(alpha), uint8(beta),
			lhsFlat.([]uint8), rhsFlat.([]uint8), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]uint8),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Float16, Output: dtypes.Float32}:
		bufAllocFn := func(size int) (ref any, data []float16.Float16) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]float16.Float16)
		}
		return GEMM(float32(alpha), float32(beta),
			lhsFlat.([]float16.Float16), rhsFlat.([]float16.Float16), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]float32),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.BFloat16, Output: dtypes.Float32}:
		bufAllocFn := func(size int) (ref any, data []bfloat16.BFloat16) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]bfloat16.BFloat16)
		}
		return GEMM(float32(alpha), float32(beta),
			lhsFlat.([]bfloat16.BFloat16), rhsFlat.([]bfloat16.BFloat16), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]float32),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Int8, Output: dtypes.Int32}:
		bufAllocFn := func(size int) (ref any, data []int8) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]int8)
		}
		return GEMM(int32(alpha), int32(beta),
			lhsFlat.([]int8), rhsFlat.([]int8), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]int32),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Int16, Output: dtypes.Int32}:
		bufAllocFn := func(size int) (ref any, data []int16) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]int16)
		}
		return GEMM(int32(alpha), int32(beta),
			lhsFlat.([]int16), rhsFlat.([]int16), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]int32),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Uint8, Output: dtypes.Uint32}:
		bufAllocFn := func(size int) (ref any, data []uint8) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]uint8)
		}
		return GEMM(uint32(alpha), uint32(beta),
			lhsFlat.([]uint8), rhsFlat.([]uint8), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]uint32),
			bufAllocFn, bufReleaseFn, starter)
	case DTypePair{Input: dtypes.Uint16, Output: dtypes.Uint32}:
		bufAllocFn := func(size int) (ref any, data []uint16) {
			ref, dataAny := bufAllocAnyFn(size)
			return ref, dataAny.([]uint16)
		}
		return GEMM(uint32(alpha), uint32(beta),
			lhsFlat.([]uint16), rhsFlat.([]uint16), batchSize,
			lhsCrossSize, rhsCrossSize, contractingSize, outputFlat.([]uint32),
			bufAllocFn, bufReleaseFn, starter)
	default:
		return errors.Errorf("Input/Output dtypes %s%s not configured in GEMM functions dispatcher",
			inputDType, outputDType)
	}
}
