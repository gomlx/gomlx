// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package packgemm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
	"github.com/gomlx/gomlx/internal/workerspool"
)

func BaseGEMMSymmetric16Registers_neon_Float16(alpha hwy.Float16, beta hwy.Float16, lhsFlat []hwy.Float16, rhsFlat []hwy.Float16, batchSize int, lhsCrossSize int, rhsCrossSize int, contractingSize int, outputFlat []hwy.Float16, bufAllocFn BufAllocFn[hwy.Float16], bufReleaseFn BufReleaseFn, pool *workerspool.Pool) error {
	numLanes := 8
	params := simd16RegistersParams
	params.RHSL1KernelCols *= numLanes
	lhsBatchStride := lhsCrossSize * contractingSize
	rhsBatchStride := contractingSize * rhsCrossSize
	outputBatchStride := lhsCrossSize * rhsCrossSize
	maxWorkers := 1
	if pool != nil {
		maxWorkers = pool.AdjustedMaxParallelism()
	}
	if maxWorkers <= 1 {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for batchIdx := range batchSize {
			batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
			batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
			batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
			GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, 0, lhsCrossSize, 0, rhsCrossSize, packedLHS, packedRHS, packedOutput)
		}
		return nil
	}
	workChan := make(chan workItem, max(2000, 2*maxWorkers))
	go feedWorkItems(batchSize, lhsCrossSize, rhsCrossSize, &params, maxWorkers, workChan)
	pool.Saturate(func() {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for item := range workChan {
			for batchIdx := item.batchStart; batchIdx < item.batchEnd; batchIdx++ {
				batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
				batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
				batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
				GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, item.lhsRowStart, item.lhsRowEnd, item.rhsColStart, item.rhsColEnd, packedLHS, packedRHS, packedOutput)
			}
		}
	})
	return nil
}

func BaseGEMMSymmetric16Registers_neon_BFloat16(alpha hwy.BFloat16, beta hwy.BFloat16, lhsFlat []hwy.BFloat16, rhsFlat []hwy.BFloat16, batchSize int, lhsCrossSize int, rhsCrossSize int, contractingSize int, outputFlat []hwy.BFloat16, bufAllocFn BufAllocFn[hwy.BFloat16], bufReleaseFn BufReleaseFn, pool *workerspool.Pool) error {
	numLanes := 8
	params := simd16RegistersParams
	params.RHSL1KernelCols *= numLanes
	lhsBatchStride := lhsCrossSize * contractingSize
	rhsBatchStride := contractingSize * rhsCrossSize
	outputBatchStride := lhsCrossSize * rhsCrossSize
	maxWorkers := 1
	if pool != nil {
		maxWorkers = pool.AdjustedMaxParallelism()
	}
	if maxWorkers <= 1 {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for batchIdx := range batchSize {
			batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
			batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
			batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
			GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, 0, lhsCrossSize, 0, rhsCrossSize, packedLHS, packedRHS, packedOutput)
		}
		return nil
	}
	workChan := make(chan workItem, max(2000, 2*maxWorkers))
	go feedWorkItems(batchSize, lhsCrossSize, rhsCrossSize, &params, maxWorkers, workChan)
	pool.Saturate(func() {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for item := range workChan {
			for batchIdx := item.batchStart; batchIdx < item.batchEnd; batchIdx++ {
				batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
				batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
				batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
				GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, item.lhsRowStart, item.lhsRowEnd, item.rhsColStart, item.rhsColEnd, packedLHS, packedRHS, packedOutput)
			}
		}
	})
	return nil
}

func BaseGEMMSymmetric16Registers_neon(alpha float32, beta float32, lhsFlat []float32, rhsFlat []float32, batchSize int, lhsCrossSize int, rhsCrossSize int, contractingSize int, outputFlat []float32, bufAllocFn BufAllocFn[float32], bufReleaseFn BufReleaseFn, pool *workerspool.Pool) error {
	numLanes := 4
	params := simd16RegistersParams
	params.RHSL1KernelCols *= numLanes
	lhsBatchStride := lhsCrossSize * contractingSize
	rhsBatchStride := contractingSize * rhsCrossSize
	outputBatchStride := lhsCrossSize * rhsCrossSize
	maxWorkers := 1
	if pool != nil {
		maxWorkers = pool.AdjustedMaxParallelism()
	}
	if maxWorkers <= 1 {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for batchIdx := range batchSize {
			batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
			batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
			batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
			GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, 0, lhsCrossSize, 0, rhsCrossSize, packedLHS, packedRHS, packedOutput)
		}
		return nil
	}
	workChan := make(chan workItem, max(2000, 2*maxWorkers))
	go feedWorkItems(batchSize, lhsCrossSize, rhsCrossSize, &params, maxWorkers, workChan)
	pool.Saturate(func() {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for item := range workChan {
			for batchIdx := item.batchStart; batchIdx < item.batchEnd; batchIdx++ {
				batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
				batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
				batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
				GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, item.lhsRowStart, item.lhsRowEnd, item.rhsColStart, item.rhsColEnd, packedLHS, packedRHS, packedOutput)
			}
		}
	})
	return nil
}

func BaseGEMMSymmetric16Registers_neon_Float64(alpha float64, beta float64, lhsFlat []float64, rhsFlat []float64, batchSize int, lhsCrossSize int, rhsCrossSize int, contractingSize int, outputFlat []float64, bufAllocFn BufAllocFn[float64], bufReleaseFn BufReleaseFn, pool *workerspool.Pool) error {
	numLanes := 2
	params := simd16RegistersParams
	params.RHSL1KernelCols *= numLanes
	lhsBatchStride := lhsCrossSize * contractingSize
	rhsBatchStride := contractingSize * rhsCrossSize
	outputBatchStride := lhsCrossSize * rhsCrossSize
	maxWorkers := 1
	if pool != nil {
		maxWorkers = pool.AdjustedMaxParallelism()
	}
	if maxWorkers <= 1 {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for batchIdx := range batchSize {
			batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
			batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
			batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
			GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, 0, lhsCrossSize, 0, rhsCrossSize, packedLHS, packedRHS, packedOutput)
		}
		return nil
	}
	workChan := make(chan workItem, max(2000, 2*maxWorkers))
	go feedWorkItems(batchSize, lhsCrossSize, rhsCrossSize, &params, maxWorkers, workChan)
	pool.Saturate(func() {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for item := range workChan {
			for batchIdx := item.batchStart; batchIdx < item.batchEnd; batchIdx++ {
				batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
				batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
				batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
				GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, item.lhsRowStart, item.lhsRowEnd, item.rhsColStart, item.rhsColEnd, packedLHS, packedRHS, packedOutput)
			}
		}
	})
	return nil
}

func BaseGEMMSymmetric16RegistersGemmChunk_neon_Float16(alpha hwy.Float16, beta hwy.Float16, lhs []hwy.Float16, rhs []hwy.Float16, output []hwy.Float16, lhsCrossSize int, rhsCrossSize int, contractingSize int, params *CacheParams, lhsRowStart int, lhsRowEnd int, rhsColStart int, rhsColEnd int, packedLhs []hwy.Float16, packedRhs []hwy.Float16, packedOutput []hwy.Float16) {
	for rhsPanelColIdx := rhsColStart; rhsPanelColIdx < rhsColEnd; rhsPanelColIdx += params.RHSPanelCrossSize {
		rhsPanelWidth := min(params.RHSPanelCrossSize, rhsColEnd-rhsPanelColIdx)
		for contractingPanelIdx := 0; contractingPanelIdx < contractingSize; contractingPanelIdx += params.PanelContractingSize {
			contractingPanelWidth := min(params.PanelContractingSize, contractingSize-contractingPanelIdx)
			PackRHS(rhs, packedRhs, contractingPanelIdx, rhsPanelColIdx, rhsCrossSize, contractingPanelWidth, rhsPanelWidth, params.RHSL1KernelCols)
			for lhsPanelRowIdx := lhsRowStart; lhsPanelRowIdx < lhsRowEnd; lhsPanelRowIdx += params.LHSPanelCrossSize {
				lhsPanelHeight := min(params.LHSPanelCrossSize, lhsRowEnd-lhsPanelRowIdx)
				packLHS(lhs, packedLhs, lhsPanelRowIdx, contractingPanelIdx, contractingSize, lhsPanelHeight, contractingPanelWidth, params.LHSL1KernelRows)
				GEMMSymmetric16RegistersPanel(contractingPanelWidth, packedLhs, packedRhs, packedOutput, params, lhsPanelHeight, rhsPanelWidth)
				effectiveBeta := beta.Float32()
				if contractingPanelIdx > 0 {
					effectiveBeta = 1
				}
				ApplyPackedOutput(packedOutput, output, alpha, hwy.Float32ToFloat16(float32(effectiveBeta)), params.RHSPanelCrossSize, lhsPanelRowIdx, rhsPanelColIdx, rhsCrossSize, lhsPanelHeight, rhsPanelWidth)
			}
		}
	}
}

func BaseGEMMSymmetric16RegistersGemmChunk_neon_BFloat16(alpha hwy.BFloat16, beta hwy.BFloat16, lhs []hwy.BFloat16, rhs []hwy.BFloat16, output []hwy.BFloat16, lhsCrossSize int, rhsCrossSize int, contractingSize int, params *CacheParams, lhsRowStart int, lhsRowEnd int, rhsColStart int, rhsColEnd int, packedLhs []hwy.BFloat16, packedRhs []hwy.BFloat16, packedOutput []hwy.BFloat16) {
	for rhsPanelColIdx := rhsColStart; rhsPanelColIdx < rhsColEnd; rhsPanelColIdx += params.RHSPanelCrossSize {
		rhsPanelWidth := min(params.RHSPanelCrossSize, rhsColEnd-rhsPanelColIdx)
		for contractingPanelIdx := 0; contractingPanelIdx < contractingSize; contractingPanelIdx += params.PanelContractingSize {
			contractingPanelWidth := min(params.PanelContractingSize, contractingSize-contractingPanelIdx)
			PackRHS(rhs, packedRhs, contractingPanelIdx, rhsPanelColIdx, rhsCrossSize, contractingPanelWidth, rhsPanelWidth, params.RHSL1KernelCols)
			for lhsPanelRowIdx := lhsRowStart; lhsPanelRowIdx < lhsRowEnd; lhsPanelRowIdx += params.LHSPanelCrossSize {
				lhsPanelHeight := min(params.LHSPanelCrossSize, lhsRowEnd-lhsPanelRowIdx)
				packLHS(lhs, packedLhs, lhsPanelRowIdx, contractingPanelIdx, contractingSize, lhsPanelHeight, contractingPanelWidth, params.LHSL1KernelRows)
				GEMMSymmetric16RegistersPanel(contractingPanelWidth, packedLhs, packedRhs, packedOutput, params, lhsPanelHeight, rhsPanelWidth)
				effectiveBeta := beta.Float32()
				if contractingPanelIdx > 0 {
					effectiveBeta = 1
				}
				ApplyPackedOutput(packedOutput, output, alpha, hwy.Float32ToBFloat16(float32(effectiveBeta)), params.RHSPanelCrossSize, lhsPanelRowIdx, rhsPanelColIdx, rhsCrossSize, lhsPanelHeight, rhsPanelWidth)
			}
		}
	}
}

func BaseGEMMSymmetric16RegistersGemmChunk_neon(alpha float32, beta float32, lhs []float32, rhs []float32, output []float32, lhsCrossSize int, rhsCrossSize int, contractingSize int, params *CacheParams, lhsRowStart int, lhsRowEnd int, rhsColStart int, rhsColEnd int, packedLhs []float32, packedRhs []float32, packedOutput []float32) {
	for rhsPanelColIdx := rhsColStart; rhsPanelColIdx < rhsColEnd; rhsPanelColIdx += params.RHSPanelCrossSize {
		rhsPanelWidth := min(params.RHSPanelCrossSize, rhsColEnd-rhsPanelColIdx)
		for contractingPanelIdx := 0; contractingPanelIdx < contractingSize; contractingPanelIdx += params.PanelContractingSize {
			contractingPanelWidth := min(params.PanelContractingSize, contractingSize-contractingPanelIdx)
			PackRHS(rhs, packedRhs, contractingPanelIdx, rhsPanelColIdx, rhsCrossSize, contractingPanelWidth, rhsPanelWidth, params.RHSL1KernelCols)
			for lhsPanelRowIdx := lhsRowStart; lhsPanelRowIdx < lhsRowEnd; lhsPanelRowIdx += params.LHSPanelCrossSize {
				lhsPanelHeight := min(params.LHSPanelCrossSize, lhsRowEnd-lhsPanelRowIdx)
				packLHS(lhs, packedLhs, lhsPanelRowIdx, contractingPanelIdx, contractingSize, lhsPanelHeight, contractingPanelWidth, params.LHSL1KernelRows)
				GEMMSymmetric16RegistersPanel(contractingPanelWidth, packedLhs, packedRhs, packedOutput, params, lhsPanelHeight, rhsPanelWidth)
				effectiveBeta := beta
				if contractingPanelIdx > 0 {
					effectiveBeta = 1
				}
				ApplyPackedOutput(packedOutput, output, alpha, float32(effectiveBeta), params.RHSPanelCrossSize, lhsPanelRowIdx, rhsPanelColIdx, rhsCrossSize, lhsPanelHeight, rhsPanelWidth)
			}
		}
	}
}

func BaseGEMMSymmetric16RegistersGemmChunk_neon_Float64(alpha float64, beta float64, lhs []float64, rhs []float64, output []float64, lhsCrossSize int, rhsCrossSize int, contractingSize int, params *CacheParams, lhsRowStart int, lhsRowEnd int, rhsColStart int, rhsColEnd int, packedLhs []float64, packedRhs []float64, packedOutput []float64) {
	for rhsPanelColIdx := rhsColStart; rhsPanelColIdx < rhsColEnd; rhsPanelColIdx += params.RHSPanelCrossSize {
		rhsPanelWidth := min(params.RHSPanelCrossSize, rhsColEnd-rhsPanelColIdx)
		for contractingPanelIdx := 0; contractingPanelIdx < contractingSize; contractingPanelIdx += params.PanelContractingSize {
			contractingPanelWidth := min(params.PanelContractingSize, contractingSize-contractingPanelIdx)
			PackRHS(rhs, packedRhs, contractingPanelIdx, rhsPanelColIdx, rhsCrossSize, contractingPanelWidth, rhsPanelWidth, params.RHSL1KernelCols)
			for lhsPanelRowIdx := lhsRowStart; lhsPanelRowIdx < lhsRowEnd; lhsPanelRowIdx += params.LHSPanelCrossSize {
				lhsPanelHeight := min(params.LHSPanelCrossSize, lhsRowEnd-lhsPanelRowIdx)
				packLHS(lhs, packedLhs, lhsPanelRowIdx, contractingPanelIdx, contractingSize, lhsPanelHeight, contractingPanelWidth, params.LHSL1KernelRows)
				GEMMSymmetric16RegistersPanel(contractingPanelWidth, packedLhs, packedRhs, packedOutput, params, lhsPanelHeight, rhsPanelWidth)
				effectiveBeta := beta
				if contractingPanelIdx > 0 {
					effectiveBeta = 1
				}
				ApplyPackedOutput(packedOutput, output, alpha, float64(effectiveBeta), params.RHSPanelCrossSize, lhsPanelRowIdx, rhsPanelColIdx, rhsCrossSize, lhsPanelHeight, rhsPanelWidth)
			}
		}
	}
}

func BaseGEMMSymmetric16RegistersPanel_neon_Float16(activeContractingLen int, packedLHS []hwy.Float16, packedRHS []hwy.Float16, packedOutput []hwy.Float16, params *CacheParams, lhsActivePanelHeight int, rhsActivePanelWidth int) {
	_ = packedLHS[activeContractingLen*lhsActivePanelHeight-1].Float32()
	_ = packedRHS[activeContractingLen*rhsActivePanelWidth-1].Float32()
	_ = packedOutput[lhsActivePanelHeight*rhsActivePanelWidth-1].Float32()
	numLanes := 8
	for lhsRowIdx := 0; lhsRowIdx < lhsActivePanelHeight; lhsRowIdx += params.LHSL1KernelRows {
		idxRHS := 0
		for rhsColIdx := 0; rhsColIdx < rhsActivePanelWidth; rhsColIdx += params.RHSL1KernelCols {
			outputRowStart := lhsRowIdx
			outputColStart := rhsColIdx
			outputStride := params.RHSPanelCrossSize
			lhsKernelRows := params.LHSL1KernelRows
			accum_lhs0_rhs0 := asm.ZeroFloat16x8()
			accum_lhs0_rhs1 := asm.ZeroFloat16x8()
			accum_lhs1_rhs0 := asm.ZeroFloat16x8()
			accum_lhs1_rhs1 := asm.ZeroFloat16x8()
			accum_lhs2_rhs0 := asm.ZeroFloat16x8()
			accum_lhs2_rhs1 := asm.ZeroFloat16x8()
			accum_lhs3_rhs0 := asm.ZeroFloat16x8()
			accum_lhs3_rhs1 := asm.ZeroFloat16x8()
			idxLHS := lhsRowIdx * activeContractingLen
			for range activeContractingLen {
				rhsVec0 := asm.LoadFloat16x8Ptr(unsafe.Pointer(&packedRHS[idxRHS:][0]))
				rhsVec1 := asm.LoadFloat16x8Ptr(unsafe.Pointer(&packedRHS[idxRHS+numLanes:][0]))
				idxRHS += 2 * numLanes
				lhsVal0 := packedLHS[idxLHS+0]
				lhsVec0 := asm.BroadcastFloat16x8(uint16(lhsVal0))
				rhsVec0.MulAddAcc(lhsVec0, &accum_lhs0_rhs0)
				rhsVec1.MulAddAcc(lhsVec0, &accum_lhs0_rhs1)
				lhsVal1 := packedLHS[idxLHS+1]
				lhsVec1 := asm.BroadcastFloat16x8(uint16(lhsVal1))
				rhsVec0.MulAddAcc(lhsVec1, &accum_lhs1_rhs0)
				rhsVec1.MulAddAcc(lhsVec1, &accum_lhs1_rhs1)
				lhsVal2 := packedLHS[idxLHS+2]
				lhsVec2 := asm.BroadcastFloat16x8(uint16(lhsVal2))
				rhsVec0.MulAddAcc(lhsVec2, &accum_lhs2_rhs0)
				rhsVec1.MulAddAcc(lhsVec2, &accum_lhs2_rhs1)
				lhsVal3 := packedLHS[idxLHS+3]
				lhsVec3 := asm.BroadcastFloat16x8(uint16(lhsVal3))
				rhsVec0.MulAddAcc(lhsVec3, &accum_lhs3_rhs0)
				rhsVec1.MulAddAcc(lhsVec3, &accum_lhs3_rhs1)
				idxLHS += lhsKernelRows
			}
			outputIdx0 := outputRowStart*outputStride + outputColStart
			outputIdx1 := outputIdx0 + params.RHSPanelCrossSize
			outputIdx2 := outputIdx0 + 2*params.RHSPanelCrossSize
			outputIdx3 := outputIdx0 + 3*params.RHSPanelCrossSize
			accum_lhs0_rhs0.StorePtr(unsafe.Pointer(&packedOutput[outputIdx0:][0]))
			accum_lhs0_rhs1.StorePtr(unsafe.Pointer(&packedOutput[outputIdx0+numLanes:][0]))
			accum_lhs1_rhs0.StorePtr(unsafe.Pointer(&packedOutput[outputIdx1:][0]))
			accum_lhs1_rhs1.StorePtr(unsafe.Pointer(&packedOutput[outputIdx1+numLanes:][0]))
			accum_lhs2_rhs0.StorePtr(unsafe.Pointer(&packedOutput[outputIdx2:][0]))
			accum_lhs2_rhs1.StorePtr(unsafe.Pointer(&packedOutput[outputIdx2+numLanes:][0]))
			accum_lhs3_rhs0.StorePtr(unsafe.Pointer(&packedOutput[outputIdx3:][0]))
			accum_lhs3_rhs1.StorePtr(unsafe.Pointer(&packedOutput[outputIdx3+numLanes:][0]))
		}
	}
}

func BaseGEMMSymmetric16RegistersPanel_neon_BFloat16(activeContractingLen int, packedLHS []hwy.BFloat16, packedRHS []hwy.BFloat16, packedOutput []hwy.BFloat16, params *CacheParams, lhsActivePanelHeight int, rhsActivePanelWidth int) {
	_ = packedLHS[activeContractingLen*lhsActivePanelHeight-1].Float32()
	_ = packedRHS[activeContractingLen*rhsActivePanelWidth-1].Float32()
	_ = packedOutput[lhsActivePanelHeight*rhsActivePanelWidth-1].Float32()
	numLanes := 8
	for lhsRowIdx := 0; lhsRowIdx < lhsActivePanelHeight; lhsRowIdx += params.LHSL1KernelRows {
		idxRHS := 0
		for rhsColIdx := 0; rhsColIdx < rhsActivePanelWidth; rhsColIdx += params.RHSL1KernelCols {
			outputRowStart := lhsRowIdx
			outputColStart := rhsColIdx
			outputStride := params.RHSPanelCrossSize
			lhsKernelRows := params.LHSL1KernelRows
			accum_lhs0_rhs0 := asm.ZeroBFloat16x8()
			accum_lhs0_rhs1 := asm.ZeroBFloat16x8()
			accum_lhs1_rhs0 := asm.ZeroBFloat16x8()
			accum_lhs1_rhs1 := asm.ZeroBFloat16x8()
			accum_lhs2_rhs0 := asm.ZeroBFloat16x8()
			accum_lhs2_rhs1 := asm.ZeroBFloat16x8()
			accum_lhs3_rhs0 := asm.ZeroBFloat16x8()
			accum_lhs3_rhs1 := asm.ZeroBFloat16x8()
			idxLHS := lhsRowIdx * activeContractingLen
			for range activeContractingLen {
				rhsVec0 := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&packedRHS[idxRHS:][0]))
				rhsVec1 := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&packedRHS[idxRHS+numLanes:][0]))
				idxRHS += 2 * numLanes
				lhsVal0 := packedLHS[idxLHS+0]
				lhsVec0 := asm.BroadcastBFloat16x8(uint16(lhsVal0))
				rhsVec0.MulAddAcc(lhsVec0, &accum_lhs0_rhs0)
				rhsVec1.MulAddAcc(lhsVec0, &accum_lhs0_rhs1)
				lhsVal1 := packedLHS[idxLHS+1]
				lhsVec1 := asm.BroadcastBFloat16x8(uint16(lhsVal1))
				rhsVec0.MulAddAcc(lhsVec1, &accum_lhs1_rhs0)
				rhsVec1.MulAddAcc(lhsVec1, &accum_lhs1_rhs1)
				lhsVal2 := packedLHS[idxLHS+2]
				lhsVec2 := asm.BroadcastBFloat16x8(uint16(lhsVal2))
				rhsVec0.MulAddAcc(lhsVec2, &accum_lhs2_rhs0)
				rhsVec1.MulAddAcc(lhsVec2, &accum_lhs2_rhs1)
				lhsVal3 := packedLHS[idxLHS+3]
				lhsVec3 := asm.BroadcastBFloat16x8(uint16(lhsVal3))
				rhsVec0.MulAddAcc(lhsVec3, &accum_lhs3_rhs0)
				rhsVec1.MulAddAcc(lhsVec3, &accum_lhs3_rhs1)
				idxLHS += lhsKernelRows
			}
			outputIdx0 := outputRowStart*outputStride + outputColStart
			outputIdx1 := outputIdx0 + params.RHSPanelCrossSize
			outputIdx2 := outputIdx0 + 2*params.RHSPanelCrossSize
			outputIdx3 := outputIdx0 + 3*params.RHSPanelCrossSize
			accum_lhs0_rhs0.StorePtr(unsafe.Pointer(&packedOutput[outputIdx0:][0]))
			accum_lhs0_rhs1.StorePtr(unsafe.Pointer(&packedOutput[outputIdx0+numLanes:][0]))
			accum_lhs1_rhs0.StorePtr(unsafe.Pointer(&packedOutput[outputIdx1:][0]))
			accum_lhs1_rhs1.StorePtr(unsafe.Pointer(&packedOutput[outputIdx1+numLanes:][0]))
			accum_lhs2_rhs0.StorePtr(unsafe.Pointer(&packedOutput[outputIdx2:][0]))
			accum_lhs2_rhs1.StorePtr(unsafe.Pointer(&packedOutput[outputIdx2+numLanes:][0]))
			accum_lhs3_rhs0.StorePtr(unsafe.Pointer(&packedOutput[outputIdx3:][0]))
			accum_lhs3_rhs1.StorePtr(unsafe.Pointer(&packedOutput[outputIdx3+numLanes:][0]))
		}
	}
}

func BaseGEMMSymmetric16RegistersPanel_neon(activeContractingLen int, packedLHS []float32, packedRHS []float32, packedOutput []float32, params *CacheParams, lhsActivePanelHeight int, rhsActivePanelWidth int) {
	_ = packedLHS[activeContractingLen*lhsActivePanelHeight-1]
	_ = packedRHS[activeContractingLen*rhsActivePanelWidth-1]
	_ = packedOutput[lhsActivePanelHeight*rhsActivePanelWidth-1]
	numLanes := 4
	for lhsRowIdx := 0; lhsRowIdx < lhsActivePanelHeight; lhsRowIdx += params.LHSL1KernelRows {
		idxRHS := 0
		for rhsColIdx := 0; rhsColIdx < rhsActivePanelWidth; rhsColIdx += params.RHSL1KernelCols {
			outputRowStart := lhsRowIdx
			outputColStart := rhsColIdx
			outputStride := params.RHSPanelCrossSize
			lhsKernelRows := params.LHSL1KernelRows
			accum_lhs0_rhs0 := asm.ZeroFloat32x4()
			accum_lhs0_rhs1 := asm.ZeroFloat32x4()
			accum_lhs1_rhs0 := asm.ZeroFloat32x4()
			accum_lhs1_rhs1 := asm.ZeroFloat32x4()
			accum_lhs2_rhs0 := asm.ZeroFloat32x4()
			accum_lhs2_rhs1 := asm.ZeroFloat32x4()
			accum_lhs3_rhs0 := asm.ZeroFloat32x4()
			accum_lhs3_rhs1 := asm.ZeroFloat32x4()
			idxLHS := lhsRowIdx * activeContractingLen
			for range activeContractingLen {
				rhsVec0 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&packedRHS[idxRHS])))
				rhsVec1 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&packedRHS[idxRHS+numLanes])))
				idxRHS += 2 * numLanes
				lhsVal0 := packedLHS[idxLHS+0]
				lhsVec0 := asm.BroadcastFloat32x4(lhsVal0)
				rhsVec0.MulAddAcc(lhsVec0, &accum_lhs0_rhs0)
				rhsVec1.MulAddAcc(lhsVec0, &accum_lhs0_rhs1)
				lhsVal1 := packedLHS[idxLHS+1]
				lhsVec1 := asm.BroadcastFloat32x4(lhsVal1)
				rhsVec0.MulAddAcc(lhsVec1, &accum_lhs1_rhs0)
				rhsVec1.MulAddAcc(lhsVec1, &accum_lhs1_rhs1)
				lhsVal2 := packedLHS[idxLHS+2]
				lhsVec2 := asm.BroadcastFloat32x4(lhsVal2)
				rhsVec0.MulAddAcc(lhsVec2, &accum_lhs2_rhs0)
				rhsVec1.MulAddAcc(lhsVec2, &accum_lhs2_rhs1)
				lhsVal3 := packedLHS[idxLHS+3]
				lhsVec3 := asm.BroadcastFloat32x4(lhsVal3)
				rhsVec0.MulAddAcc(lhsVec3, &accum_lhs3_rhs0)
				rhsVec1.MulAddAcc(lhsVec3, &accum_lhs3_rhs1)
				idxLHS += lhsKernelRows
			}
			outputIdx0 := outputRowStart*outputStride + outputColStart
			outputIdx1 := outputIdx0 + params.RHSPanelCrossSize
			outputIdx2 := outputIdx0 + 2*params.RHSPanelCrossSize
			outputIdx3 := outputIdx0 + 3*params.RHSPanelCrossSize
			accum_lhs0_rhs0.Store((*[4]float32)(unsafe.Pointer(&packedOutput[outputIdx0])))
			accum_lhs0_rhs1.Store((*[4]float32)(unsafe.Pointer(&packedOutput[outputIdx0+numLanes])))
			accum_lhs1_rhs0.Store((*[4]float32)(unsafe.Pointer(&packedOutput[outputIdx1])))
			accum_lhs1_rhs1.Store((*[4]float32)(unsafe.Pointer(&packedOutput[outputIdx1+numLanes])))
			accum_lhs2_rhs0.Store((*[4]float32)(unsafe.Pointer(&packedOutput[outputIdx2])))
			accum_lhs2_rhs1.Store((*[4]float32)(unsafe.Pointer(&packedOutput[outputIdx2+numLanes])))
			accum_lhs3_rhs0.Store((*[4]float32)(unsafe.Pointer(&packedOutput[outputIdx3])))
			accum_lhs3_rhs1.Store((*[4]float32)(unsafe.Pointer(&packedOutput[outputIdx3+numLanes])))
		}
	}
}

func BaseGEMMSymmetric16RegistersPanel_neon_Float64(activeContractingLen int, packedLHS []float64, packedRHS []float64, packedOutput []float64, params *CacheParams, lhsActivePanelHeight int, rhsActivePanelWidth int) {
	_ = packedLHS[activeContractingLen*lhsActivePanelHeight-1]
	_ = packedRHS[activeContractingLen*rhsActivePanelWidth-1]
	_ = packedOutput[lhsActivePanelHeight*rhsActivePanelWidth-1]
	numLanes := 2
	for lhsRowIdx := 0; lhsRowIdx < lhsActivePanelHeight; lhsRowIdx += params.LHSL1KernelRows {
		idxRHS := 0
		for rhsColIdx := 0; rhsColIdx < rhsActivePanelWidth; rhsColIdx += params.RHSL1KernelCols {
			outputRowStart := lhsRowIdx
			outputColStart := rhsColIdx
			outputStride := params.RHSPanelCrossSize
			lhsKernelRows := params.LHSL1KernelRows
			accum_lhs0_rhs0 := asm.ZeroFloat64x2()
			accum_lhs0_rhs1 := asm.ZeroFloat64x2()
			accum_lhs1_rhs0 := asm.ZeroFloat64x2()
			accum_lhs1_rhs1 := asm.ZeroFloat64x2()
			accum_lhs2_rhs0 := asm.ZeroFloat64x2()
			accum_lhs2_rhs1 := asm.ZeroFloat64x2()
			accum_lhs3_rhs0 := asm.ZeroFloat64x2()
			accum_lhs3_rhs1 := asm.ZeroFloat64x2()
			idxLHS := lhsRowIdx * activeContractingLen
			for range activeContractingLen {
				rhsVec0 := asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&packedRHS[idxRHS])))
				rhsVec1 := asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&packedRHS[idxRHS+numLanes])))
				idxRHS += 2 * numLanes
				lhsVal0 := packedLHS[idxLHS+0]
				lhsVec0 := asm.BroadcastFloat64x2(lhsVal0)
				rhsVec0.MulAddAcc(lhsVec0, &accum_lhs0_rhs0)
				rhsVec1.MulAddAcc(lhsVec0, &accum_lhs0_rhs1)
				lhsVal1 := packedLHS[idxLHS+1]
				lhsVec1 := asm.BroadcastFloat64x2(lhsVal1)
				rhsVec0.MulAddAcc(lhsVec1, &accum_lhs1_rhs0)
				rhsVec1.MulAddAcc(lhsVec1, &accum_lhs1_rhs1)
				lhsVal2 := packedLHS[idxLHS+2]
				lhsVec2 := asm.BroadcastFloat64x2(lhsVal2)
				rhsVec0.MulAddAcc(lhsVec2, &accum_lhs2_rhs0)
				rhsVec1.MulAddAcc(lhsVec2, &accum_lhs2_rhs1)
				lhsVal3 := packedLHS[idxLHS+3]
				lhsVec3 := asm.BroadcastFloat64x2(lhsVal3)
				rhsVec0.MulAddAcc(lhsVec3, &accum_lhs3_rhs0)
				rhsVec1.MulAddAcc(lhsVec3, &accum_lhs3_rhs1)
				idxLHS += lhsKernelRows
			}
			outputIdx0 := outputRowStart*outputStride + outputColStart
			outputIdx1 := outputIdx0 + params.RHSPanelCrossSize
			outputIdx2 := outputIdx0 + 2*params.RHSPanelCrossSize
			outputIdx3 := outputIdx0 + 3*params.RHSPanelCrossSize
			accum_lhs0_rhs0.Store((*[2]float64)(unsafe.Pointer(&packedOutput[outputIdx0])))
			accum_lhs0_rhs1.Store((*[2]float64)(unsafe.Pointer(&packedOutput[outputIdx0+numLanes])))
			accum_lhs1_rhs0.Store((*[2]float64)(unsafe.Pointer(&packedOutput[outputIdx1])))
			accum_lhs1_rhs1.Store((*[2]float64)(unsafe.Pointer(&packedOutput[outputIdx1+numLanes])))
			accum_lhs2_rhs0.Store((*[2]float64)(unsafe.Pointer(&packedOutput[outputIdx2])))
			accum_lhs2_rhs1.Store((*[2]float64)(unsafe.Pointer(&packedOutput[outputIdx2+numLanes])))
			accum_lhs3_rhs0.Store((*[2]float64)(unsafe.Pointer(&packedOutput[outputIdx3])))
			accum_lhs3_rhs1.Store((*[2]float64)(unsafe.Pointer(&packedOutput[outputIdx3+numLanes])))
		}
	}
}
