// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package packgemm

import (
	"github.com/ajroetker/go-highway/hwy"
	"simd/archsimd"
	"unsafe"
)

func BasePackRHS_avx512_Float16(src []hwy.Float16, dst []hwy.Float16, srcRowStart int, srcColStart int, srcRowStride int, contractingRows int, numCols int, kernelCols int) {
	dstIdx := 0
	numFullStrips := numCols / kernelCols
	fullStripsCol := numFullStrips * kernelCols
	srcStartRowIdx := srcRowStart * srcRowStride
	numLanes := 32
	switch {
	case kernelCols == numLanes:
		var v0 hwy.Vec[hwy.Float16]
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				v0 = hwy.Load(src[srcIdx:])
				hwy.StoreFull(v0, dst[dstIdx:])
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	case kernelCols == numLanes*2:
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				v0 := hwy.Load(src[srcIdx:])
				v1 := hwy.Load(src[srcIdx+numLanes:])
				hwy.StoreFull(v0, dst[dstIdx:])
				hwy.StoreFull(v1, dst[dstIdx+numLanes:])
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	case kernelCols == numLanes*4:
		var v0, v1, v2, v3 hwy.Vec[hwy.Float16]
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				v0 = hwy.Load(src[srcIdx:])
				v1 = hwy.Load(src[srcIdx+numLanes:])
				v2 = hwy.Load(src[srcIdx+numLanes*2:])
				v3 = hwy.Load(src[srcIdx+numLanes*3:])
				hwy.StoreFull(v0, dst[dstIdx:])
				hwy.StoreFull(v1, dst[dstIdx+numLanes:])
				hwy.StoreFull(v2, dst[dstIdx+numLanes*2:])
				hwy.StoreFull(v3, dst[dstIdx+numLanes*3:])
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	default:
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				copy(dst[dstIdx:], src[srcIdx:srcIdx+kernelCols])
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	}
	validCols := numCols - fullStripsCol
	if validCols == 0 {
		return
	}
	srcIdx := srcStartRowIdx + srcColStart + fullStripsCol
	for range contractingRows {
		copy(dst[dstIdx:], src[srcIdx:srcIdx+validCols])
		dstIdx += validCols
		for range kernelCols - validCols {
			dst[dstIdx] = hwy.Float32ToFloat16(0)
			dstIdx++
		}
	}
}

func BasePackRHS_avx512_BFloat16(src []hwy.BFloat16, dst []hwy.BFloat16, srcRowStart int, srcColStart int, srcRowStride int, contractingRows int, numCols int, kernelCols int) {
	dstIdx := 0
	numFullStrips := numCols / kernelCols
	fullStripsCol := numFullStrips * kernelCols
	srcStartRowIdx := srcRowStart * srcRowStride
	numLanes := 32
	switch {
	case kernelCols == numLanes:
		var v0 hwy.Vec[hwy.BFloat16]
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				v0 = hwy.Load(src[srcIdx:])
				hwy.StoreFull(v0, dst[dstIdx:])
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	case kernelCols == numLanes*2:
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				v0 := hwy.Load(src[srcIdx:])
				v1 := hwy.Load(src[srcIdx+numLanes:])
				hwy.StoreFull(v0, dst[dstIdx:])
				hwy.StoreFull(v1, dst[dstIdx+numLanes:])
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	case kernelCols == numLanes*4:
		var v0, v1, v2, v3 hwy.Vec[hwy.BFloat16]
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				v0 = hwy.Load(src[srcIdx:])
				v1 = hwy.Load(src[srcIdx+numLanes:])
				v2 = hwy.Load(src[srcIdx+numLanes*2:])
				v3 = hwy.Load(src[srcIdx+numLanes*3:])
				hwy.StoreFull(v0, dst[dstIdx:])
				hwy.StoreFull(v1, dst[dstIdx+numLanes:])
				hwy.StoreFull(v2, dst[dstIdx+numLanes*2:])
				hwy.StoreFull(v3, dst[dstIdx+numLanes*3:])
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	default:
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				copy(dst[dstIdx:], src[srcIdx:srcIdx+kernelCols])
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	}
	validCols := numCols - fullStripsCol
	if validCols == 0 {
		return
	}
	srcIdx := srcStartRowIdx + srcColStart + fullStripsCol
	for range contractingRows {
		copy(dst[dstIdx:], src[srcIdx:srcIdx+validCols])
		dstIdx += validCols
		for range kernelCols - validCols {
			dst[dstIdx] = hwy.Float32ToBFloat16(0)
			dstIdx++
		}
	}
}

func BasePackRHS_avx512(src []float32, dst []float32, srcRowStart int, srcColStart int, srcRowStride int, contractingRows int, numCols int, kernelCols int) {
	dstIdx := 0
	numFullStrips := numCols / kernelCols
	fullStripsCol := numFullStrips * kernelCols
	srcStartRowIdx := srcRowStart * srcRowStride
	numLanes := 16
	switch {
	case kernelCols == numLanes:
		var v0 archsimd.Float32x16
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				v0 = archsimd.LoadFloat32x16Slice(src[srcIdx:])
				v0.Store((*[16]float32)(unsafe.Pointer(&dst[dstIdx])))
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	case kernelCols == numLanes*2:
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				v0 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[srcIdx])))
				v1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[srcIdx+numLanes])))
				v0.Store((*[16]float32)(unsafe.Pointer(&dst[dstIdx])))
				v1.Store((*[16]float32)(unsafe.Pointer(&dst[dstIdx+numLanes])))
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	case kernelCols == numLanes*4:
		var v0, v1, v2, v3 archsimd.Float32x16
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				v0 = archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[srcIdx])))
				v1 = archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[srcIdx+numLanes])))
				v2 = archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[srcIdx+numLanes*2])))
				v3 = archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[srcIdx+numLanes*3])))
				v0.Store((*[16]float32)(unsafe.Pointer(&dst[dstIdx])))
				v1.Store((*[16]float32)(unsafe.Pointer(&dst[dstIdx+numLanes])))
				v2.Store((*[16]float32)(unsafe.Pointer(&dst[dstIdx+numLanes*2])))
				v3.Store((*[16]float32)(unsafe.Pointer(&dst[dstIdx+numLanes*3])))
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	default:
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				copy(dst[dstIdx:], src[srcIdx:srcIdx+kernelCols])
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	}
	validCols := numCols - fullStripsCol
	if validCols == 0 {
		return
	}
	srcIdx := srcStartRowIdx + srcColStart + fullStripsCol
	for range contractingRows {
		copy(dst[dstIdx:], src[srcIdx:srcIdx+validCols])
		dstIdx += validCols
		for range kernelCols - validCols {
			dst[dstIdx] = 0
			dstIdx++
		}
	}
}

func BasePackRHS_avx512_Float64(src []float64, dst []float64, srcRowStart int, srcColStart int, srcRowStride int, contractingRows int, numCols int, kernelCols int) {
	dstIdx := 0
	numFullStrips := numCols / kernelCols
	fullStripsCol := numFullStrips * kernelCols
	srcStartRowIdx := srcRowStart * srcRowStride
	numLanes := 8
	switch {
	case kernelCols == numLanes:
		var v0 archsimd.Float64x8
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				v0 = archsimd.LoadFloat64x8Slice(src[srcIdx:])
				v0.Store((*[8]float64)(unsafe.Pointer(&dst[dstIdx])))
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	case kernelCols == numLanes*2:
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				v0 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[srcIdx])))
				v1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[srcIdx+numLanes])))
				v0.Store((*[8]float64)(unsafe.Pointer(&dst[dstIdx])))
				v1.Store((*[8]float64)(unsafe.Pointer(&dst[dstIdx+numLanes])))
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	case kernelCols == numLanes*4:
		var v0, v1, v2, v3 archsimd.Float64x8
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				v0 = archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[srcIdx])))
				v1 = archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[srcIdx+numLanes])))
				v2 = archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[srcIdx+numLanes*2])))
				v3 = archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[srcIdx+numLanes*3])))
				v0.Store((*[8]float64)(unsafe.Pointer(&dst[dstIdx])))
				v1.Store((*[8]float64)(unsafe.Pointer(&dst[dstIdx+numLanes])))
				v2.Store((*[8]float64)(unsafe.Pointer(&dst[dstIdx+numLanes*2])))
				v3.Store((*[8]float64)(unsafe.Pointer(&dst[dstIdx+numLanes*3])))
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	default:
		for stripColIdx := 0; stripColIdx < fullStripsCol; stripColIdx += kernelCols {
			srcIdx := srcStartRowIdx + srcColStart + stripColIdx
			for range contractingRows {
				copy(dst[dstIdx:], src[srcIdx:srcIdx+kernelCols])
				dstIdx += kernelCols
				srcIdx += srcRowStride
			}
		}
	}
	validCols := numCols - fullStripsCol
	if validCols == 0 {
		return
	}
	srcIdx := srcStartRowIdx + srcColStart + fullStripsCol
	for range contractingRows {
		copy(dst[dstIdx:], src[srcIdx:srcIdx+validCols])
		dstIdx += validCols
		for range kernelCols - validCols {
			dst[dstIdx] = 0
			dstIdx++
		}
	}
}
