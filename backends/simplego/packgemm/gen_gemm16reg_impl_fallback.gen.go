// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package packgemm

import (
	"github.com/ajroetker/go-highway/hwy"
	"github.com/gomlx/gomlx/internal/workerspool"
)

func BaseGEMMSymmetric16Registers_fallback_Float16(alpha hwy.Float16, beta hwy.Float16, lhsFlat []hwy.Float16, rhsFlat []hwy.Float16, batchSize int, lhsCrossSize int, rhsCrossSize int, contractingSize int, outputFlat []hwy.Float16, bufAllocFn BufAllocFn[hwy.Float16], bufReleaseFn BufReleaseFn, pool *workerspool.Pool) error {
	numLanes := hwy.NumLanes[hwy.Float16]()
	params := simd16RegistersParams
	params.RHSL1KernelCols *= numLanes
	lhsBatchStride := lhsCrossSize * contractingSize
	rhsBatchStride := contractingSize * rhsCrossSize
	outputBatchStride := lhsCrossSize * rhsCrossSize
	maxWorkers := 1
	if pool != nil {
		maxWorkers = pool.AdjustedMaxParallelism()
	}
	if maxWorkers <= 1 {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for batchIdx := range batchSize {
			batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
			batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
			batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
			GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, 0, lhsCrossSize, 0, rhsCrossSize, packedLHS, packedRHS, packedOutput)
		}
		return nil
	}
	workChan := make(chan workItem, max(2000, 2*maxWorkers))
	go feedWorkItems(batchSize, lhsCrossSize, rhsCrossSize, &params, maxWorkers, workChan)
	pool.Saturate(func() {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for item := range workChan {
			for batchIdx := item.batchStart; batchIdx < item.batchEnd; batchIdx++ {
				batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
				batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
				batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
				GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, item.lhsRowStart, item.lhsRowEnd, item.rhsColStart, item.rhsColEnd, packedLHS, packedRHS, packedOutput)
			}
		}
	})
	return nil
}

func BaseGEMMSymmetric16Registers_fallback_BFloat16(alpha hwy.BFloat16, beta hwy.BFloat16, lhsFlat []hwy.BFloat16, rhsFlat []hwy.BFloat16, batchSize int, lhsCrossSize int, rhsCrossSize int, contractingSize int, outputFlat []hwy.BFloat16, bufAllocFn BufAllocFn[hwy.BFloat16], bufReleaseFn BufReleaseFn, pool *workerspool.Pool) error {
	numLanes := hwy.NumLanes[hwy.BFloat16]()
	params := simd16RegistersParams
	params.RHSL1KernelCols *= numLanes
	lhsBatchStride := lhsCrossSize * contractingSize
	rhsBatchStride := contractingSize * rhsCrossSize
	outputBatchStride := lhsCrossSize * rhsCrossSize
	maxWorkers := 1
	if pool != nil {
		maxWorkers = pool.AdjustedMaxParallelism()
	}
	if maxWorkers <= 1 {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for batchIdx := range batchSize {
			batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
			batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
			batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
			GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, 0, lhsCrossSize, 0, rhsCrossSize, packedLHS, packedRHS, packedOutput)
		}
		return nil
	}
	workChan := make(chan workItem, max(2000, 2*maxWorkers))
	go feedWorkItems(batchSize, lhsCrossSize, rhsCrossSize, &params, maxWorkers, workChan)
	pool.Saturate(func() {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for item := range workChan {
			for batchIdx := item.batchStart; batchIdx < item.batchEnd; batchIdx++ {
				batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
				batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
				batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
				GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, item.lhsRowStart, item.lhsRowEnd, item.rhsColStart, item.rhsColEnd, packedLHS, packedRHS, packedOutput)
			}
		}
	})
	return nil
}

func BaseGEMMSymmetric16Registers_fallback(alpha float32, beta float32, lhsFlat []float32, rhsFlat []float32, batchSize int, lhsCrossSize int, rhsCrossSize int, contractingSize int, outputFlat []float32, bufAllocFn BufAllocFn[float32], bufReleaseFn BufReleaseFn, pool *workerspool.Pool) error {
	numLanes := 1
	params := simd16RegistersParams
	params.RHSL1KernelCols *= numLanes
	lhsBatchStride := lhsCrossSize * contractingSize
	rhsBatchStride := contractingSize * rhsCrossSize
	outputBatchStride := lhsCrossSize * rhsCrossSize
	maxWorkers := 1
	if pool != nil {
		maxWorkers = pool.AdjustedMaxParallelism()
	}
	if maxWorkers <= 1 {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for batchIdx := range batchSize {
			batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
			batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
			batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
			GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, 0, lhsCrossSize, 0, rhsCrossSize, packedLHS, packedRHS, packedOutput)
		}
		return nil
	}
	workChan := make(chan workItem, max(2000, 2*maxWorkers))
	go feedWorkItems(batchSize, lhsCrossSize, rhsCrossSize, &params, maxWorkers, workChan)
	pool.Saturate(func() {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for item := range workChan {
			for batchIdx := item.batchStart; batchIdx < item.batchEnd; batchIdx++ {
				batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
				batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
				batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
				GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, item.lhsRowStart, item.lhsRowEnd, item.rhsColStart, item.rhsColEnd, packedLHS, packedRHS, packedOutput)
			}
		}
	})
	return nil
}

func BaseGEMMSymmetric16Registers_fallback_Float64(alpha float64, beta float64, lhsFlat []float64, rhsFlat []float64, batchSize int, lhsCrossSize int, rhsCrossSize int, contractingSize int, outputFlat []float64, bufAllocFn BufAllocFn[float64], bufReleaseFn BufReleaseFn, pool *workerspool.Pool) error {
	numLanes := 1
	params := simd16RegistersParams
	params.RHSL1KernelCols *= numLanes
	lhsBatchStride := lhsCrossSize * contractingSize
	rhsBatchStride := contractingSize * rhsCrossSize
	outputBatchStride := lhsCrossSize * rhsCrossSize
	maxWorkers := 1
	if pool != nil {
		maxWorkers = pool.AdjustedMaxParallelism()
	}
	if maxWorkers <= 1 {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for batchIdx := range batchSize {
			batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
			batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
			batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
			GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, 0, lhsCrossSize, 0, rhsCrossSize, packedLHS, packedRHS, packedOutput)
		}
		return nil
	}
	workChan := make(chan workItem, max(2000, 2*maxWorkers))
	go feedWorkItems(batchSize, lhsCrossSize, rhsCrossSize, &params, maxWorkers, workChan)
	pool.Saturate(func() {
		packedLhsRef, packedLHS := bufAllocFn(params.LHSPanelCrossSize * params.PanelContractingSize)
		packedRhsRef, packedRHS := bufAllocFn(params.PanelContractingSize * params.RHSPanelCrossSize)
		packedOutRef, packedOutput := bufAllocFn(params.LHSPanelCrossSize * params.RHSPanelCrossSize)
		defer func() {
			bufReleaseFn(packedLhsRef)
			bufReleaseFn(packedRhsRef)
			bufReleaseFn(packedOutRef)
		}()
		for item := range workChan {
			for batchIdx := item.batchStart; batchIdx < item.batchEnd; batchIdx++ {
				batchLhs := lhsFlat[batchIdx*lhsBatchStride : (batchIdx+1)*lhsBatchStride]
				batchRhs := rhsFlat[batchIdx*rhsBatchStride : (batchIdx+1)*rhsBatchStride]
				batchOutput := outputFlat[batchIdx*outputBatchStride : (batchIdx+1)*outputBatchStride]
				GEMMSymmetric16RegistersGemmChunk(alpha, beta, batchLhs, batchRhs, batchOutput, lhsCrossSize, rhsCrossSize, contractingSize, &params, item.lhsRowStart, item.lhsRowEnd, item.rhsColStart, item.rhsColEnd, packedLHS, packedRHS, packedOutput)
			}
		}
	})
	return nil
}

func BaseGEMMSymmetric16RegistersGemmChunk_fallback_Float16(alpha hwy.Float16, beta hwy.Float16, lhs []hwy.Float16, rhs []hwy.Float16, output []hwy.Float16, lhsCrossSize int, rhsCrossSize int, contractingSize int, params *CacheParams, lhsRowStart int, lhsRowEnd int, rhsColStart int, rhsColEnd int, packedLhs []hwy.Float16, packedRhs []hwy.Float16, packedOutput []hwy.Float16) {
	for rhsPanelColIdx := rhsColStart; rhsPanelColIdx < rhsColEnd; rhsPanelColIdx += params.RHSPanelCrossSize {
		rhsPanelWidth := min(params.RHSPanelCrossSize, rhsColEnd-rhsPanelColIdx)
		for contractingPanelIdx := 0; contractingPanelIdx < contractingSize; contractingPanelIdx += params.PanelContractingSize {
			contractingPanelWidth := min(params.PanelContractingSize, contractingSize-contractingPanelIdx)
			PackRHS(rhs, packedRhs, contractingPanelIdx, rhsPanelColIdx, rhsCrossSize, contractingPanelWidth, rhsPanelWidth, params.RHSL1KernelCols)
			for lhsPanelRowIdx := lhsRowStart; lhsPanelRowIdx < lhsRowEnd; lhsPanelRowIdx += params.LHSPanelCrossSize {
				lhsPanelHeight := min(params.LHSPanelCrossSize, lhsRowEnd-lhsPanelRowIdx)
				packLHS(lhs, packedLhs, lhsPanelRowIdx, contractingPanelIdx, contractingSize, lhsPanelHeight, contractingPanelWidth, params.LHSL1KernelRows)
				GEMMSymmetric16RegistersPanel(contractingPanelWidth, packedLhs, packedRhs, packedOutput, params, lhsPanelHeight, rhsPanelWidth)
				effectiveBeta := beta.Float32()
				if contractingPanelIdx > 0 {
					effectiveBeta = 1
				}
				ApplyPackedOutput(packedOutput, output, alpha, hwy.Float32ToFloat16(effectiveBeta), params.RHSPanelCrossSize, lhsPanelRowIdx, rhsPanelColIdx, rhsCrossSize, lhsPanelHeight, rhsPanelWidth)
			}
		}
	}
}

func BaseGEMMSymmetric16RegistersGemmChunk_fallback_BFloat16(alpha hwy.BFloat16, beta hwy.BFloat16, lhs []hwy.BFloat16, rhs []hwy.BFloat16, output []hwy.BFloat16, lhsCrossSize int, rhsCrossSize int, contractingSize int, params *CacheParams, lhsRowStart int, lhsRowEnd int, rhsColStart int, rhsColEnd int, packedLhs []hwy.BFloat16, packedRhs []hwy.BFloat16, packedOutput []hwy.BFloat16) {
	for rhsPanelColIdx := rhsColStart; rhsPanelColIdx < rhsColEnd; rhsPanelColIdx += params.RHSPanelCrossSize {
		rhsPanelWidth := min(params.RHSPanelCrossSize, rhsColEnd-rhsPanelColIdx)
		for contractingPanelIdx := 0; contractingPanelIdx < contractingSize; contractingPanelIdx += params.PanelContractingSize {
			contractingPanelWidth := min(params.PanelContractingSize, contractingSize-contractingPanelIdx)
			PackRHS(rhs, packedRhs, contractingPanelIdx, rhsPanelColIdx, rhsCrossSize, contractingPanelWidth, rhsPanelWidth, params.RHSL1KernelCols)
			for lhsPanelRowIdx := lhsRowStart; lhsPanelRowIdx < lhsRowEnd; lhsPanelRowIdx += params.LHSPanelCrossSize {
				lhsPanelHeight := min(params.LHSPanelCrossSize, lhsRowEnd-lhsPanelRowIdx)
				packLHS(lhs, packedLhs, lhsPanelRowIdx, contractingPanelIdx, contractingSize, lhsPanelHeight, contractingPanelWidth, params.LHSL1KernelRows)
				GEMMSymmetric16RegistersPanel(contractingPanelWidth, packedLhs, packedRhs, packedOutput, params, lhsPanelHeight, rhsPanelWidth)
				effectiveBeta := beta.Float32()
				if contractingPanelIdx > 0 {
					effectiveBeta = 1
				}
				ApplyPackedOutput(packedOutput, output, alpha, hwy.Float32ToBFloat16(effectiveBeta), params.RHSPanelCrossSize, lhsPanelRowIdx, rhsPanelColIdx, rhsCrossSize, lhsPanelHeight, rhsPanelWidth)
			}
		}
	}
}

func BaseGEMMSymmetric16RegistersGemmChunk_fallback(alpha float32, beta float32, lhs []float32, rhs []float32, output []float32, lhsCrossSize int, rhsCrossSize int, contractingSize int, params *CacheParams, lhsRowStart int, lhsRowEnd int, rhsColStart int, rhsColEnd int, packedLhs []float32, packedRhs []float32, packedOutput []float32) {
	for rhsPanelColIdx := rhsColStart; rhsPanelColIdx < rhsColEnd; rhsPanelColIdx += params.RHSPanelCrossSize {
		rhsPanelWidth := min(params.RHSPanelCrossSize, rhsColEnd-rhsPanelColIdx)
		for contractingPanelIdx := 0; contractingPanelIdx < contractingSize; contractingPanelIdx += params.PanelContractingSize {
			contractingPanelWidth := min(params.PanelContractingSize, contractingSize-contractingPanelIdx)
			PackRHS(rhs, packedRhs, contractingPanelIdx, rhsPanelColIdx, rhsCrossSize, contractingPanelWidth, rhsPanelWidth, params.RHSL1KernelCols)
			for lhsPanelRowIdx := lhsRowStart; lhsPanelRowIdx < lhsRowEnd; lhsPanelRowIdx += params.LHSPanelCrossSize {
				lhsPanelHeight := min(params.LHSPanelCrossSize, lhsRowEnd-lhsPanelRowIdx)
				packLHS(lhs, packedLhs, lhsPanelRowIdx, contractingPanelIdx, contractingSize, lhsPanelHeight, contractingPanelWidth, params.LHSL1KernelRows)
				GEMMSymmetric16RegistersPanel(contractingPanelWidth, packedLhs, packedRhs, packedOutput, params, lhsPanelHeight, rhsPanelWidth)
				effectiveBeta := beta
				if contractingPanelIdx > 0 {
					effectiveBeta = 1
				}
				ApplyPackedOutput(packedOutput, output, alpha, float32(effectiveBeta), params.RHSPanelCrossSize, lhsPanelRowIdx, rhsPanelColIdx, rhsCrossSize, lhsPanelHeight, rhsPanelWidth)
			}
		}
	}
}

func BaseGEMMSymmetric16RegistersGemmChunk_fallback_Float64(alpha float64, beta float64, lhs []float64, rhs []float64, output []float64, lhsCrossSize int, rhsCrossSize int, contractingSize int, params *CacheParams, lhsRowStart int, lhsRowEnd int, rhsColStart int, rhsColEnd int, packedLhs []float64, packedRhs []float64, packedOutput []float64) {
	for rhsPanelColIdx := rhsColStart; rhsPanelColIdx < rhsColEnd; rhsPanelColIdx += params.RHSPanelCrossSize {
		rhsPanelWidth := min(params.RHSPanelCrossSize, rhsColEnd-rhsPanelColIdx)
		for contractingPanelIdx := 0; contractingPanelIdx < contractingSize; contractingPanelIdx += params.PanelContractingSize {
			contractingPanelWidth := min(params.PanelContractingSize, contractingSize-contractingPanelIdx)
			PackRHS(rhs, packedRhs, contractingPanelIdx, rhsPanelColIdx, rhsCrossSize, contractingPanelWidth, rhsPanelWidth, params.RHSL1KernelCols)
			for lhsPanelRowIdx := lhsRowStart; lhsPanelRowIdx < lhsRowEnd; lhsPanelRowIdx += params.LHSPanelCrossSize {
				lhsPanelHeight := min(params.LHSPanelCrossSize, lhsRowEnd-lhsPanelRowIdx)
				packLHS(lhs, packedLhs, lhsPanelRowIdx, contractingPanelIdx, contractingSize, lhsPanelHeight, contractingPanelWidth, params.LHSL1KernelRows)
				GEMMSymmetric16RegistersPanel(contractingPanelWidth, packedLhs, packedRhs, packedOutput, params, lhsPanelHeight, rhsPanelWidth)
				effectiveBeta := beta
				if contractingPanelIdx > 0 {
					effectiveBeta = 1
				}
				ApplyPackedOutput(packedOutput, output, alpha, float64(effectiveBeta), params.RHSPanelCrossSize, lhsPanelRowIdx, rhsPanelColIdx, rhsCrossSize, lhsPanelHeight, rhsPanelWidth)
			}
		}
	}
}

func BaseGEMMSymmetric16RegistersPanel_fallback_Float16(activeContractingLen int, packedLHS []hwy.Float16, packedRHS []hwy.Float16, packedOutput []hwy.Float16, params *CacheParams, lhsActivePanelHeight int, rhsActivePanelWidth int) {
	_ = packedLHS[activeContractingLen*lhsActivePanelHeight-1].Float32()
	_ = packedRHS[activeContractingLen*rhsActivePanelWidth-1].Float32()
	_ = packedOutput[lhsActivePanelHeight*rhsActivePanelWidth-1].Float32()
	numLanes := hwy.NumLanes[hwy.Float16]()
	for lhsRowIdx := 0; lhsRowIdx < lhsActivePanelHeight; lhsRowIdx += params.LHSL1KernelRows {
		idxRHS := 0
		for rhsColIdx := 0; rhsColIdx < rhsActivePanelWidth; rhsColIdx += params.RHSL1KernelCols {
			outputRowStart := lhsRowIdx
			outputColStart := rhsColIdx
			outputStride := params.RHSPanelCrossSize
			lhsKernelRows := params.LHSL1KernelRows
			accum_lhs0_rhs0 := hwy.Zero[hwy.Float16]()
			accum_lhs0_rhs1 := hwy.Zero[hwy.Float16]()
			accum_lhs1_rhs0 := hwy.Zero[hwy.Float16]()
			accum_lhs1_rhs1 := hwy.Zero[hwy.Float16]()
			accum_lhs2_rhs0 := hwy.Zero[hwy.Float16]()
			accum_lhs2_rhs1 := hwy.Zero[hwy.Float16]()
			accum_lhs3_rhs0 := hwy.Zero[hwy.Float16]()
			accum_lhs3_rhs1 := hwy.Zero[hwy.Float16]()
			idxLHS := lhsRowIdx * activeContractingLen
			for range activeContractingLen {
				rhsVec0 := hwy.Load(packedRHS[idxRHS:])
				rhsVec1 := hwy.Load(packedRHS[idxRHS+numLanes:])
				idxRHS += 2 * numLanes
				lhsVal0 := packedLHS[idxLHS+0]
				lhsVec0 := hwy.Set[hwy.Float16](lhsVal0)
				accum_lhs0_rhs0 = hwy.MulAdd(rhsVec0, lhsVec0, accum_lhs0_rhs0)
				accum_lhs0_rhs1 = hwy.MulAdd(rhsVec1, lhsVec0, accum_lhs0_rhs1)
				lhsVal1 := packedLHS[idxLHS+1]
				lhsVec1 := hwy.Set[hwy.Float16](lhsVal1)
				accum_lhs1_rhs0 = hwy.MulAdd(rhsVec0, lhsVec1, accum_lhs1_rhs0)
				accum_lhs1_rhs1 = hwy.MulAdd(rhsVec1, lhsVec1, accum_lhs1_rhs1)
				lhsVal2 := packedLHS[idxLHS+2]
				lhsVec2 := hwy.Set[hwy.Float16](lhsVal2)
				accum_lhs2_rhs0 = hwy.MulAdd(rhsVec0, lhsVec2, accum_lhs2_rhs0)
				accum_lhs2_rhs1 = hwy.MulAdd(rhsVec1, lhsVec2, accum_lhs2_rhs1)
				lhsVal3 := packedLHS[idxLHS+3]
				lhsVec3 := hwy.Set[hwy.Float16](lhsVal3)
				accum_lhs3_rhs0 = hwy.MulAdd(rhsVec0, lhsVec3, accum_lhs3_rhs0)
				accum_lhs3_rhs1 = hwy.MulAdd(rhsVec1, lhsVec3, accum_lhs3_rhs1)
				idxLHS += lhsKernelRows
			}
			outputIdx0 := outputRowStart*outputStride + outputColStart
			outputIdx1 := outputIdx0 + params.RHSPanelCrossSize
			outputIdx2 := outputIdx0 + 2*params.RHSPanelCrossSize
			outputIdx3 := outputIdx0 + 3*params.RHSPanelCrossSize
			hwy.Store(accum_lhs0_rhs0, packedOutput[outputIdx0:])
			hwy.Store(accum_lhs0_rhs1, packedOutput[outputIdx0+numLanes:])
			hwy.Store(accum_lhs1_rhs0, packedOutput[outputIdx1:])
			hwy.Store(accum_lhs1_rhs1, packedOutput[outputIdx1+numLanes:])
			hwy.Store(accum_lhs2_rhs0, packedOutput[outputIdx2:])
			hwy.Store(accum_lhs2_rhs1, packedOutput[outputIdx2+numLanes:])
			hwy.Store(accum_lhs3_rhs0, packedOutput[outputIdx3:])
			hwy.Store(accum_lhs3_rhs1, packedOutput[outputIdx3+numLanes:])
		}
	}
}

func BaseGEMMSymmetric16RegistersPanel_fallback_BFloat16(activeContractingLen int, packedLHS []hwy.BFloat16, packedRHS []hwy.BFloat16, packedOutput []hwy.BFloat16, params *CacheParams, lhsActivePanelHeight int, rhsActivePanelWidth int) {
	_ = packedLHS[activeContractingLen*lhsActivePanelHeight-1].Float32()
	_ = packedRHS[activeContractingLen*rhsActivePanelWidth-1].Float32()
	_ = packedOutput[lhsActivePanelHeight*rhsActivePanelWidth-1].Float32()
	numLanes := hwy.NumLanes[hwy.BFloat16]()
	for lhsRowIdx := 0; lhsRowIdx < lhsActivePanelHeight; lhsRowIdx += params.LHSL1KernelRows {
		idxRHS := 0
		for rhsColIdx := 0; rhsColIdx < rhsActivePanelWidth; rhsColIdx += params.RHSL1KernelCols {
			outputRowStart := lhsRowIdx
			outputColStart := rhsColIdx
			outputStride := params.RHSPanelCrossSize
			lhsKernelRows := params.LHSL1KernelRows
			accum_lhs0_rhs0 := hwy.Zero[hwy.BFloat16]()
			accum_lhs0_rhs1 := hwy.Zero[hwy.BFloat16]()
			accum_lhs1_rhs0 := hwy.Zero[hwy.BFloat16]()
			accum_lhs1_rhs1 := hwy.Zero[hwy.BFloat16]()
			accum_lhs2_rhs0 := hwy.Zero[hwy.BFloat16]()
			accum_lhs2_rhs1 := hwy.Zero[hwy.BFloat16]()
			accum_lhs3_rhs0 := hwy.Zero[hwy.BFloat16]()
			accum_lhs3_rhs1 := hwy.Zero[hwy.BFloat16]()
			idxLHS := lhsRowIdx * activeContractingLen
			for range activeContractingLen {
				rhsVec0 := hwy.Load(packedRHS[idxRHS:])
				rhsVec1 := hwy.Load(packedRHS[idxRHS+numLanes:])
				idxRHS += 2 * numLanes
				lhsVal0 := packedLHS[idxLHS+0]
				lhsVec0 := hwy.Set[hwy.BFloat16](lhsVal0)
				accum_lhs0_rhs0 = hwy.MulAdd(rhsVec0, lhsVec0, accum_lhs0_rhs0)
				accum_lhs0_rhs1 = hwy.MulAdd(rhsVec1, lhsVec0, accum_lhs0_rhs1)
				lhsVal1 := packedLHS[idxLHS+1]
				lhsVec1 := hwy.Set[hwy.BFloat16](lhsVal1)
				accum_lhs1_rhs0 = hwy.MulAdd(rhsVec0, lhsVec1, accum_lhs1_rhs0)
				accum_lhs1_rhs1 = hwy.MulAdd(rhsVec1, lhsVec1, accum_lhs1_rhs1)
				lhsVal2 := packedLHS[idxLHS+2]
				lhsVec2 := hwy.Set[hwy.BFloat16](lhsVal2)
				accum_lhs2_rhs0 = hwy.MulAdd(rhsVec0, lhsVec2, accum_lhs2_rhs0)
				accum_lhs2_rhs1 = hwy.MulAdd(rhsVec1, lhsVec2, accum_lhs2_rhs1)
				lhsVal3 := packedLHS[idxLHS+3]
				lhsVec3 := hwy.Set[hwy.BFloat16](lhsVal3)
				accum_lhs3_rhs0 = hwy.MulAdd(rhsVec0, lhsVec3, accum_lhs3_rhs0)
				accum_lhs3_rhs1 = hwy.MulAdd(rhsVec1, lhsVec3, accum_lhs3_rhs1)
				idxLHS += lhsKernelRows
			}
			outputIdx0 := outputRowStart*outputStride + outputColStart
			outputIdx1 := outputIdx0 + params.RHSPanelCrossSize
			outputIdx2 := outputIdx0 + 2*params.RHSPanelCrossSize
			outputIdx3 := outputIdx0 + 3*params.RHSPanelCrossSize
			hwy.Store(accum_lhs0_rhs0, packedOutput[outputIdx0:])
			hwy.Store(accum_lhs0_rhs1, packedOutput[outputIdx0+numLanes:])
			hwy.Store(accum_lhs1_rhs0, packedOutput[outputIdx1:])
			hwy.Store(accum_lhs1_rhs1, packedOutput[outputIdx1+numLanes:])
			hwy.Store(accum_lhs2_rhs0, packedOutput[outputIdx2:])
			hwy.Store(accum_lhs2_rhs1, packedOutput[outputIdx2+numLanes:])
			hwy.Store(accum_lhs3_rhs0, packedOutput[outputIdx3:])
			hwy.Store(accum_lhs3_rhs1, packedOutput[outputIdx3+numLanes:])
		}
	}
}

func BaseGEMMSymmetric16RegistersPanel_fallback(activeContractingLen int, packedLHS []float32, packedRHS []float32, packedOutput []float32, params *CacheParams, lhsActivePanelHeight int, rhsActivePanelWidth int) {
	_ = packedLHS[activeContractingLen*lhsActivePanelHeight-1]
	_ = packedRHS[activeContractingLen*rhsActivePanelWidth-1]
	_ = packedOutput[lhsActivePanelHeight*rhsActivePanelWidth-1]
	numLanes := 1
	for lhsRowIdx := 0; lhsRowIdx < lhsActivePanelHeight; lhsRowIdx += params.LHSL1KernelRows {
		idxRHS := 0
		for rhsColIdx := 0; rhsColIdx < rhsActivePanelWidth; rhsColIdx += params.RHSL1KernelCols {
			outputRowStart := lhsRowIdx
			outputColStart := rhsColIdx
			outputStride := params.RHSPanelCrossSize
			lhsKernelRows := params.LHSL1KernelRows
			accum_lhs0_rhs0 := float32(0)
			accum_lhs0_rhs1 := float32(0)
			accum_lhs1_rhs0 := float32(0)
			accum_lhs1_rhs1 := float32(0)
			accum_lhs2_rhs0 := float32(0)
			accum_lhs2_rhs1 := float32(0)
			accum_lhs3_rhs0 := float32(0)
			accum_lhs3_rhs1 := float32(0)
			idxLHS := lhsRowIdx * activeContractingLen
			for range activeContractingLen {
				rhsVec0 := packedRHS[idxRHS]
				rhsVec1 := packedRHS[idxRHS+numLanes]
				idxRHS += 2 * numLanes
				lhsVal0 := packedLHS[idxLHS+0]
				lhsVec0 := float32(lhsVal0)
				accum_lhs0_rhs0 = rhsVec0*lhsVec0 + accum_lhs0_rhs0
				accum_lhs0_rhs1 = rhsVec1*lhsVec0 + accum_lhs0_rhs1
				lhsVal1 := packedLHS[idxLHS+1]
				lhsVec1 := float32(lhsVal1)
				accum_lhs1_rhs0 = rhsVec0*lhsVec1 + accum_lhs1_rhs0
				accum_lhs1_rhs1 = rhsVec1*lhsVec1 + accum_lhs1_rhs1
				lhsVal2 := packedLHS[idxLHS+2]
				lhsVec2 := float32(lhsVal2)
				accum_lhs2_rhs0 = rhsVec0*lhsVec2 + accum_lhs2_rhs0
				accum_lhs2_rhs1 = rhsVec1*lhsVec2 + accum_lhs2_rhs1
				lhsVal3 := packedLHS[idxLHS+3]
				lhsVec3 := float32(lhsVal3)
				accum_lhs3_rhs0 = rhsVec0*lhsVec3 + accum_lhs3_rhs0
				accum_lhs3_rhs1 = rhsVec1*lhsVec3 + accum_lhs3_rhs1
				idxLHS += lhsKernelRows
			}
			outputIdx0 := outputRowStart*outputStride + outputColStart
			outputIdx1 := outputIdx0 + params.RHSPanelCrossSize
			outputIdx2 := outputIdx0 + 2*params.RHSPanelCrossSize
			outputIdx3 := outputIdx0 + 3*params.RHSPanelCrossSize
			packedOutput[outputIdx0] = accum_lhs0_rhs0
			packedOutput[outputIdx0+numLanes] = accum_lhs0_rhs1
			packedOutput[outputIdx1] = accum_lhs1_rhs0
			packedOutput[outputIdx1+numLanes] = accum_lhs1_rhs1
			packedOutput[outputIdx2] = accum_lhs2_rhs0
			packedOutput[outputIdx2+numLanes] = accum_lhs2_rhs1
			packedOutput[outputIdx3] = accum_lhs3_rhs0
			packedOutput[outputIdx3+numLanes] = accum_lhs3_rhs1
		}
	}
}

func BaseGEMMSymmetric16RegistersPanel_fallback_Float64(activeContractingLen int, packedLHS []float64, packedRHS []float64, packedOutput []float64, params *CacheParams, lhsActivePanelHeight int, rhsActivePanelWidth int) {
	_ = packedLHS[activeContractingLen*lhsActivePanelHeight-1]
	_ = packedRHS[activeContractingLen*rhsActivePanelWidth-1]
	_ = packedOutput[lhsActivePanelHeight*rhsActivePanelWidth-1]
	numLanes := 1
	for lhsRowIdx := 0; lhsRowIdx < lhsActivePanelHeight; lhsRowIdx += params.LHSL1KernelRows {
		idxRHS := 0
		for rhsColIdx := 0; rhsColIdx < rhsActivePanelWidth; rhsColIdx += params.RHSL1KernelCols {
			outputRowStart := lhsRowIdx
			outputColStart := rhsColIdx
			outputStride := params.RHSPanelCrossSize
			lhsKernelRows := params.LHSL1KernelRows
			accum_lhs0_rhs0 := float64(0)
			accum_lhs0_rhs1 := float64(0)
			accum_lhs1_rhs0 := float64(0)
			accum_lhs1_rhs1 := float64(0)
			accum_lhs2_rhs0 := float64(0)
			accum_lhs2_rhs1 := float64(0)
			accum_lhs3_rhs0 := float64(0)
			accum_lhs3_rhs1 := float64(0)
			idxLHS := lhsRowIdx * activeContractingLen
			for range activeContractingLen {
				rhsVec0 := packedRHS[idxRHS]
				rhsVec1 := packedRHS[idxRHS+numLanes]
				idxRHS += 2 * numLanes
				lhsVal0 := packedLHS[idxLHS+0]
				lhsVec0 := float64(lhsVal0)
				accum_lhs0_rhs0 = rhsVec0*lhsVec0 + accum_lhs0_rhs0
				accum_lhs0_rhs1 = rhsVec1*lhsVec0 + accum_lhs0_rhs1
				lhsVal1 := packedLHS[idxLHS+1]
				lhsVec1 := float64(lhsVal1)
				accum_lhs1_rhs0 = rhsVec0*lhsVec1 + accum_lhs1_rhs0
				accum_lhs1_rhs1 = rhsVec1*lhsVec1 + accum_lhs1_rhs1
				lhsVal2 := packedLHS[idxLHS+2]
				lhsVec2 := float64(lhsVal2)
				accum_lhs2_rhs0 = rhsVec0*lhsVec2 + accum_lhs2_rhs0
				accum_lhs2_rhs1 = rhsVec1*lhsVec2 + accum_lhs2_rhs1
				lhsVal3 := packedLHS[idxLHS+3]
				lhsVec3 := float64(lhsVal3)
				accum_lhs3_rhs0 = rhsVec0*lhsVec3 + accum_lhs3_rhs0
				accum_lhs3_rhs1 = rhsVec1*lhsVec3 + accum_lhs3_rhs1
				idxLHS += lhsKernelRows
			}
			outputIdx0 := outputRowStart*outputStride + outputColStart
			outputIdx1 := outputIdx0 + params.RHSPanelCrossSize
			outputIdx2 := outputIdx0 + 2*params.RHSPanelCrossSize
			outputIdx3 := outputIdx0 + 3*params.RHSPanelCrossSize
			packedOutput[outputIdx0] = accum_lhs0_rhs0
			packedOutput[outputIdx0+numLanes] = accum_lhs0_rhs1
			packedOutput[outputIdx1] = accum_lhs1_rhs0
			packedOutput[outputIdx1+numLanes] = accum_lhs1_rhs1
			packedOutput[outputIdx2] = accum_lhs2_rhs0
			packedOutput[outputIdx2+numLanes] = accum_lhs2_rhs1
			packedOutput[outputIdx3] = accum_lhs3_rhs0
			packedOutput[outputIdx3+numLanes] = accum_lhs3_rhs1
		}
	}
}
