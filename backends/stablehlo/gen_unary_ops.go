/***** File generated by ./internal/cmd/stable_generator, based on the backends' ops. Don't edit it directly. *****/

package stablehlo

import (
	"github.com/gomlx/gomlx/backends"
)

// BitCount returns the number of bits that are set to one.
func (b *Builder) BitCount(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeBitCount.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Popcnt(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Abs returns the Op that represents the output of the corresponding operation.
func (b *Builder) Abs(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeAbs.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Abs(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// BitwiseNot returns the element-wise bitwise AND operation.
func (b *Builder) BitwiseNot(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeBitwiseNot.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Not(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Ceil returns the Op that represents the output of the corresponding operation.
func (b *Builder) Ceil(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeCeil.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Ceil(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Clz returns element-wise the "count leading zeros" bits of input node x -- for integer values.
func (b *Builder) Clz(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeClz.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.CountLeadingZeros(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Cos returns the Op that represents the output of the corresponding operation.
func (b *Builder) Cos(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeCos.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Cosine(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Erf returns the "error function", defined as erf(x) = 2/Pi * \int_{0}^{x}{e^{-t^2}dt}.
func (b *Builder) Erf(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeErf.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Erf(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Exp returns the Op that represents the output of the corresponding operation.
func (b *Builder) Exp(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeExp.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Exponential(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Expm1 returns the Op that represents the output of the corresponding operation.
func (b *Builder) Expm1(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeExpm1.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.ExponentialMinusOne(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Floor returns the Op that represents the output of the corresponding operation.
func (b *Builder) Floor(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeFloor.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Floor(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Imag returns the imaginary part of a complex number. It returns 0 if the x is a float number.
func (b *Builder) Imag(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeImag.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Imag(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// IsFinite tests whether each element of operand is finite, i.e., is not positive or negative infinity, and is not NaN.
// It returns an array of boolean values with the same shape as the input, where each element is true if and only if
// the corresponding input element is finite.
func (b *Builder) IsFinite(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeIsFinite.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.IsFinite(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Log returns the Op that represents the output of the corresponding operation.
func (b *Builder) Log(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeLog.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Log(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Log1p returns the expression log(x+1).
func (b *Builder) Log1p(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeLog1p.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.LogPlusOne(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// LogicalNot returns the Op that represents the output of the corresponding operation.
func (b *Builder) LogicalNot(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeLogicalNot.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Not(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Logistic returns the element-wise expression 1/(1+exp(-x)). Also known as the Sigmoid function.
func (b *Builder) Logistic(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeLogistic.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Logistic(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Neg returns the Op that represents the output of the corresponding operation.
func (b *Builder) Neg(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeNeg.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Negate(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Real return the real part of a complex number. It returns x if the x is a float number.
func (b *Builder) Real(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeReal.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Real(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Round returns the Op that represents the output of the corresponding operation.
func (b *Builder) Round(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeRound.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.RoundNearestEven(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Rsqrt returns the element-wise reciprocal of square root operation 1/sqrt(x).
func (b *Builder) Rsqrt(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeRsqrt.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Rsqrt(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Sign returns element-wise +1, +/-0 or -1 depending on the sign of x. It returns NaN if the input is NaN.
func (b *Builder) Sign(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeSign.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Sign(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Sin returns the Op that represents the output of the corresponding operation.
func (b *Builder) Sin(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeSin.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Sine(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Sqrt returns the Op that represents the output of the corresponding operation.
func (b *Builder) Sqrt(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeSqrt.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Sqrt(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Tanh returns the Op that represents the output of the corresponding operation.
func (b *Builder) Tanh(operand backends.Op) (backends.Op, error) {
	operandNode, err := b.verifyAndCastOp(operand, backends.OpTypeTanh.String())
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Tanh(operandNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}
