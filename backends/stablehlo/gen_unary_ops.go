/***** File generated by ./internal/cmd/stable_generator, based on the backends' ops. Don't edit it directly. *****/

package stablehlo

import (
	"github.com/gomlx/gomlx/backends"
	"github.com/gomlx/stablehlo"
)

// BitCount returns the number of bits that are set to one.
// Also known as Population Count ("Popcnt") or Hamming Weight.
func (b *Builder) BitCount(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("BitCount", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Popcnt(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// BitwiseNot returns the element-wise bitwise AND operation.
func (b *Builder) BitwiseNot(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("BitwiseNot", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Not(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Ceil returns the Op that represents the output of the corresponding operation.
func (b *Builder) Ceil(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Ceil", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Ceil(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Clz returns element-wise the "count leading zeros" bits of input node x -- for integer values.
func (b *Builder) Clz(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Clz", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.CountLeadingZeros(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Cos returns the Op that represents the output of the corresponding operation.
func (b *Builder) Cos(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Cos", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Cosine(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Erf returns the "error function", defined as erf(x) = 2/Pi * \int_{0}^{x}{e^{-t^2}dt}.
func (b *Builder) Erf(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Erf", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Erf(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Exp returns the Op that represents the output of the corresponding operation.
func (b *Builder) Exp(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Exp", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Exponential(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Expm1 returns the Op that represents the output of the corresponding operation.
func (b *Builder) Expm1(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Expm1", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.ExponentialMinusOne(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Floor returns the Op that represents the output of the corresponding operation.
func (b *Builder) Floor(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Floor", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Floor(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Imag returns the imaginary part of a complex number. It returns 0 if the x is a float number.
func (b *Builder) Imag(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Imag", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Imag(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// IsFinite tests whether each element of operand is finite, i.e., if it is not positive nor negative infinity, and it is not NaN.
// It returns the same shape as the input, but with boolean values where each element is true if and only if
// the corresponding input element is finite.
func (b *Builder) IsFinite(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("IsFinite", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.IsFinite(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Log returns the Op that represents the output of the corresponding operation.
func (b *Builder) Log(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Log", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Log(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Log1p returns the expression log(x+1).
func (b *Builder) Log1p(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Log1p", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.LogPlusOne(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// LogicalNot returns the Op that represents the output of the corresponding operation.
func (b *Builder) LogicalNot(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("LogicalNot", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Not(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Logistic returns the element-wise expression 1/(1+exp(-x)). Also known as the Sigmoid function.
func (b *Builder) Logistic(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Logistic", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Logistic(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Neg returns the Op that represents the output of the corresponding operation.
func (b *Builder) Neg(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Neg", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Negate(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Real return the real part of a complex number. It returns x if the x is a float number.
func (b *Builder) Real(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Real", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Real(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Round returns the Op that represents the output of the corresponding operation.
// This operation rounds to the nearest even.
func (b *Builder) Round(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Round", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.RoundNearestEven(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Rsqrt returns the element-wise reciprocal of square root operation 1/sqrt(x).
func (b *Builder) Rsqrt(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Rsqrt", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Rsqrt(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Sign returns element-wise +1, +/-0 or -1 depending on the sign of x. It returns NaN if the input is NaN.
func (b *Builder) Sign(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Sign", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Sign(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Sin returns the Op that represents the output of the corresponding operation.
func (b *Builder) Sin(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Sin", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Sine(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Sqrt returns the Op that represents the output of the corresponding operation.
func (b *Builder) Sqrt(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Sqrt", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Sqrt(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Tanh returns the Op that represents the output of the corresponding operation.
func (b *Builder) Tanh(operand backends.Op) (backends.Op, error) {
	nodes, err := b.verifyAndCastValues("Tanh", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Tanh(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}
