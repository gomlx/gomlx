/***** File generated by ./internal/cmd/stable_generator, based on backends ops. Don't edit it directly. *****/

package stablehlo

import (
	"github.com/gomlx/gomlx/backends"
	"github.com/pkg/errors"
)

// Add returns the element-wise sum of the two values.
// Standard broadcasting rules apply (see documentation).
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Add(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeAdd, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Add(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// BitwiseAnd returns the element-wise bitwise AND operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) BitwiseAnd(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeBitwiseAnd, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.And(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// BitwiseOr returns the element-wise bitwise OR operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) BitwiseOr(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeBitwiseOr, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Or(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// BitwiseXor returns the element-wise bitwise XOR operator.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) BitwiseXor(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeBitwiseXor, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Xor(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Complex returns the complex number taking x0 as the real part and x1 as the imaginary part.
// The real (x0) and imaginary (x1) must have the same dtype, and they must be either `dtypes.Float32` or
// `dtypes.Float64`.
// The output will be either `dtypes.Complex64` or `dtypes.Complex128`, depending on x0 and x1 dtypes.
// The shapes of `real` or `imaginary` must be the same, or one must be a scalar, in which case
// the value is broadcast to every other value.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Complex(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeComplex, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Complex(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Div returns the element-wise division of the two values.
// Standard broadcasting rules apply (see documentation).
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Div(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeDiv, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Divide(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Equal performs element-wise equality check, returns boolean results with the same dimensions as input.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Equal(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeEqual, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Compare(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// EqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) EqualTotalOrder(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeEqualTotalOrder, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.EqualTotalOrder(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// GreaterOrEqual performs element-wise comparison, returns boolean results with the same dimensions as input.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) GreaterOrEqual(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeGreaterOrEqual, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Compare(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// GreaterOrEqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) GreaterOrEqualTotalOrder(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeGreaterOrEqualTotalOrder, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.GreaterOrEqualTotalOrder(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// GreaterThan performs element-wise comparison, returns boolean results with the same dimensions as input.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) GreaterThan(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeGreaterThan, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Compare(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// GreaterThanTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) GreaterThanTotalOrder(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeGreaterThanTotalOrder, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.GreaterThanTotalOrder(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// LessOrEqual performs element-wise comparison, returns boolean results with the same dimensions as input.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) LessOrEqual(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeLessOrEqual, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Compare(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// LessOrEqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) LessOrEqualTotalOrder(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeLessOrEqualTotalOrder, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.LessOrEqualTotalOrder(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// LessThan performs element-wise comparison, returns boolean results with the same dimensions as input.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) LessThan(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeLessThan, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Compare(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// LessThanTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) LessThanTotalOrder(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeLessThanTotalOrder, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.LessThanTotalOrder(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// LogicalAnd returns the element-wise logical AND operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) LogicalAnd(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeLogicalAnd, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.And(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// LogicalOr returns the element-wise logical OR operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) LogicalOr(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeLogicalOr, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Or(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// LogicalXor returns the element-wise logical XOR operator.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) LogicalXor(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeLogicalXor, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Xor(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Max returns the element-wise highest value among the two.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Max(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeMax, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Max(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Min returns the element-wise smallest value among the two.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Min(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeMin, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Min(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Mul returns the element-wise multiplication of the two values.
// Standard broadcasting rules apply (see documentation).
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Mul(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeMul, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Multiply(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// NotEqual performs element-wise inequality check, returns boolean results with the same dimensions as input.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) NotEqual(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeNotEqual, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Compare(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// NotEqualTotalOrder returns the element-wise operation.
// Standard broadcasting rules apply (see documentation).
// The "TotalOrder" version of the operation enforces `-NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN`.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) NotEqualTotalOrder(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeNotEqualTotalOrder, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.NotEqualTotalOrder(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Pow returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Pow(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypePow, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Pow(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Rem returns the remainder operation, also known as modulo (or Mod for short).
// Notice despite the name XLA implements Mod not IEEE754 Remainder operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Rem(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeRem, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Rem(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// ShiftLeft n bits. It implicitly preserves the sign bit, if there is no overflow. So ShiftLeft(-1, 1) = -2.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) ShiftLeft(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeShiftLeft, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.ShiftLeft(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// ShiftRightArithmetic shifts right by n bits, preserving the sign bit. So ShiftRight(-2, 1) = -1.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) ShiftRightArithmetic(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeShiftRightArithmetic, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.ShiftRightArithmetic(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// ShiftRightLogical shifts right by n bits, destroying the sign bit.
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) ShiftRightLogical(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeShiftRightLogical, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.ShiftRightLogical(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Sub returns the element-wise subtraction of the two values.
// Standard broadcasting rules apply (see documentation).
// The op is created on the same XlaBuilder as used for x0 and x1.
func (b *Builder) Sub(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeSub, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := b.fn.Sub(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}
