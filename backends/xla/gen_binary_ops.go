/***** File generated by ./internal/cmd/stable_generator, based on the backends' ops. Don't edit it directly. *****/

package xla

import (
	"github.com/gomlx/go-xla/pkg/stablehlo"
	"github.com/gomlx/gomlx/backends"
)

// Add returns the element-wise sum of the two values.
// Standard broadcasting rules apply (see documentation).
func (b *Builder) Add(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeAdd, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Add(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// BitwiseAnd returns the element-wise bitwise AND operation.
func (b *Builder) BitwiseAnd(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeBitwiseAnd, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.And(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// BitwiseOr returns the element-wise bitwise OR operation.
func (b *Builder) BitwiseOr(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeBitwiseOr, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Or(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// BitwiseXor returns the element-wise bitwise XOR operator.
func (b *Builder) BitwiseXor(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeBitwiseXor, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Xor(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Complex returns the complex number taking x0 as the real part and x1 as the imaginary part.
// The real (x0) and imaginary (x1) must have the same dtype, and they must be either `dtypes.Float32` or
// `dtypes.Float64`.
// The output will be either `dtypes.Complex64` or `dtypes.Complex128`, depending on x0 and x1 dtypes.
// The shapes of `real` or `imaginary` must be the same, or one must be a scalar, in which case
// the value is broadcast to every other value.
func (b *Builder) Complex(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeComplex, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Complex(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Div returns the element-wise division of the two values.
// Standard broadcasting rules apply (see documentation).
func (b *Builder) Div(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeDiv, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Divide(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// LogicalAnd returns the element-wise logical AND operation.
func (b *Builder) LogicalAnd(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeLogicalAnd, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.And(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// LogicalOr returns the element-wise logical OR operation.
func (b *Builder) LogicalOr(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeLogicalOr, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Or(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// LogicalXor returns the element-wise logical XOR operator.
func (b *Builder) LogicalXor(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeLogicalXor, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Xor(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Max returns the element-wise highest value among the two.
func (b *Builder) Max(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeMax, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Maximum(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Min returns the element-wise smallest value among the two.
func (b *Builder) Min(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeMin, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Minimum(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Mul returns the element-wise multiplication of the two values.
// Standard broadcasting rules apply (see documentation).
func (b *Builder) Mul(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeMul, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Multiply(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Pow returns the Op that represents the output of the corresponding operation.
func (b *Builder) Pow(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypePow, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Power(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Rem returns the remainder operation, also known as modulo (or Mod for short).
// Notice despite the name XLA implements Mod not IEEE754 Remainder operation.
func (b *Builder) Rem(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeRem, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Remainder(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// ShiftLeft n bits. It implicitly preserves the sign bit if there is no overflow. So ShiftLeft(-1, 1) = -2.
func (b *Builder) ShiftLeft(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeShiftLeft, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.ShiftLeft(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// ShiftRightArithmetic shifts right by n bits, preserving the sign bit. So ShiftRight(-2, 1) = -1.
func (b *Builder) ShiftRightArithmetic(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeShiftRightArithmetic, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.ShiftRightArithmetic(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// ShiftRightLogical shifts right by n bits, destroying the sign bit.
func (b *Builder) ShiftRightLogical(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeShiftRightLogical, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.ShiftRightLogical(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}

// Sub returns the element-wise subtraction of the two values.
// Standard broadcasting rules apply (see documentation).
func (b *Builder) Sub(lhs, rhs backends.Op) (backends.Op, error) {
	lhsNode, rhsNode, err := b.broadcastForBinaryOps(backends.OpTypeSub, lhs, rhs)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Subtract(lhsNode.value, rhsNode.value)
	if err != nil {
		return nil, err
	}
	return b.newNode(value), nil
}
