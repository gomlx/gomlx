/***** File generated by ./internal/cmd/xla_generator, based on the backends' ops. Don't edit it directly. *****/

package xla

import (
	"github.com/gomlx/go-xla/pkg/stablehlo"
	"github.com/gomlx/gomlx/backends"
)

// BitCount returns the number of bits that are set to one.
// Also known as Population Count ("Popcnt") or Hamming Weight.
func (f *Function) BitCount(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("BitCount", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Popcnt(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// BitwiseNot returns the element-wise bitwise AND operation.
func (f *Function) BitwiseNot(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("BitwiseNot", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Not(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Ceil returns the Op that represents the output of the corresponding operation.
func (f *Function) Ceil(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Ceil", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Ceil(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Clz returns element-wise the "count leading zeros" bits of input node x -- for integer values.
func (f *Function) Clz(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Clz", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.CountLeadingZeros(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Cos returns the Op that represents the output of the corresponding operation.
func (f *Function) Cos(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Cos", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Cosine(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Erf returns the "error function", defined as erf(x) = 2/Pi * \int_{0}^{x}{e^{-t^2}dt}.
func (f *Function) Erf(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Erf", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Erf(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Exp returns the Op that represents the output of the corresponding operation.
func (f *Function) Exp(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Exp", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Exponential(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Expm1 returns the Op that represents the output of the corresponding operation.
func (f *Function) Expm1(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Expm1", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.ExponentialMinusOne(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Floor returns the Op that represents the output of the corresponding operation.
func (f *Function) Floor(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Floor", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Floor(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Imag returns the imaginary part of a complex number. It returns 0 if the x is a float number.
func (f *Function) Imag(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Imag", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Imag(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// IsFinite tests whether each element of operand is finite, i.e., if it is not positive nor negative infinity, and it is not NaN.
// It returns the same shape as the input, but with boolean values where each element is true if and only if
// the corresponding input element is finite.
func (f *Function) IsFinite(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("IsFinite", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.IsFinite(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Log returns the Op that represents the output of the corresponding operation.
func (f *Function) Log(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Log", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Log(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Log1p returns the expression log(x+1).
func (f *Function) Log1p(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Log1p", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.LogPlusOne(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// LogicalNot returns the Op that represents the output of the corresponding operation.
func (f *Function) LogicalNot(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("LogicalNot", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Not(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Logistic returns the element-wise expression 1/(1+exp(-x)). Also known as the Sigmoid function.
func (f *Function) Logistic(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Logistic", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Logistic(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Neg returns the Op that represents the output of the corresponding operation.
func (f *Function) Neg(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Neg", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Negate(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Real return the real part of a complex number. It returns x if the x is a float number.
func (f *Function) Real(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Real", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Real(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Round returns the Op that represents the output of the corresponding operation.
// This operation rounds to the nearest even.
func (f *Function) Round(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Round", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.RoundNearestEven(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Rsqrt returns the element-wise reciprocal of square root operation 1/sqrt(x).
func (f *Function) Rsqrt(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Rsqrt", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Rsqrt(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Sign returns element-wise +1, +/-0 or -1 depending on the sign of x. It returns NaN if the input is NaN.
func (f *Function) Sign(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Sign", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Sign(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Sin returns the Op that represents the output of the corresponding operation.
func (f *Function) Sin(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Sin", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Sine(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Sqrt returns the Op that represents the output of the corresponding operation.
func (f *Function) Sqrt(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Sqrt", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Sqrt(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}

// Tanh returns the Op that represents the output of the corresponding operation.
func (f *Function) Tanh(operand backends.Value) (backends.Value, error) {
	nodes, err := f.verifyAndCastValues("Tanh", operand)
	if err != nil {
		return nil, err
	}
	value, err := stablehlo.Tanh(nodes[0].value)
	if err != nil {
		return nil, err
	}
	return f.newNode(value), nil
}
